# 模块

Nim支持将一个程序拆分成模块的概念。每一个模块是一个Nim文件。模块能够隐藏信息，并且可以单独编译。一个模块可以通过import语句访问其他模块中的符号，仅仅是被 * 标记的顶层符号才能被其他模块使用。一个有效的模块名称仅仅是一个有效的Nim标识符

一个模块的顶层语句当程序开始时将执行，这个可以用来初始化复杂的数据结构。每一个模块都有一个特别的魔法常量isMainModule，如果这个模块作为一个main文件被编译，那么它是true。这对于嵌入模块测试是非常有用的

### 编译模块的算法：

像往常一样编译整个模块，接着是递归import语句。

如果有一个循环仅仅导入已经解析的符号（它被输出）；如果出现一个未知的标识符，那么终止。

```
# Module mA
type
  T1* = int  # Module mA exports the type ``T1``
import mB     # the compiler starts parsing mB

proc main() =
  var i = p(3) # works because mB has been parsed completely here

main()

```

```
# Module mB
import mA  # mA is not parsed here! Only the already known symbols
          # of mA are imported.

proc p*(x: mA.T1): mA.T1 =
  # this works because the compiler has already
  # added T1 to mA's interface symbol table
  result = x + 1
```

## import expect语句

**import语句将导入所有的导出符号。可以通过except限定符限制要排除在外的符号，这样在这个模块中就不能使用该符号了。**

```
import strutils except `%`, toUpper

# doesn't work then:
echo "$1" % "abc".toUpper
```

### from import语句

仅仅导入列出的符号：

```
from strutils import `%`

echo "$1" % "abc"
# always possible: full qualification:
echo strutils.replace("abc", "a", "z")
```

From语句开业i堆符号进行强制的命名空间限制，从而使符号可用，但需要被限定使用：

```
#Module  mymodule
proc x*() =
  echo "this is x proc"

proc y*() =
  echo "this is y proc"

proc z*() =
  echo "this is z proc"
```

```
from mymodule import x,y,z

x() // use x without any qualification
```

使用as 可以给模块其别名：

```
from mymodule as m import nil
m.x()
```

### include语句

不同于import，include语句与导入一个模块有一些根本的不同:他仅仅包含一个文件的内容。include语句把一个大模块分成几个文件

```
#Module fileA
type
  Person = object
    name: string
    age: int
```

```
#module fileB
proc print(x:Person)=
  neme:string
  age:int
```

```
include fileA, fileB

var student: Person
student.name = "yrs"
student.age = 22
student.print()
```

include就像是把文件fileA和fileB都包括在最后一个测试文件内，它们像是一个模块，文**件fileA和fileB中的标识符不用使用 * 进行标记就能在最后一个文件中使用。而import语句导入模块，只导人被 * 标记的标识符。**

### Export语句

用于符号转发

```
#module B
type myobj*=object
```

```
#module A
import B 
export B.myobj
proc `$`*(x: MyObject): string = "my object"
```

```
# module C
import A

# B.MyObject has been imported implicitly here:
var x: MyObject
echo($x)
```

### 路径

如果模块路径的任何部分以一个数字开始，必须用双引号把路径括器来

```
import "gfx/3d/somemodule"
```

```
# module mexportb
type TMyObject* = object

const xyz* = 13

proc q*(x: int): int = 6
proc q*(x: string): string = "8"
```

```
# module mexporta
import mexportb
export mexportb.TMyObject, mexportb.xyz

export mexportb.q

proc `$`*(x: TMyObject): string = "my object"
```







