## 二进制格式

### 结构

看rust一段代码：

```shell
cargo new name --lib
```

`cargo.toml` 配置

```toml
[lib]
crate-type=["cdylib"]
```



```rust
extern "C" {fn random_i32()->i32;}
#[no_mangle]
pub extern "C" fn discard (){
    unsafe {let _=random_i32();}
}
```

将这段源码编译之后

```shell
cargo build -target wasm32-unknown-unknown --release
```

接着执行

```shell
wasm-objdump -x name.wasm


...
Section Details:

Type[2]:
 - type[0] () -> i32
 - type[1] () -> nil
Import[1]:
 - func[0] sig=0 <random_i32> <- env.random_i32
Function[1]:
 - func[1] sig=1 <discard>
Table[1]:
 - table[0] type=funcref initial=1 max=1
Memory[1]:
 - memory[0] pages: initial=16
Global[3]:
 - global[0] i32 mutable=1 <__stack_pointer> - init i32=1048576
 - global[1] i32 mutable=0 <__data_end> - init i32=1048576
 - global[2] i32 mutable=0 <__heap_base> - init i32=1048576
Export[4]:
 - memory[0] -> "memory"
 - func[1] <discard> -> "discard"
 - global[1] -> "__data_end"
 - global[2] -> "__heap_base"
Code[1]:
 - func[1] size=9 <discard>
 ...
```

从上述二进制文件的简略信息中可以看出，该文件的组成部分：`Type` `Import` `Function` `Table` `Memory` `Global` `Export` `Code`,这些都是wasm 二进制文件的项目中的一部分。

wasm规范一共定义了12个段，每个段都分配了ID(0--11)

完整的wasm二进制文件的项目划分见下表：

| magic number  version | 以魔数和版本号开头                                           |
| --------------------- | ------------------------------------------------------------ |
|                       | 自定义段 ID 0 这段是给编译器工具使用的，可以存放函数名等调试信息，或其他附加信息。 |
| TypeSec               | 类型段 ID 1  本例中为`Type[2]` random_i32()->i32             |
| ImprotSec             | 导入段 ID 2  本例中为`Import[1]  ` <random_i32> <- env.random_i32 |
| FuncSec               | 函数段 ID 3  本例中为 `Func[1]` discard                      |
| TableSec              | 表段 ID 4   本例中为`type=funcref initial=1 max=1` 列出了模块内定义定义的所有的表，wasm规定最多只能导入和定义一张表 |
| MemroySec             | 内存段 ID 5 本例中为`pages: initial=16`列出模块定义需要的内存空间 |
| GlobalSec             | 全局段 ID 6 本例中为`Global[3]:` 包含模块内定义的全局变量信息，包含值类型、可变性、初始值。 |
| ExportSec             | 导出段  ID 7 本例中`Export[4]:` discard 方法， 至于memory等则是rust 内部实现的。 |
| StartSec              | 起始段 ID 8  给出模块起始函数索引，不同于其他的段，该段只能有一个项目，主要功能：1）在模块加载后进行一些初始化的工作 2） 将模块变成可执行模块。 |
| ElEMSec               | 元素段 ID 9  对应Table elem 表示表内初始化的数据             |
| CodeSec               | 代码段 ID 10 本例中为`func[1] size=9 <discard>`  存储内部函数局部变量的信息和字节码，与函数段一一对应 |
| DataSec               | 数据段 ID 11 列出内存初始化的数据。                          |



### 实体类型

#### 值类型

wasm定义了四种基本的数值类型 32位整数、64位整数、32位浮点数、64位浮点数。高级语言所支持的类型，如布尔类型、指针、结构体等，都是被编译器翻译成这四种基础的值类型。，不同于高级语言，wasm值类型并不会区分符号

#### 函数类型

即函数的签名，描述函数的参数数量和类型，以及返回值和类型

#### 限制类型

描述表元素的数量和内存页数的上下限

#### 内存类型

描述内存的页数限制

#### 表类型

表的元素类型以及元素限制

#### 全局变量

描述全局变量的类型和可变性

#### 结果类型

函数或表达式的执行结果

#### 导出类型

函数类型、表类型、内存类型和全局变量类型的集合

 

### 指令集

和汇编代码一样，wasm二进制模块中的代码也是由多条的指令构成。

wasm的指令包含两部分的信息：操作码和操作数。操作码是指指令的ID，决定指令将执行的操作；操作数相当于指令的参数，决定指令的执行结果。

操作数又分为：

- 静态操作数：直接编码在指令里边，跟在操作码后边
- 动态操作数：在运行时从操作数栈获取

#### 操作码

wasm的操作码固定一个字节，因此指令集最多有256条指令。wasm规范一共定义了178条指，按照功能可以分为5大类：

1. 控制指令：共13条
2. 参数指令： 共2条
3. 变量指令：共5条
4. 内存指令：共25条
5. 数值指令：共133条

#### 数值指令

格式为前缀操作码 + 子操作码（立即数），在所有的数值指令中，只有4条常量指令和饱和截断指令有立即数：

- i32.const （opcode 0x41） 带一个s32的立即数，使用LEB128有符号编码格式
  - LEB128 编码格式： 是一种变长的编码格式，对于32位的整数来说，编码之后可能变为1--5字节，64位整数可能变为1--10字节.越小的整数，编码之后占用的字节数越小。
    - 采用小端编码方式，低位在前，高位在后
    - 采用128进制，每7bit为一组，由第一个字节的第7位承载，空出来的最高位则是标志位，1表示还有后续字节，0表示没有。
- i64.const (opcode 0x42) 带一个s64的立即数，使用LEB128有符号编码格式
- f32.const  (opcode 0x43) 带一个f32的立即数，固定占用4字节
- f64.const (opcode 0x44) 带一个f64类型的立即数，固定占用8字节
- trunc_sat (opcode 0xFC) 带一个单字节立即数，将浮点数截断为整数

例：

```wat
(module
	(f32.const 1.32) (f32.const 3.1415) (f32.add)
	(f32.trunc_sat_f32_2) (drop)
)
```

讲wat文件编译为二进制文件

```shell
wat2wasm name.wat -o name.wasm
```

借助wasm-objdump 工具查看wasm文件的详细信息：

```shell
wasm-objdump -d name.wasm

Code Disassembly:

000016 func[0]:
000017: 43 a4 70 9d 3f             | f32.const 0x1.3ae148p+0
00001c: 43 56 0e 49 40             | f32.const 0x1.921cacp+1
000021: 92                         | f32.add
000022: fc 00                      | i32.trunc_sat_f32_s
000024: 1a                         | drop
000025: 0b                         | end
```

在wat文件中设置了两个f32的常量，并将两个数相加，随后进行截断，根据解析的wasm文件可以看出  `f32.const `---> `0x43`  `turnc_ast`--->` 0xfc`  `end` ---> `0x0b`  `add` -->`0x92`  `drop`--> `0x1a`

同理使用xxd 命令也可以看出相应的操作

```shell
xxd -g -u 1 name.wasm

00000000: 00 61 73 6D 01 00 00 00 01 04 01 60 00 00 03 02  .asm.......`....
00000010: 01 00 0A 12 01 10 00 43 A4 70 9D 3F 43 56 0E 49  .......C.p.?CV.I
00000020: 40 92 FC 00 1A 0B                                @.....
```

#### 变量指令

变量指令共5条，其中3条用于读写局部变量，剩余的2条是用来读写全局变量，立即数都是变量的索引。

例：

```
(module
	
   (global $g1 (mut i32)(i32.const 15 ))  ;; 全局变量
   (global $g2 (mut i32)(i32.const 20 ))


   (func(param $a i32) (param $b i32)  ;;声明函数 获取全局变量，以及函数中的局部变量
       (global.get $g1) (global.set $g2)  
       (local.get $a) (local.set $b)

   )

)
```

编译之后，使用wasm-objdump 工具对二进制文件进行分析

```shell
Code Disassembly:

000025 func[0]:
000026: 23 00                      | global.get 0   // 获取去全局变量
000028: 24 01                      | global.set 1   // 设置全局变量
00002a: 20 00                      | local.get 0    // 获取局部变量
00002c: 21 01                      | local.set 1    // 设置局部变量
00002e: 0b                         | end
```

xxd 命令同上

```shell
00000000: 00 61 73 6D 01 00 00 00 01 06 01 60 02 7F 7F 00  .asm.......`....
00000010: 03 02 01 00 06 0B 02 7F 01 41 0F 0B 7F 01 41 14  .........A....A.
00000020: 0B 0A 0C 01 0A 00 23 00 24 01 20 00 21 01 0B     ......#.$. .!..
```

#### 内存指令

内存指令共25条，其中14条用于将内存数据加载到操作数栈，9条存储指令，将操作数栈顶的数据写回内存，加载，存储的这些指令带有两个操作数：对齐提示、内存偏移量。

剩余的指令用于获取和扩展内存页数，操作数为内存索引，由于wasm规范规定，模块只能导入和定义一块内存，因此内存索引，目前只起到占位的作用，index ==0。

> tip：内存可以在限制范围内动态增长，增长必须以页为单位，一页是 **64KB** 即 65536 字节。内存页数总数不能超过65536，也就是一个wasm的内存不能超过**4GB**

例：

```shell
   (memory 1 8)
   ;; 将memory 设置初始page = 1  max = 8   此处可以先将max 设置为65537 观察终端中的错误信息。
   ;; error: max pages (65537) must be <= (65536) 
   ;; (memory 1 65537) 
   
   
   (data (offset (i32.const 100)) "hello")
   (func

       (i32.const 1) (i32.const 2)
       (i32.load offset=100)
       (i32.store offset=100)
       (memory.size) (drop)
       (i32.const 4 ) (memory.grow) (drop)
   )
```

编译之后使用wasm-odjdump 命令查看二进制文件

```shell
wasm-objdump -d name.wasm


Code Disassembly:

00001c func[0]:
00001d: 41 01                      | i32.const 1
00001f: 41 02                      | i32.const 2
000021: 28 02 64                   | i32.load 2 100
000024: 36 02 64                   | i32.store 2 100
000027: 3f 00                      | memory.size 0
000029: 1a                         | drop
00002a: 41 04                      | i32.const 4
00002c: 40 00                      | memory.grow 0
00002e: 1a                         | drop
00002f: 0b                         | end
```

#### 结构化控制指令

































