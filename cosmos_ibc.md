## cosmos ibc 

[QTech (hyperchain.cn)](https://tech.hyperchain.cn/) blockchian blog



IBC 是一种分层协议，由一下两层组成：

- 较低的传输、认证、排序层(IBC/TAO)
- 建立在TAO之上的上层应用层(IBC/APP)

区块链间通信协议 (IBC) 允许区块链相互通信。作为 Cosmos 生态系统的支柱，IBC 处理跨不同主权区块链的传输。这种端到端、面向连接的有状态协议在异构区块链之间提供可靠、有序和经过身份验证的通信。



通道和端口的抽象层详细信息与应用程序开发人员相关。您可以定义自己的自定义数据包和 IBCModule 回调

模块必须满足以下的要求才能和IBC进行交互：

- 绑定一个或多个端口
- 定义数据包数据
- 定义可选的确认结构和方法来编码、解码他们
- 实现IBCModule 接口

> IBC 应用程序编写为独立的**模块**。一个区块链上的模块可以通过`(channelID, portID)`元组唯一标识的通道发送、接收和确认数据包，与其他区块链上的其他模块通信。



### IBC/TAO

用于两个区块链之间可靠、有序和经过身份验证的方式中继数据包的层。

- “可靠”意味着只有源链准确发送的数据包才会被目标链准确接收。
- “有序”意味着目标链以与源链发送数据包相同的顺序接收数据包。
- “已认证”意味着 IBC 在中继数据包时使用channel，并且通道的每一端都专门分配给特定的智能合约。因此，如果目标链通过通道接收到数据包，则证明分配给源链上通道的特定智能合约发送了数据包，并且任何其他智能合约都不能使用该通道发送数据包。

IBC/TAO 被实现为智能合约，在通过 IBC 相互连接的两个区块链上运行，组成组件：

- client
- connection
- channel

#### client

每当一个新的区块头附加到对面的区块链时，中继器都会查询该区块头并将其提交给本地区块链上的 IBC/TAO 模块。然后 IBC/TAO 模块根据对端区块链执行轻客户端协议，检查区块头是否有效，并仅在区块头有效时更新其 *ClientState* 对端区块链。 （维护一个轻节点）



### IBC/APP



### 组件

#### Client

IBC 客户端是由唯一客户端 ID 标识的轻客户端。IBC 客户端跟踪其他区块链的共识状态以及这些区块链的证明规范，这些区块链需要根据客户端的共识状态正确验证证明。



#### Connection

连接将两个对象封装`ConnectionEnd`在两个独立的区块链上。每个`ConnectionEnd`都与另一个区块链（交易对手区块链）的客户端相关联。连接握手负责验证每条链上的轻客户端对于各自的交易对手来说是正确的。连接一旦建立，负责促进 IBC 状态的所有跨链验证。一个连接可以与任意数量的通道相关联。

####  proofs  paths

在IBC中区块链不会和通过网络之哦姐相互传递消息

- 为了进行通信，区块链将某些状态提交给为特定消息类型和特定交易对手保留的精确定义的路径。
- 中继进程监视这些路径的更新，并通过将存储在路径下的数据连同该数据的证明提交给交易对手链来中继消息。

#### port

IBC 模块可以绑定到任意数量的端口。每个端口必须由唯一的`portID`.  由于 IBC 被设计为与在同一分类帐上运行的相互不信任的模块一起确保安全，因此绑定端口会返回动态对象功能



#### channel

在两个 IBC 端口之间建立 IBC 通道。端口由单个模块独占。IBC 数据包通过通道发送。

- 通道可以`ORDERED`使得来自发送模块的数据包必须由接收模块按照发送的顺序进行处理。
- 一个通道可以`UNORDERED`使来自发送模块的数据包按照它们到达的顺序被处理，这可能不是数据包被发送的顺序。



通道握手的步骤：

1. A 发送一条`ChainOpenInit`的消息来表示与链B的通道初始化
2. B 发送一条`ChainOpenTry` 的消息尝试打开链A上的通道
3. A 发送`ChainOpenAck`将其通道结束状态标记为打开
4. B 发送`ChainOpenConfirm` 将通道结束状态标记为打开。

如果所有这些动作都成功发生，则通道在双方都是开放的。在握手的每个步骤中，与该握手步骤关联的模块都会`ChannelEnd`执行其回调。依此类推`ChanOpenInit`，链 A 上的模块执行其回调`OnChanOpenInit`。

 

#### Packets 数据包

模块通过 IBC 通道发送数据包相互通信。所有 IBC 数据包都包含：

- 目标链的 `portID`
- 目标链的 `channelID`
- 来源的`portID`
- 目标链的 `channelID`
- 可选择的强制排序的序列
- `TimeOutTimestamp`  `TimeoutHeight` 当非零时，这些超时值确定接收模块必须处理数据包的最后期限，若超时没有接收到数据包，则发送模块可以使数据包超时，并采取适当的措施。

#### `Receipt`  `timeouts`

由于 IBC 在分布式网络上工作并依赖潜在故障中继器在分类帐之间中继消息，因此 IBC 必须处理数据包没有及时或根本没有发送到其目的地的情况。数据包必须指定超时高度或超时时间戳，在此之后，目标链上将无法再成功接收数据包。

如果达到超时，则可以将数据包证明超时提交给原始链，然后原始链可以执行特定于应用程序的逻辑以使数据包超时，可能通过回滚数据包发送更改（退还发送者任何锁定的资金）。

在 ORDERED 通道中，通道中单个数据包的超时关闭通道。如果数据包序列`n`超时，则在`k > n`不违反 ORDERED 通道的约定的情况下，将无法成功接收序列中的数据包，即数据包按照发送的顺序进行处理。`n`由于 ORDERED 通道强制执行此不变量，因此数据包指定的超时时间尚未在目标链上收到序列的证明`n`足以使数据包超时`n`并关闭通道。

在 UNORDERED 情况下，可以按任何顺序接收数据包。IBC 为它在 UNORDERED 通道中接收到的每个序列写入一个数据包收据。此收据不包含任何信息，只是一个标记，旨在表示 UNORDERED 通道已按指定顺序接收到数据包。要使 UNORDERED 通道上的数据包超时，需要在指定的超时前证明数据包的序列不存在数据包接收。当然，超时 UNORDERED 通道上的数据包会触发该数据包的特定于应用程序的超时逻辑，并且不会关闭通道。





### 跨分区交易流程

#### Tracking

A 链 同步B链的区块头信息，（A、B共同维护对方的一个轻节点）

#### Bonding

当IBC 初始化一笔跨链转账之后，A链上的部分ATOM 属于锁定状态

#### Proof 中继

一份证明A链上资产锁定的证明 被发送到B链的IBC模块

#### 验证

B链结合A链的轻节点信息，对这份“证据”验证通过之后，B链上会“铸造”10份ATOM Voucher（抵用券），这些Voucher可以进行后续的流通使用。当然这些Voucher也可以通过同样的跨链方式返回到A链，A链上的ATOM代币相应执行解锁的操作。





























