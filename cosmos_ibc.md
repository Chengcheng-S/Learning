## cosmos ibc 

### IBC和链桥的区别

cosmos提供了cosmos-sdk 方便开发者直接使用该包构建自己的区块链然后参与到cosmos的生态中去，换句话说使用cosmos提供的框架，区块链底层部分(通信、共识等模块)不需要自己去实现，只需要去做应用层即可。即参与到cosmos中的区块其项目架构本质上都是相同的也就是所谓同构区块链，他们之间可以直接使用IBC协议进行通信，若多条参与cosmos生态的区块链之间相互通信的话，需要建立很多的链接，因此大部分情况下，cosmos生态中的区块链通信通过 zons-->hub--->zone 的形式，即通过hub 中心枢纽进行资产转移等。

链桥则是异构区块链间的通信，比如eth与near之间的彩虹桥。 



IBC 是一种分层协议，由一下两层组成：

- 较低的传输、认证、排序层(IBC/TAO)
- 建立在TAO之上的上层应用层(IBC/APP)

区块链间通信协议 (IBC) 允许区块链相互通信。作为 Cosmos 生态系统的支柱，IBC 处理跨不同主权区块链的传输。这种端到端、面向连接的有状态协议在异构区块链之间提供可靠、有序和经过身份验证的通信。



通道和端口的抽象层详细信息与应用程序开发人员相关。您可以定义自己的自定义数据包和 IBCModule 回调

模块必须满足以下的要求才能和IBC进行交互：

- 绑定一个或多个端口
- 定义数据包数据
- 定义可选的确认结构和方法来编码、解码他们
- 实现IBCModule 接口

> IBC 应用程序编写为独立的**模块**。一个区块链上的模块可以通过`(channelID, portID)`元组唯一标识的通道发送、接收和确认数据包，与其他区块链上的其他模块通信。



### IBC/TAO

用于两个区块链之间可靠、有序和经过身份验证的方式中继数据包的层。

- “可靠”意味着只有源链准确发送的数据包才会被目标链准确接收。
- “有序”意味着目标链以与源链发送数据包相同的顺序接收数据包。
- “已认证”意味着 IBC 在中继数据包时使用channel，并且通道的每一端都专门分配给特定的智能合约。因此，如果目标链通过通道接收到数据包，则证明分配给源链上通道的特定智能合约发送了数据包，并且任何其他智能合约都不能使用该通道发送数据包。

IBC/TAO 被实现为智能合约，在通过 IBC 相互连接的两个区块链上运行，组成组件：

- client
- connection
- channel

#### client

每当一个新的区块头附加到对面的区块链时，中继器都会查询该区块头并将其提交给本地区块链上的 IBC/TAO 模块。然后 IBC/TAO 模块根据对端区块链执行轻客户端协议，检查区块头是否有效，并仅在区块头有效时更新其 *ClientState* 对端区块链。 （维护一个轻节点）

#### ibc client height

```go
type Height struct{
    	
    RevisionNumber uint64
    RevisionHeight uint64
}
```

- `RevisionNumber` 表示高度所代表链的版本（连续单调递增的范围）
- `RevisionHeight` 表示给定版本中的链高

在任何`RevisionHeight` 重置时（如硬分叉tendermint时） `RevisionNumber` 将增加。这允许IBC client 区分链的版本的块高度。可以通过简单地比较它们各自的 RevisionHeights 来比较共享相同修订号的高度。不共享相同修订号的高度将仅使用它们各自的修订号进行比较。



### 组件

#### Client

IBC 客户端是由唯一客户端 ID 标识的轻客户端。IBC 客户端跟踪其他区块链的共识状态以及这些区块链的证明规范，这些区块链需要根据客户端的共识状态正确验证证明。



#### Connection

连接将两个对象封装`ConnectionEnd`在两个独立的区块链上。每个`ConnectionEnd`都与另一个区块链（交易对手区块链）的客户端相关联。连接握手负责验证每条链上的轻客户端对于各自的交易对手来说是正确的。连接一旦建立，负责促进 IBC 状态的所有跨链验证。一个连接可以与任意数量的通道相关联。

####  proofs  paths

在IBC中区块链不会和通过网络之哦姐相互传递消息

- 为了进行通信，区块链将某些状态提交给为特定消息类型和特定交易对手保留的精确定义的路径。
- 中继进程监视这些路径的更新，并通过将存储在路径下的数据连同该数据的证明提交给交易对手链来中继消息。

proof以字节的形式从core ibc 传递到轻客户端



#### Capabilities

IBC旨在在模块不一定相互信任的执行环境中工作。因此IBC必须对port和channel上的模块操作进行身份验证，以便只有具有适当权限的模块才能使用他们。

此模块身份验证是使用动态能力存储完成。在绑定到端口或为模块创建通道后，IBC会返回模块必须声明的动态功能，以便于使用该channel、port。动态能力模块阻止其他模块使用该port、channel。

一个区块链上的模块可以通过由(channelID,portID)元组唯一标识的channel 发送、接收和确认数据包来与其他区块链上的模块进行通信。



#### port

IBC 模块可以绑定到任意数量的端口。每个端口必须由唯一的`portID`.  由于 IBC 被设计为与在同一分类帐上运行的相互不信任的模块一起确保安全，因此绑定端口会返回动态对象功能。

目的是防止恶意模块打开不属于他的端口的channel，因此IBC模块负责声明在BindPort上返回的功能。



#### channel

在两个 IBC 端口之间建立 IBC 通道。端口由单个模块独占。IBC 数据包通过通道发送。

- 通道可以`ORDERED`使得来自发送模块的数据包必须由接收模块按照发送的顺序进行处理。
- 一个通道可以`UNORDERED`使来自发送模块的数据包按照它们到达的顺序被处理，这可能不是数据包被发送的顺序。



通道握手的步骤：

1. A 发送一条`ChanOpenInit`的消息来表示与链B的通道初始化
2. B 发送一条`ChanOpenTry` 的消息尝试打开链A上的通道
3. A 发送`ChanOpenAck`将其通道结束状态标记为打开
4. B 发送`ChanOpenConfirm` 将通道结束状态标记为打开。

如果所有这些动作都成功发生，则通道在双方都是开放的。在握手的每个步骤中，与该握手步骤关联的模块都会`ChannelEnd`执行其回调。依此类推`ChanOpenInit`，链 A 上的模块执行其回调`OnChanOpenInit`。

正如端口的动态功能一样，channel初始化返回模块必须声明动态功能，以便他们可以传递对channel操作（如发送数据包）进行身份验证的功能。

若channel已经存在，`ChanCloseInit` 关闭执行链上的通道，其还没有关闭且它存在的连接是`OPEN`。通道只能由调用模块或在`ORDERED` 通道上的数据包超时的情况下关闭。

`ChanCloseConfirm` 是对执行`ChanCloseInit` 交易的响应，若channel存在并尚未关闭，且链接状态为`open`，执行链成功验证交易对方的channel已经关闭，则执行链上的通过将关闭。







#### Packets 数据包

模块通过 IBC 通道发送数据包相互通信。所有 IBC 数据包都包含：

- 目标链的 `portID`
- 目标链的 `channelID`
- 来源的`portID`
- 目标链的 `channelID`
- 可选择的强制排序的序列
- `TimeOutTimestamp`  `TimeoutHeight` 当非零时，这些超时值确定接收模块必须处理数据包的最后期限，若超时没有接收到数据包，则发送模块可以使数据包超时，并采取适当的措施。

模块在IBC packet的data 字段中相互发送自定义应用的数据。分组数据对IBC处理程序是不透明的，发送方模块将应用程序的数据信息编码到相应的字段中，接收器模块将数据解码到对应的字段。



#### `Receipt`  `timeouts`

由于 IBC 在分布式网络上工作，因此 IBC 必须处理数据包没有及时或根本没有发送到其目的地的情况。数据包必须指定超时高度或超时时间戳，在此之后，目标链上将无法再成功接收数据包。

- `timeoutHeight` 表示目标链上的共识高度，在该高度之后不在处理packet，作为超时处理
- `timeoutTimestap` 指目标链上的时间戳，在此之后不在处理packet。



如果达到超时，则可以将数据包证明超时提交给原始链，然后原始链可以执行特定于应用程序的逻辑以使数据包超时，可能通过回滚数据包发送更改（退还发送者任何锁定的资金）。

在 ORDERED 通道中，通道中单个数据包的超时关闭通道。如果数据包序列`n`超时，则在`k > n`不违反 ORDERED 通道的约定的情况下，将无法成功接收序列中的数据包，即数据包按照发送的顺序进行处理。`n`由于 ORDERED 通道强制执行此不变量，因此数据包指定的超时时间尚未在目标链上收到序列的证明`n`足以使数据包超时`n`并关闭通道。

在 UNORDERED 情况下，可以按任何顺序接收数据包。IBC 为它在 UNORDERED 通道中接收到的每个序列写入一个数据包收据。此收据不包含任何信息，只是一个标记，旨在表示 UNORDERED 通道已按指定顺序接收到数据包。要使 UNORDERED 通道上的数据包超时，需要在指定的超时前证明数据包的序列不存在数据包接收。当然，超时 UNORDERED 通道上的数据包会触发该数据包的特定于应用程序的超时逻辑，并且不会关闭通道。



### 跨分区交易流程

#### Tracking

A 链 同步B链的区块头信息，（A、B共同维护对方的一个轻节点）

#### Bonding

当IBC 初始化一笔跨链转账之后，A链上的部分ATOM 属于锁定状态

#### Proof 中继

一份证明A链上资产锁定的证明 被发送到B链的IBC模块

#### 验证

B链结合A链的轻节点信息，对这份“证据”验证通过之后，B链上会“铸造”10份ATOM Voucher，这些Voucher可以进行后续的流通使用。当然这些Voucher也可以通过同样的跨链方式返回到A链，A链上的ATOM代币相应执行解锁的操作。



```
channel state



A\B uninitialized -----chaninit---> A init B uninitialized ---chanopentry---> A init B tryopen ---chanopenAck-> A open B tryopen ----chanopennconfirm--> A\B open --chancloseinit-> A close  B open ---chancloseconfirm ---> A\B close
```





























