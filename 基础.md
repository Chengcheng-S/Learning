## 介绍

静态类型，命令式编程语言，*Nim有一个强大的，基于AST的宏机制；Nim在本地线程上有一个强大的实时垃圾收集机制；线程之间可以通过异步消息机制通讯；为了提供执行效率，Nim还提供了一个不安全的共享内存区。*

编译：

```
nim c name.nim

nim c -r name.nim

nim objc name.nim

nim js name.nim
```

编译发布版本：

```
nim c -d:release name.nim
```

注：参数-d:release 关闭一些检查并且打开优化



> *Nim代码会编译成C语言的代码，再编译成本地机器码，不依赖于虚拟机，* *而且生成的可执行文件比较小，不依赖于其他库，分发起来比较方便*
>
> *拥有一个“非追踪式”的垃圾收集器，这就非常适用于类似游戏这样的“弱实时”系统*
>
> *让程序员拥有直接操纵内存和访问硬件的权力（手动管理的内存有别于垃圾收集器可收集的内存）*
>
> *零开销的迭代器*
>
> *Cross-module inlining（这是跨模块代码嵌入吗？不知道怎么翻）*
>
> *实现了动态方法绑定，但并没有用到虚拟方法表*
>
> *（virtual method table，这是在黑.NET吧）*
>
> *编译期评估用户自定义的方法*
>
> *无用代码自动消除*
>
> *直接在栈上为实例、对象、数组分配空间*

### 类型推断

```nim
var name:string=readLine(stdin)///  从命令行读取数据
```

```nim
var name=readLine(stdin)
```

### 转义字符

与C语言类似，反斜杠（\）是它的转移符号，比方说\n代表换行符，\t代表tab制表符，

如果你不想在你的字符串中大量使用转移字符，

```nim
var path = r"C:\program files\nim"
```

### 文本

```
var str = """这是我的大段文本
我换了一行
我又换了一行
就算有反斜杠，\，也不会被当作转义符"""
```

Nim允许开发人员用成对儿的三个分号包住大段文本，文本里的反斜杠也不会被当作转义符

### 变量声明

```nim
var x:int 
var 
	x :int
	y:string
	
var x,y=3	
```

### 常量

```nim
const 
  x=4
  y=3
  z="aa"
```

注意：

1. const 定义的变量不能被修改
2. 因为编译器会把所有const变量换成他所对应的值，所以变量对应的值是表达式的话，在编译器一定要能对表达式求值才行

### `let`

```rust
const input = readLine(stdin) # Error: 运行期的值不能赋给const变量
let input = readLine(stdin)   # works：运行期的值可以赋给let定义的变量
```

let定义的变量，赋值后不能被修改，可以在运行期赋值

### `if/elif   else`

```nim
let name = readLine(stdin)
if name == "":
  echo("Poor soul, you lost your name?")
elif name == "name":
  echo("Very funny, your name is name.")
else:
  echo("Hi, ", name, "!")
```



### `case of     else`

```
let name = readLine(stdin)
case name
of "":
    echo ("what is your name?")
of "name":
    echo ("are you sure this is ",name " is your name?")

else:
    echo ("nice !",name,"is your name")
```

### `while`

```nim
echo("What's your name? ")
var name = readLine(stdin)
while name == "":
  echo("Please tell me your name: ")
  name = readLine(stdin)
```

一定要注意最后一行的缩进，如果没有这个缩进，会报错

### `for`

```nim
echo("Counting to ten: ")
for i in countup(1, 10):
  echo(i)
  
  
for i in 1..10:
	echo i
```

### `block`和作用域

用for还是用while，都会导致开辟一个新的作用域(内建的作用域)使用block关键字显示创建一个额作用域

```nim
block myblock: 
  var x = "hi" 
echo(x) #这里没有缩进，已经跳出myblock作用域，所以这是错误的
```

### `break`

break可以迫使程序执行跳出当前作用域,像while、for和block关键字声明的作用域，它都能跳出.

```nim
block myblock2:
  echo("entering block")
  while true:
    echo("looping")
    break myblock2 # 跳出while循环，而且也跳出myblock2作用域
```

### `continue`

```nim
while true:
  let x = readLine(stdin)
  if x == "": continue
  echo(x)
```

### `when`

```nim
when system.hostOS == "windows":
  echo("running on Windows!")
elif system.hostOS == "linux":
  echo("running on Linux!")
elif system.hostOS == "macosx":
  echo("running on Mac OS X!")
else:
  echo("unknown operating system")
```

注：when每个分支都必须在编译器取值， 每个分支并不开辟新的作用域

当第一个分支的条件为true的时候，编译器会对第一个分支的代码做词法分析，编译器不对其他分支进行分析

### 缩进

单条指令，无需缩进

```nim
if x:x=false
```

嵌套的判断需要缩进

```nim
if x:
  if y:
    y = false
  else:
    y = true
```

多条指令也需要缩进

```nim
if x:
  x = false
  y = false
```

如果判断条件是一个挺长的表达式，那么也可以用换行缩进来保证可读性和正确性

（注意，一定要在操作符、括号开始、逗号结束之后再换行缩进）

```nim
if thisIsaLongCondition() and
    thisIsAnotherLongCondition(1,
       2, 3, 4):
  x = true
```

有些地方只允许你使用一个表达式，或者为了保证可读性，最好用一个表达式的时候。可以用括号和分号来解决问题，比如下面的代码

```nim
const fac4 = (var x = 1; for i in 1..4: x *= i; x)
```

> *宏可以使用命令式编程方式来构造分析树（parse trees），使用Nim并不需要换一种编程风格来来完成元数据编程*
>
> *宏不能改变Nim的语法（不能用宏来做语法糖），因为完全就木有这个必要，因为Nim的语法已经足够灵活了*
>
> *通过缩进来分隔代码块，缩进不能使用tab制表符，这样编译器能更好的处理代码*

## 方法

Nim给方法叫做Procedures

声明关键字为`proc`

```nim
proc yes(question: string): bool =
  echo(question, " (y/n)")
  while true:
    case readLine(stdin)
    of "y", "Y", "yes", "Yes": return true
    of "n", "N", "no", "No": return false
    else: echo("Please be clear: yes or no")

if yes("Should I delete all your important files?"):
  echo("I'm sorry Dave, I'm afraid I can't do that.")
else:
  echo("I think you know what the problem is just as well as I do.")
```

方法名为`yes`,参数类型为`string` 返回值为`bool`,使用关键字return 返回

### 方法中的result

只要一个方法被定义成有返回值的方法， 那么Nim会给你默认创建一个result变量，

你可以在方法中不用声明就使用这个result变量，不管你方法中有没有retun指令，到方法执行结束，都会返回这个result变量

```
proc sumTillNegative(x: varargs[int]): int =
  for i in x:
    if i < 0:
      return
    result = result + i
```

### 参数

为了执行效率，在方法体内部不能改变参数的指，在方法体内部使用与参数同名的变量，使用var重新定义一个同名参数，隐藏掉本身的方法参数，这样就可以像普通的变量一样使用它了

```
proc f1(a:int=1):int=
    var a =7
    result=result+a
```

`a:int=1` 设置a参数的默认值为1

### 丢弃返回值

Nim中必须显示的丢弃返回值

```nim
discard yes("May I ask a pointless question?")
```

使用`discard`显示丢弃返回值

或者在声明时进行标注

```
proc p(y,x:int):int{.discardable.}=
	return x+y
p(1,2)   // no valuie	
```

### 具名实参

有的时候一个方法包含很多参数，使用这个方法的人只记得参数的名字，但不记得参数的顺序了，那么你可以使用具名参数来解决这个问题，就像下面这样：

```nim
proc createWindow(x, y, width, height: int; title: string;
                  show: bool): Window =
```

### 参数默认值

Nim所有的内置类型都有个默认值，string的默认值为unkown

```
proc createWindow(x = 0, y = 0, width = 500, height = 700,
                  title = "unknown",
                  show = true): Window =
```

### 重载

```nim
proc toString(x: int): string = ...
proc toString(x: bool): string =
  if x: result = "true"
  else: result = "false"
 
echo(toString(13))   # 调用 toString(x: int) 方法
echo(toString(true)) # 调用 the toString(x: bool) 方法
```

### 操作符

在Nim的类库中大量的使用了方法的重载，主要的原因就是操作符的原理其实就是方法重载；

Nim的语法允许使用中缀表示法（a+ b）、前缀表示法（+a）；中缀表示法就是一个接收两个参数的方法重载；前缀表示法就是一个接收一个参数的方法重载；

不允许使用后缀表示法，

除了一些内置的关键词操作符（and or not）之外，

操作符一般都是这些字符：`+ - * \ / < > = @ $ ~ & % ! ? ^ . |`

```
proc `$` (x: myDataType): string = ...
# 现在可以使用$来操作myDataType类型的数据：$ myDataTypeValue
```

### 前置声明

所有的变量和方法都必须在使用前声明，递归除外

## 迭代器

```nim
iterator countup(a, b: int): int =
  var res = a
  while res <= b:
    yield res
    inc(res)
```

- 用iterator声明迭代器，
- 迭代器内部可以使用`yield`关键字(迭代，返回某一个变量的值)
- 迭代器只能用于for循环之中
- 迭代器不能包含return关键字
- 方法中不能包含yield关键字
- 迭代器中没有一个隐藏的result变量
- 迭代器不支持递归
- 迭代器不支持前置声明

## bool类型

bool类型有两个值：true和false

用在while， when等流程控制语句中，用于判断是否满足条件

## 字符类型

关键字`char`,占据一个字节，不能表示一个utf-8字符，但可以表示一部分

==,<,>,<=,>=这些操作符，可以用来操字符类型

`$`可以把一个字符类型格式化为字符串类型

`ord()`可以得到一个字符类型的序数值，   `chr()`可以把一个数字类型的值格式化为字符类型

## 字符串类型

字符串类型可变， Nim中的字符串类型是以\0结尾的，但Nim中的字符串类型还包含一个长度的属性，这个属性不会计算字符串结尾的\0字符，使用`len`获取一个字符串的长度。

原始字符串字面值：

```nim
r"nim string"
```

  赋值运算符会导致一个字符串被复制

​    使用`&`运算符来链接两个字符串

使用add 将一个字符串添加到另一个字符串的结尾

字符串的比较是按字符串内的字符顺序做比较的， 所有的比较操作符都可以用在字符串身上

string类型的变量默认值是nil，很多针对string类型的操作，都不能用在nil身上

## 注释：

注释在任何字符串或字符字面值之外，以哈希字符 `#` 开始，文档以 `##` 开始：

```
 复制代码# 注释。 var myVariable: int ## 文档注释
```

多行注释以 `#[` 开始，以 `]#` 结束。多行注释也可以嵌套。

和长字符串字面值一起使用discard语句构建块注释

```
discard """You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes("May I ask a pointless question?") """
```



## 基本数据类型

数字类型，允许使用下划线： `1_000_000` (一百万)。 包含点（或者'e'或'E'）的数字是浮点字面值： `1.0e9` （十亿）。十六进制字面值前缀是 `0x` ，二进制字面值用 `0b` ，八进制用 `0o` 。 单独一个前导零不产生八进制。

### 整型

Nim有十种整型类型

```
int,int8,int16,int32;int64;uint8,uint16,uint32,nint64
```

默认整型的类型为`int`

```
let 
	x=0      // x的类型是int
	y=0'i8    // y的类型是int8
```

由于整型类型经常被用于计算内存里的对象，整型的大小和指针的大小一样

```
+ - * / div mod < <= == != > >=
```

还有一些按位计算的操作符：

and   or   xor   not  

也可以用在整型身上

shl操作符可以完成左移位操作

shr操作符可以完成右移位操作

移位操作一般都会把目标当作无符号的整形来对待

因为移位操作往往会导致乘法或除法操作

针对无符号的操作数，操作符做做过二次封装，不会产生内存泄漏或溢出的问题

在表达式中使用不同类型的整型时，会导致类型转化

宽度比较小的类型会被转化成宽度比较大的类型

整形不会自动转化成浮点类型

同样，浮点类型也不会自动转化成整形

`toInt`方法和`toFloat`方法可以用来处理这两种类型转化操作

### 浮点类型

三种浮点类型

```
 float  float32  float64
```

默认为`float`,在现在的Nim实现中，float类型总是64位的

```
var 
	x=0.0
	y=0.0'f32
	z=0.0'64
```

```
+   -   *    /    <    <=     ==    !=   >     >=
```

不同宽度的浮点类型出现在一个表达式的是偶，宽度较小的浮点类型将被格式化为宽度较大的浮点类型

整型不会自动转为浮点各类型，浮点类型也不会自动转为整型

### 类型转换

基本数据类型的关键字本身就是一个方法，可以完成这些格式化转换的工作

```
var
  x: int32 = 1.int32   # same as calling int32(1)
  y: int8  = int8('a') # 'a' == 97'i8
  z: float = 2.5       # int(2.5) rounds down to 2
  sum: int = int(x) + int(y) + int(z) # sum == 100
```

### `$`操作符和`repr`方法

Nim中的内置类型都可以用`$`操作符数据格式化成字符串，对于某些高级类型，或者自定义的类型。`$`就无能为力了(除非为这些类型重定义了$操作符)

在调试的时候看看一个复杂类型的值，可以使用repr方法，repr方法可以应用于任何类型，甚至自关联类型也没有问题

```nim
var
  myBool = true
  myCharacter = 'n'
  myString = "nim"
  myInteger = 42
  myFloat = 3.14
echo($myBool, ":", repr(myBool))
# --> true:true
echo($myCharacter, ":", repr(myCharacter))
# --> n:'n'
echo($myString, ":", repr(myString))
# --> nim:0x10fa8c050"nim"
echo($myInteger, ":", repr(myInteger))
# --> 42:42
echo($myFloat, ":", repr(myFloat))
# --> 3.1400000000000001e+00:3.1400000000000001e+00
```

注：在repr(mystring)的时候，其内存地址也会被输出

### `type`关键字

使用type关键字来定义一个类型

```
type 
	biggestInt=int64
	biggestFloat=folat64
```

对象和枚举类型也是通过type关键字定义的

### 枚举类型

枚举类型定义了一个有序的值序列，值序列中每个值都是整型，第一个值为0，第二个值为1，依次类推。一个枚举类型的变脸只能被赋值为这个序列值中的一个。

```nim
type
	Direction=enum
	 north,east,south,west   //  注意此处的缩进
	
var x=south
echo &x
```

定义的变量x类型为Direction。

注： 最后一行输出的内容为south，而不是2， 如果使用`ord`方法的话，可以得到枚举变量的值，所有比较相关的操作符可以用到枚举变量身上。

可以用`.`来避免起义

```
var x =Diection.south
```

为了更好的兼容其他语言，枚举类型内定义的符号可以指定为特定的值,指定特定值的时候，一定要按大小顺序指定,没有明确给定一个符号的值，那么这个符号的值就是他上一个符号的值再加1

```
type
	myenum=enum
	   a=2,b=3,c=99,d
	   
var l=myenum.d
echo ord(l)    // 100
```



## 有序類型

值連續的枚舉類型，整形，字符串類型，bool(以及這些類型的變種)都可以稱爲有序類型，爲此Nim提供了一系列的特殊方法

| 方法簽名  |     方法説明      |
| :-------: | :---------------: |
|  ord(X)   | 返回x參數的整形值 |
|  inc(x)   |     為x參數+1     |
| inc(x,n)  |        x+n        |
|  dec(x)   |        x-1        |
| dec(x,n)  |        x-n        |
|  succ(x)  |  返回x的下一個值  |
| succ(x,n) |  返回x的下n個值   |
|  pred(x)  |   返回x前一個值   |
| pred(x,n) |  返回x的前n個值   |

### Subrange

某一範圍内的整形

```
type
	Sunrange=range[0..5]
```

Subrnage這個類型的值，只能是0到5之間的int

### Set集合類型

Set只容納有序類型，  Set類型可以被一個`{}`實例化，

```
var  x={}        // 空的set

type
  CharSet = set[char]
var
  x: CharSet
x = {'a'..'z', '0'..'9'}
```

適用於set的操作符

| 操作符        | 含义                                           |
| ------------- | ---------------------------------------------- |
| A + B         | union操作，链接两个Set变量                     |
| A * B         | 得到两个集合的交集                             |
| A - B         | 得到两个集合的差异（A中哪些元素是B所不包含的） |
| A == B        | 判断两个集合是否相等                           |
| A <= B        | A是否与B相等或者A是否是B的子集                 |
| A < B         | A是否是B的子集                                 |
| e in A        | A包含元素e                                     |
| e notin A     | A不包含元素e                                   |
| contains(A,e) | A包含元素e                                     |
| Card(A)       | A中包含多少个元素                              |
| incl(A,e)     | 与A = A +  {e}相同                             |
| excl(A,e)     | 与A = A - {e}相同                              |

### Array

數組：固定長度，元素類型相同，可以使用`[]`構造

```
type
  IntArray = array[0..5, int] # an array that is indexed with 0..5
var
  x: IntArray
x = [1, 2, 3, 4, 5, 6]
for i in low(x)..high(x):
  echo(x[i])
```

依次輸出x中的元素， 數組是值類型，賦值操作將複製整個數組内容， `len`返回數組中元素個數， `low`返回數組的最小下標，`high`返回數組的最大下標

```nim
type
  Direction = enum
    north, east, south, west
  BlinkLights = enum
    off, on, slowBlink, mediumBlink, fastBlink
  LevelSetting = array[north..west, BlinkLights]
var
  level: LevelSetting
level[north] = on
level[south] = slowBlink
level[east] = fastBlink
echo repr(level)  # --> [on, fastBlink, slowBlink, off]
echo low(level)   # --> north
echo len(level)   # --> 4
echo high(level)  # --> west
```

可以用多個`[]`實現多維數組，在多維數組中，不同緯度可以擁有不同索引類型

多維數組定義

```
type
  LightTower = array[1..10, array[north..west, BlinkLights]]
```



```
type
  IntArray = array[0..5, int] # an array that is indexed with 0..5
  QuickArray = array[6, int]  # an array that is indexed with 0..5
var
  x: IntArray
  y: QuickArray
x = [1, 2, 3, 4, 5, 6]
y = x
for i in low(x)..high(x):
  echo(x[i], y[i])
```

定義數組時，不必每次都指定數組的最小下標

### seq序列類型

seq類似於數組，但seq可以在運行時改變容器的長度，因为seq是长度可变的，所以nim在内存堆上为它分配空间和进行垃圾收集

seq類型的索引總是從`0`開始，len，low，high 也適用於seq類型，可以通過`x[i]`訪問其中的元素。

seq類型可以通過`@`和`[]`  構造，也可以使用内置的`newseq`構造

```
var
  x: seq[int] # a sequence of integers
x = @[1, 2, 3, 4, 5, 6] # the @ turns the array into a sequence  
// 此處的  @和=之間務必有一個&nsp
```

默認值為`nil`（為賦值）

seq类型的变量设置空值：@[]，會在堆上創建一個空的序列，性能上相對損耗

```
for k,v in @[3,4,5]:
	echo $k $v
	//  k ===>index,   v ====> value
	
for v in @[3,5,4]:
	echo $v
    //  v=> value
```

### openarry類型

該類型只適用於參數

openarray类型的变量索引总是从0开始

len、low、high等操作同样试用于openarray类型， 任何一个数组都可以被传递到一个openarray参数中，索引的類型并不重要， **不能給openarry類型的參數傳遞多維數組**

### 可變參數

可變參數就是openarry，給方法傳遞多個同一類型的數據，編譯器自動將這些參數轉爲一個openarry   `varargs` ====> 動態數組

```
proc myWriteln(f: File, a: varargs[string]) =
  for s in items(a):
    write(f, s)
  write(f, "\n")
 
myWriteln(stdout, "abc", "def", "xyz")
# is transformed by the compiler to:
myWriteln(stdout, ["abc", "def", "xyz"])
```

注:這種類型的參數必須是方法簽名的最後一個參數

```nim
proc myWriteln(f: File, a: varargs[string, `$`]) =
  for s in items(a):
    write(f, s)
  write(f, "\n")
 
myWriteln(stdout, 123, "abc", 4.0)
# is transformed by the compiler to:
myWriteln(stdout, [$123, $"def", $4.0])
```

本例中`$`應用於任何參數，($應用於字符串時，是一個nop操作)

### slice

实际的业务控制代码中slice类型并不是很常用，在很多集合类型的操作中，slice起到定义操作数的作用

```
var 
	a="nim is a progromming language"
	b="slice are useless"
echo a[7..12]
b[0..13]="successful"
echo b
```

```
Nim is a prog
successfless
```



### Tuple元組類型

使用`[]`定義元組，  使用`()`構造元組，構造器中屬性的屬性必須和元組定義的屬性一直

如果两个元组在定义的时候，使用了相同的属性而且属性的顺序也是一致的，那麽這兩個元素是相同的，

```
type
  Person = tuple[name: string, age: int] # type representing a person:
                                         # a person consists of a name
                                         # and an age
var
  person: Person
person = (name: "Peter", age: 30)
# the same, but less readable:
person = ("Peter", 30)
 
echo(person.name) # "Peter"
echo(person.age)  # 30
 
echo(person[0]) # "Peter"
echo(person[1]) # 30
 
# You don't need to declare tuples in a separate type section.
var building: tuple[street: string, number: int]
building = ("Rue del Percebe", 13)
echo(building.street)
 
# The following line does not compile, they are different tuples!
#person = building
# --> Error: type mismatch: got (tuple[street: string, number: int])
#     but expected 'Person'
 
# The following works because the field names and types are the same.
var teacher: tuple[name: string, age: int] = ("Mark", 42)
person = teacher
```

在使用tuple类型的时候，不一定要新创建一个类型出，building变量就直接使用了tuple类型，而不像person一样先创建了一个Person类型，只有在元组属性赋值期间元组才可以被拆箱

```
import os
 
let
  path = "usr/local/nimc.html"
  (dir, name, ext) = splitFile(path)
  baddir, badname, badext = splitFile(path)
echo dir      # outputs `usr/local`
echo name     # outputs `nimc`
echo ext      # outputs `.html`
# All the following output the same line:
# `(dir: usr/local, name: nimc, ext: .html)`
echo baddir
echo badname
echo badext
```

os模块的内置splitFile方法，可以返回三个值，一个是路径，一个是文件名，一个是文件扩展名

只有使用var或者let操作符时，才可以应用元组解包的特性

```
import os
 
var
  path = "usr/local/nimc.html"
  dir, name, ext = ""
 
(dir, name, ext) = splitFile(path)
# --> Error: '(dir, name, ext)' cannot be assigned to
```

### 引用類型和指針類型

nim中存在兩種引用方式，一種是追蹤引用，另一種是非追蹤引用，

非追蹤引用也是指針，指向手動在内存中分配的對象。

追蹤引用指向一個垃圾收集的對象，  非追蹤引用是不安全的，對於一些低級操作，非追蹤引用是不可避免的。

追蹤引用使用`ref`聲明， 非追蹤引用使用`ptr`,使用`[]`解包一個引用(訪問一個元組或對象域時要用到)

```nim
type
  Node = ref NodeObj
  NodeObj = object
    le, ri: Node
    data: int
var
  n: Node
new(n)
n.data = 9
```

使用new() 來創建一個新的追蹤對象， 使用`alloc`或`dealloc`或`realloc`函數處理非追蹤對象

如果一個引用沒有指向任何東西，那麽他的值為nil

### proc方法指針類型

方法類型是一個方法的指針，默認值為nil

```nim
proc echoItem()=echo(x)

prco forEach(action:proc(x:int))=
	const
		data=[2,3,4,5]
	for d in items(data):
    	action(d)
    	
forEah(echoItem)    	
```

```
2
3
4
5
```

## 模塊

nim允許把一個程序分爲若干塊，一個模塊就是一個文件，模塊可以起到隱藏信息的作用、分開編譯，可以使用import另一個模塊，在一個模塊中，只有星號標記的，才能到處給另一個模塊

```
var x*,y :int    // 導出變量x

proc `*` *(a,b:seq[int]):seq[int]=
	newSeq(result,len(a))
	for i in 0..len(a)-1:
		result[i]=a[i]*b[i]
when isMainModule:
	assert!(@[1,2,3]*@[1,2,3]==@[1,4,9])
```

導出了方法“*”，在程序開始執行的時候就會執行模塊的頂層語句，可以用來初始化一些複雜的數據結構， 模塊的内部可以通過使用isMaininModule内置變量來判斷當前模塊是否為主模塊

```python
# Module A
type
  T1* = int  # Module A exports the type ``T1``
import B     # the compiler starts parsing B

proc main()=
	var i =p(3)
main() //module B

import A
#A is not parsed here! Only the already known symbols
# of A are imported

proc p*(x:A.T1):A.T1=
    result =x+1

```

模塊的符號書寫要符合`moduld.symbol`的語法，如果一個符號在連個模塊中都定義過了，而且第三個模塊引用了這兩個模塊

```python
# Module A
var x*: string

# Module B
var x*: int# Module C

import A, B
write(stdout, x) # error: x is ambiguous
write(stdout, A.x) # no error: qualifier used
 
var x = 4
write(stdout, x) # not ambiguous: uses the module C's x
```

這個規則不適用於方法或者迭代器，對於方法或迭代器來講 ，適用於重載的規則

```python
#module A
proc x*(a:int):string=$a  // module b
proc x*(a:string):string=$a   //module c

import a,b
wirte(stdout,x(3))  //A.x is called
write(stdout,x(""))  //B.x is called

proc x*(a:int):string=nil
write(stdout,x(3))    // mod A    
```

### 排除指定符號

```python
import moduleA except y,Z
```

使用``except`排除了moduleA中的y和z符號

### 導入指定的符號

```python
from moduleA import y,z
```

### 强行名稱空間限定

```python
from mymodule as m import nil


m.A()
```

模塊別名

### `include`

include語句和from語句的本質區別，include在編譯器把幾個文件合并成一個文件，有利於把一個大文件分割成爲幾個文件

```python
include fileA，fileB,fileC
```

























