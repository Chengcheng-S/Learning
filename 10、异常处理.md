# 异常

在Nim中异常时对象，异常类型带有`Error`后缀，系统模型定义了一种异常层次结构，异常源自**system.Exception**,它提供公共接口。

异常必须分配在**堆上**，因为他们的生命周期时未知的，编译器阻止在栈创建异常。所有引发的异常至少在msg域说明原因。

一个约定时异常要在特殊的情况下才能触发，如：打开文件失败，

## rasie语句

使用raise引发异常

```
var e:ref OSError
new(e)
e.msg="the request to the OS failed"
raise e
```

**如果关键字raise后没有跟着一个异常，那么最后一个异常将会被重新引起，**为了达到避免重复公共代码模式的目的，可以使用系统模块中的模板newException:

```
raise newException(OSError,"the request to the OS failed")
```

## try 语句

使用try 处理异常

```
import strutils

var
  f: File
if open(f, "test.txt"):
  try:
    let a = readLine(f)
    let b = readLine(f)
    echo "sum: ", parseInt(a) + parseInt(b)
  except OverflowError:
    echo "overflow!"
  except ValueError:
    echo "could not convert string to integer"
  except IOError:
    echo "IO error!"
  except:
    echo "Unknown exception!"
    # reraise the unknown exception:
    raise
  finally:
    close(f)
```

**除非引发一个异常，try之后的语句才会执行，然后会执行相应的except部分**，如果有一个**异常没有明确的列出**，将会**执行空的except部分**，类似于if语句中的else部分。 如果存在f**inally部分，在处理完成异常之后总是要执行它**。

**异常**只**在except部分处理**，如果一个异常没有处理，它是通过调用堆栈传播，意味着通常剩下的程序，不在一个finally的部分，是不会执行的(如果异常发生)

**访问实际的异常对象或者except分支中的消息，可以使用系统模型中的getCurrentException()和getCurrentExceptionMsg()的方法。**

```
try:

  var number = open("G:name.txt")

except:
  let
    e = getCurrentException()
    msg = getCurrentExceptionMsg()
  echo "Got exception ", repr(e), " with message ", msg
```

## 注释过程引起异常

通常使用可选项**{.raise.}编译指示**可以指定一个过程是为了**引起一组特定的异常**。 如果{ .raises.}编译指示使用,编译器将验证这是真的。

```
proc complexProc() {.raises: [IOError, ArithmeticError].} =  ...
proc simpleProc() {.raises: [].} =  ...
```

添加{.raise.}编译注释， 可以添加{.effects.}编译注释语句。

```
discard """
proc main():void =
  defer: close(f)
  except:
    echo "Exception"
  var f = open("numbers.txt")
                               #Top level defer statements are not supported since it's unclear what such a statement should refer to
  f.write "abc"                               #也就是defer 不能用在程序的顶层。
  f.write "def"

main()
"""

var f = open("numbers.txt")
try:
  f.write "abc"
  f.write "def"
finally:
  close(f)

#defer语句没有捕获异常的功能，要想捕获异常，except 语句要添加到在defer 语句后面，可能发生异常语句的前面。
```

 

## 异常基类

```
Exception = object of RootObj
  parent*: ref Exception      ## parent exception (can be used as a stack)
  name: cstring               ## The exception's name is its Nim identifier.
                              ## This field is filled automatically in the
                              ## ``raise`` statement.
  msg* {.exportc: "message".}: string ## the exception's message. Not
                              ## providing an exception message
                              ## is bad style.
  trace: string
```



```
SystemError = object of Exception

#Abstract class for exceptions that the runtime system raises.

#抽象类的异常运行时系统提出。


IOError = object of SystemError

#Raised if an IO error occurred.

#如果一个IO错误发生，将会引起IOError异常。


OSError = object of SystemError  errorCode*: int32 ## OS-defined error code describing this error.#Raised if an operating system service failed.

#如果一个操作系统服务失败，会引发OSError 异常


LibraryError = object of OSError

#Raised if a dynamic library could not be loaded.

#如果无法加载动态库，会引发 LibraryError  异常。


ResourceExhaustedError = object of SystemError

#Raised if a resource request could not be fulfilled.

#如果一个资源请求不能被满足，将会引发 ResourceExhaustedError  异常。


ArithmeticError = object of Exception
#Raised if any kind of arithmetic error occurred.
#如果发生任何算术错误，将会引发 ArithmeticError  异常。

DivByZeroError = object of ArithmeticError
#Raised for runtime integer divide-by-zero errors.
#运行时出现 整型除以0，将会引发 DivByZeroError 异常。

OverflowError = object of ArithmeticError
#Raised for runtime integer overflows.
#This happens for calculations whose results are too large to fit in the provided bits.
#运行时整型溢出，将会引起 OverflowError 异常。
#这种情况发生是因为运算结果太大，超出了提供的位数。

AccessViolationError = object of Exception
#Raised for invalid memory access errors
#无效的内存访问错误，将会引发 AccessViolationError 异常。

AssertionError = object of Exception
#Raised when assertion is proved wrong.
#Usually the result of using the assert() template.
#当断言证明是错误的，将会引起AssertionError  异常。
#通常是使用assert()模板的结果



ValueError = object of Exception
#Raised for string and object conversion errors.   Source
#字符串和对象转换错误，将会引起ValueError 异常。

KeyError = object of ValueError
#Raised if a key cannot be found in a table.
#Mostly used by the tables module, it can also be raised by other collection


modules like sets or strtabs.
#如果在表中不能找到一个键，将会引起KeyError异常。
#主要在用table 模块时使用，它也能被其他的收集模块引起，像 sets 或 strtabs。


OutOfMemError = object of SystemError
#Raised for unsuccessful attempts to allocate memory.
#分配内存失败，将会引起OutOfMemError 异常。

IndexError = object of Exception
#Raised if an array index is out of bounds.
#如果一个数组索引超出了界限，将引起IndexError 异常。


FieldError = object of Exception
#Raised if a record field is not accessible because its discriminant's value does not fit.
#如果一个记录字段因为它的判别式的值不符合而不能访问，将会引起FieldError 异常。


RangeError = object of Exception
#Raised if a range check error occurred.
#如果一个范围检查错误发生，将会引起RangeError 异常。


StackOverflowError = object of SystemError
#Raised if the hardware stack used for subroutine calls overflowed.
#如果子例程调用使用的硬件堆栈溢出，将会引起StackOverflowError 异常。


ReraiseError = object of Exception
#Raised if there is no exception to reraise.
#如果没有异常引起，将会引起ReraiseError 异常。


ObjectAssignmentError = object of Exception
#Raised if an object gets assigned to its parent's object.
#如果一个对象被分配给它的父对象，将会引起ObjectAssignmentError 异常。（子类=父类）


ObjectConversionError = object of Exception
#Raised if an object is converted to an incompatible object type.
#如果一个对象被转换为一个不兼容的对象类型，将会引起ObjectConversionError 异常。


FloatingPointError = object of Exception
#Base class for floating point exceptions.
#浮点异常基类。


FloatInvalidOpError = object of FloatingPointError
#Raised by invalid operations according to IEEE.  Raised by 0.0/0.0, for example.
#无效的操作根据IEEE，会引起FloatInvalidOpError 异常。例如：0.0/0.0


FloatDivByZeroError = object of FloatingPointError
#Raised by division by zero.    Divisor is zero and dividend is a finite nonzero number.
#除以零会引起异常。   除数为零和被除数是有限非零的数字。


FloatOverflowError = object of FloatingPointError
#Raised for overflows.
#The operation produced a result that exceeds the range of the exponent.
#由于溢出引发异常。操作产生的结果超过指数的范围。


FloatUnderflowError = object of FloatingPointError
#Raised for underflows.
#The operation produced a result that is too small to be represented as a normal number.
#由向下溢出引发的异常。这个操作产生一个结果，太小而不能用一个正常的数表示。


FloatInexactError = object of FloatingPointError
#Raised for inexact results.
#The operation produced a result that cannot be represented with infinite precision -- for #example: 2.0 / 3.0, log(1.1)
#NOTE: Nim currently does not detect these!
#不精确的结果，引起 FloatInexactError 异常。
#操作产生的结果,不能用无限精确表示，例如： 2.0/3.0,    log(1.1)
#注意：Nim目前不能检测这些。


DeadThreadError = object of Exception
#Raised if it is attempted to send a message to a dead thread.
#如果企图向死线程发送一条消息，将会引发DeadThreadError 异常。

```

## 有关异常操作的过程：

```
proc getCurrentException*(): ref Exception {.compilerRtl, inl, benign.} =
  result = currException
   #检索当前的异常；如果没有， 返回 nil。


proc getCurrentExceptionMsg*(): string {.inline, benign.} =
  var e = getCurrentException()
  return if e == nil: "" else: e.msg
  #获取在当前异常的错误消息；如果没有，返回"" 。


proc onRaise*(action: proc(e: ref Exception): bool{.closure.}) =

can be used in a ``try`` statement to setup a Lisp-like

`condition system`:idx:\: This prevents the 'raise' statement to
## raise an exception but instead calls ``action``.
  ## If ``action`` returns false, the exception has been handled and
  ## does not propagate further through the call stack.
  if not isNil(excHandler):
    excHandler.hasRaiseAction = true
    excHandler.raiseAction = action
  #能够用在一个``try`` 语句去安装一个Lisp-like  `condition system`:idx:\:这个阻   止’raise’语句引起一个异常，而是调用``action``。如果``action``返回 false，这个异常已经被处理，不会通过调用堆栈进一步传播。

proc setCurrentException*(exc: ref Exception) {.inline, benign.} =
  currException = exc
  #设置当前的异常
  #**Warning**：如果你知道你要做什么，仅仅用这个。
```

## 调试程序

### 断言语句

```
var 
  x,y:int
proc `*`*(a,b:seq[int]):sqe[int]=
   newSeq(result,len(a))
   for i in 0..len(a)-1:result[i]=a[i]*b[i]
when is MainModule:
   assert(@[1,2,3]*@[1,2,3]**@[1,4,9],"测试重载运算符`*`")
```

### 设置断点

```
echo "hello world"
var x=10
echo "value of x:",x
```

### 调试

```
$ nim --lineDir:on --debuginfo c hello
$ gdb ./hello
(gdb) break hello.nim:3
Breakpoint 1 at 0x41f886: file /home/def/hello.nim, line 3.
(gdb) run
Starting program: /home/def/hello
Hello World
Breakpoint 1, helloInit () at /home/def/hello.nim:3
3       echo "Value of x: ", x
(gdb) print x_89010
$1 = 10
(gdb) print x_89010 = 200
$2 = 200
(gdb) c
Continuing.
Value of x: 200
```











