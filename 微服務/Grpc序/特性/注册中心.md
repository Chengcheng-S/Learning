# 注册中心

服务注册中心用来**实现服务发现**和**服务的原始数据存储**。

rpcx会自动将服务的信息比如服务名，监听地址，监听协议，权重等**注册到注册中心**，同时还会定时的将服务的**吞吐率更新**到注册中心。

若服务意外中断或者宕机，注册中心可以检测到这个事件，通知客户端该服务的问题，避免调用该服务

客户端初始化时会从注册中心得到服务器列表，根据不同的路由选择选择合适的服务进行服务调用，

## Peer2Peer

点对点：最简单的一种注册中心的方式，客户端直接得到唯一的服务器的地址，连接服务。（事实上没有注册中心）服务器不需要进行更多的配置

客户端使用`Peer2PeerDiscovery`设置服务的网络和地址

由于只有一个节点，选择器不可用

```go
d:=client.NewPeer2peerDiscovery{"tcp@"+addr,""}
xclient"=client.NewXClient("Arirh",client.Failtry,client.RandomSelect,d,client.DefaultOption)
defer xclient.Close()
```

**注**：rpcx使用`network@Host: port`,表示一项服务  network可以是：tcp，kcp，http，unix，quic，Host表示主机名或IP地址

NewClient必须使用**服务名称作为第一个参数**，

## MultipleServers

固定多台服务器提供相同的服务， 多个服务没有注册中心，使用**编码的方式**在客户端中配置服务的地址。

客户端使用`MultipleServersDiscoery`并设置该服务的网络和地址

```go
 d := client.NewMultipleServersDiscovery([]*client.KVPair{{Key: *addr1}, {Key: *addr2}})
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
```

必须在`MultipleServersDiscovery`中设置服务信息和元数据，对于服务变更（增加删除服务）调用 `update`动态更新。

```go
func (d *MultipleServersDiscovery) Update(pairs []*KVPair)
```

## ZooKeeper

为大型分布式计算提供分布式配置服务、同步服务和命名注册

ZooKeeper的架构通过冗余服务实现高可用性。若一次无答复，则询问另一台主机

> ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。

ZooKeeper一个应用场景就是服务发现，在java中广泛应用，Go也可以使用Zookeeper，尤其是在和Java项目混布的情况。

### 服务器

使用tag 简单实现该服务

`-tags zookeeper` 若需要多个特性，可以使用`-tags"tag1 tag2 tag3"`

服务端使用Zookeeper唯一的工作就是设置`ZookeeperRegisterPlugin`这个插件。

配置的参数：

- ServiceAdders：本机的监听地址，对外暴露的监听地址，格式为`tcp@ipaddress:port`
- ZookeeperServers:Zookeeper 集群的地址
- BasePath： 服务前缀，多个项目同时使用Zookeeper，避免命名冲突可以使用这个参数，为当前的服务设置命名空间
- Metrics：更新服务的TPS
- UpdateInterval:服务的刷新间隔,(在一定间隔内当前设置2*UpdateInterval 没有刷新，服务就会从Zookeeper中删除)。

注：插件必须在注册服务之前添加大Server中，否则插件没有办法获取注册的服务信息。

#### 服务端

```go
func main(){
    flag.Parse()
    s := server.NewServer()
    addRegistryPlugin(s)
    s.RegisterName("Arith", new(example.Arith), "")
    s.Serve("tcp", *addr)
}
func addRegistryPlugin(s *server.Server){
    r:=&serverplugin.ZookeeperRegisterplugin{
        ServiceAddress:"tcp@"+ *addr,
         ZooKeeperServers: []string{*zkAddr},
        BasePath:         *basePath,
        Metrics:          metrics.NewRegistry(),
        UpdateInterval:   time.Minute,
    }
    err:=r.Start()
    if err!=nil{
        log.Fatal(err)
    }
    s.Plugins.Addr(r)
}
```

运行：

```
go run -tags zookeeper server.go
```

#### 客户端

```go
 d := client.NewZookeeperDiscovery(*basePath, "Arith",[]string{*zkAddr}, nil)
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
```

运行：go run -tags zookeeper client.go

## Etcd

构建一个高可用的分布式键值(key-value)数据库，基于Go实现，

提供了RESTful接口，其他语言也可以使用，编译时需要加上`etcd `tag

### 服务器

服务器需要增加EtcdRegisterPlugin插件，配置参数和Zookeeper相同

- ServiceAddress：本机监听地址，对外暴露的监听地址，格式为`tcp@ipaddress:port`
- EtcdServers: etcd 集群地址
- BasePath:服务前缀。 如果有多个项目同时使用etcd，避免命名冲突，可以设置这个参数，为当前的服务设置命名空间
- Metrics：更新服务的TPS
- UpdateInterval: 服务刷新间隔，如果在一定时间间隔内(当前设为2 * UpdateInterval)没有刷新，服务就会从etcd中删除

插件必须注册到Server中，否则插件无法获取注册的服务信息

```go
func main() {
    flag.Parse()
    s := server.NewServer()
    addRegistryPlugin(s)
    s.RegisterName("Arith", new(example.Arith), "")
    s.Serve("tcp", *addr)
}
func addRegistryPlugin(s *server.Server) {
    r := &serverplugin.EtcdRegisterPlugin{
        ServiceAddress: "tcp@" + *addr,
        EtcdServers:    []string{*etcdAddr},
        BasePath:       *basePath,
        Metrics:        metrics.NewRegistry(),
        UpdateInterval: time.Minute,
    }
    err := r.Start()
    if err != nil {
        log.Fatal(err)
    }
    s.Plugins.Add(r)
}
```

### 客户端

客户端需要设置`EtcdDiscovery`插件   ，`basepath`etcd集群地址

```go
  d := client.NewEtcdDiscovery(*basePath, "Arith",[]string{*etcdAddr}, nil)
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
```

启动

```
go run -tags etcd client.go
```

## Consul

实现分布式系统的服务发现与配置。Consul是分布式的、高可用的、 可横向扩展的。它具备以下特性:

- 服务发现：Consul提供了通过**DNS**或者**HTTP**接口的方式来注册服务和发现服务。一些外部的服务通过Consul很容易的找到它所依赖的服务。
- 健康检测：: Consul的Client提供了健康检查的机制，可以通过用来**避免流量被转发到有故障的服务上**。
- key/value存储：应用程序可以根据自己的需要使用Consul提供的Key/Value存储。 Consul提供了简单易用的HTTP接口，结合其他工具可以实现动态配置、功能标记、领袖选举等等功能。
- 多数据中心： Consul支持开箱即用的**多数据中心**. 这意味着用户不需要担心需要建立**额外的抽象层**让业务扩展到多个区域。

Consul也是使用Go开发的，使用consul 需要添加 tags consul

### 服务器

需要配置`consulRegisterPlugin`插件

参数：

- ServiceAddress: 本机的监听地址， 这个对外暴露的监听地址， 格式为`tcp@ipaddress:port`
- ConsulServers: consul集群的地址
- BasePath: 服务前缀。 如果有多个项目同时使用consul，避免命名冲突，可以设置这个参数，为当前的服务设置命名空间
- Metrics: 用来更新服务的TPS
- UpdateInterval: 服务的刷新间隔， 如果在一定间隔内(当前设为2 * UpdateInterval)没有刷新,服务就会从consul中删除

```go
func main() {
    flag.Parse()
    s := server.NewServer()
    addRegistryPlugin(s)
    s.RegisterName("Arith", new(example.Arith), "")
    s.Serve("tcp", *addr)
}
func addRegistryPlugin(s *server.Server) {
    r := &serverplugin.ConsulRegisterPlugin{
        ServiceAddress: "tcp@" + *addr,
        ConsulServers:  []string{*consulAddr},
        BasePath:       *basePath,
        Metrics:        metrics.NewRegistry(),
        UpdateInterval: time.Minute,
    }
    err := r.Start()
    if err != nil {
        log.Fatal(err)
    }
    s.Plugins.Add(r)
}
```

### 客户端

需要配置`ConsulDiscovery` 使用`basepath`和 consul地址

```go
 d := client.NewConsulDiscovery(*basePath, "Arith",[]string{*consulAddr}, nil)
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
```

## mDNS

mdns 即多播dns，

mDNS主要实现了在没有传统DNS服务器的情况下使局域网内的主机实现相互发现和通信，使用的端口为**5353**，遵从dns协议，使用现有的DNS信息结构、名语法和资源记录类型。并且没有指定新的操作代码或响应代码。

> 在局域网中，设备和设备之前相互通信需要知道对方的ip地址的，大多数情况，设备的ip不是静态ip地址，而是通过dhcp 协议动态分配的ip 地址，
>
> 设备发现就需要用到了mDNS

mDns协议规定了**消息的基本格式**和**消息的收发的基本顺序**，DNS-SD协议在这基础上，首先对实例名，服务名称，域名长度/顺序等做出了具体的定义，然后规定了如何方便的进行服务发现和描述。

服务实例名称=<服务实例>.<服务名称>.<域名>

服务实例一般由一个或者多个标签组成，标签之间使用`.`隔开

服务类型表明**该服务是使用什么协议**实现的，由 _ 下划线和服务使用的协议名称组成，如大部分使用的 _tcp 协议，另外，可以同时使用多个协议标签，如: “_http._tcp” 就表明该服务类型使用了基于tcp的http协议。

域名一般都固定为 “local”

DNS-SD 协议使用了**PTR、SRV、TXT** 3种类型的资源记录来完整地描述了一个服务。当主机通过查询得到了一个PTR响应记录后，就获得了一个它所关心服务的实例名称，它可以同通过继续获取 SRV 和 TXT 记录来拿到进一步的信息。其中的 **SRV 记录中有该服务对应的主机名和端口号**。**TXT 记录中有该服务的其他附加信息**。

### 服务器

```go
func main() {
    flag.Parse()
    s := server.NewServer()
    addRegistryPlugin(s)
    s.RegisterName("Arith", new(example.Arith), "")
    s.Serve("tcp", *addr)
}


func addRegistryPlugin(s *server.Server) {
    r := serverplugin.NewMDNSRegisterPlugin("tcp@"+*addr, 8972, metrics.NewRegistry(), time.Minute, "")
    err := r.Start()
    if err != nil {
        log.Fatal(err)
    }
    s.Plugins.Add(r)
}
```

### 客户端

```go
func main() {
    flag.Parse()
    d := client.NewMDNSDiscovery("Arith", 10*time.Second, 10*time.Second, "")
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
    args := &example.Args{
        A: 10,
        B: 20,
    }
    reply := &example.Reply{}
    err := xclient.Call(context.Background(), "Mul", args, reply)
    if err != nil {
        log.Fatalf("failed to call: %v", err)
    }
    log.Printf("%d * %d = %d", args.A, args.B, reply.C)
}
```

## Inprocess

这个Registry用于进程内的测试。 在开发过程中，可能不能直接连接线上的服务器直接测试，而是写一些mock程序作为服务，这个时候就可以使用这个registry, 测试通过在部署的时候再换成相应的其它registry.

在这种情况下， client和server并不会走TCP或者UDP协议，而是直接进程内方法调用,所以服务器代码是和client代码在一起的。

```go
func main() {
    flag.Parse()
    s := server.NewServer()
    addRegistryPlugin(s)
    s.RegisterName("Arith", new(example.Arith), "")
    go func() {
        s.Serve("tcp", *addr)
    }()
    d := client.NewInprocessDiscovery()
    xclient := client.NewXClient("Arith", client.Failtry, client.RandomSelect, d, client.DefaultOption)
    defer xclient.Close()
    args := &example.Args{
        A: 10,
        B: 20,
    }
    for i := 0; i < 100; i++ {
        reply := &example.Reply{}
        err := xclient.Call(context.Background(), "Mul", args, reply)
        if err != nil {
            log.Fatalf("failed to call: %v", err)
        }
        log.Printf("%d * %d = %d", args.A, args.B, reply.C)
    }
}
func addRegistryPlugin(s *server.Server) {
    r := client.InprocessClient
    s.Plugins.Add(r)
}
```





















