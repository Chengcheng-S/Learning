# 超时

超时机制可以保护服务调用陷入无限的等待之中。超时定义了服务的最长等待时间，如果在给定的时间没有相应，服务调用就进入下一个状态，或者重试、或者立即返回错误。

### Server

使用`OptionFn`设置服务器的`readTimeout` 和`writeTimeout`

```go
erver struct
type Server struct {
	readTimeout time.Duration
	writeTimeout time.Duration
}    
```

超时的OptionFn

```go
func WithReadTimeout(readTimeout time.Duration) OptionFn
func WithWriteTimeout(writeTimeout time.Duration) OptionFn
```

### Client

客户端的两种方式超时

- 设置连接的read/write deadline
- context.Context

read/write deadline

client的Option 可以设置连接的超时值：

```go
type Option struct {
    ……
    //ConnectTimeout sets timeout for dialing
    ConnectTimeout time.Duration
    // ReadTimeout sets readdeadline for underlying net.Conns
    ReadTimeout time.Duration
    // WriteTimeout sets writedeadline for underlying net.Conns
    WriteTimeout time.Duration
    ……
}
```

`DefaultOption`设置连接超时值为10秒，但是没有设置`ReadTimeout`和`WriteTimeout`，若没有设置，则不会有超时限制。

由于多个服务可能共同一个节点，有可能出现多个服务互相影响的状况。

### context.Context 

控制超时

使用context.WithTimeout 设置超时时间

```go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
```

