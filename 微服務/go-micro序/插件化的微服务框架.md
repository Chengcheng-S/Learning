# GO-MICRO

插件化微服务框架

## 特性：

  服务发现： 通过服务发现自动注册和名称解析

  负载均衡： 基于发现构建的服务的只能客户端负载均衡

  同步通信： 基于RPC的通信，支持双向流

  异步通信： 为时间驱动架构内置的Pub/Sub接口

  消息编码： 基于带有protobuf和json内容类型的动态编码

  服务接口：所有功能都打包在一个简单的高级界面中，用于开发微服务

 

Micro

 查询寻和访问的微服务的工具包

·http到rpc的API网关

·web微服务的web代理

·sidecar作为服务网格

·用于命令行访问的CLI

·Bot通过Slack进行查询

 

## GO Micro

·分布式系统抽象

·服务发现rpc，pub/sub，消息编码

·容错超时，重试和负载均衡

·通过封装扩展功能

·可替换后端的插件接口

插件： 

  默认的consul或mDNS服务发现

  随机散列客户端负载均衡

  JSON-RPC以及PROTOBUF 消息编码

  HTTP通信机制

 

Go micro由多个软件包组成。

 

传输同步消息

代理异步消息

用于消息编码的编解码器

服务发现注册表

选择器进行负载平衡

客户端提出请求

服务器来处理请求

 

（Registry）注册机制： 提供了一个服务发现机制将名称解析为地址，服务在启动时进行注册，并在关闭时取消注册，服务可以选择一个到期TTL并在一段时间之内重新注册确保活跃 ，服务消亡即清除。

 

（Selector）选择器： 建立在注册表上的负载均衡抽象，允许使用过滤器功能对"服务"进行过滤，请求时利用选择器，使用内置的负载均衡机制

 

（Transport）传输：

  服务之间的同步请求/相应通信的接口，随意切换通信机制，支持双向流式传输。

 

编解码器（Broker）：

编码和解码，通过线路传输消息，

 

服务器

编写服务的构建模块，命名服务，注册请求处理程序，添加middeware等，该服务构建在go-micro，为服务请求提供统一接口，内置一个rpc系统的服务器，允许定义多个编码解码器，提供不同的编码信息。

客户端：

提供一个接口向服务器发送请求，提供一个统一的界面，用于使用注册机制，根据名称查找服务，使用选择器进行负载均衡机制，使用代理进行传输和异步消息传输的同步请求。

 

零依赖：

内置的零依赖的Multicast DNS服务注册表配置，在启动时将--registry=mdbs或MICRO_REGISTRY=mdns进行消息传递

 

 

注：：

google.golang.org/grpc 1.26后的版本是不支持clientv3的。

 

也就是说要把这个改成1.26版本的就可以了。

 

具体操作方法是在go.mod里加上：

 

replace google.golang.org/grpc => google.golang.org/grpc v1.26.0

replace github.com/lucas-clemente/quic-go => github.com/lucas-clemente/quic-go v0.14.1

 

 

GO-Micro API 

微服务API网关 ，提供http并动态路由配置到后端服务，将HTTP请求转换为RPC并转发给响应的服务，默认命名空间为go,micro.api micro API 符合api网关模式

 

原理：

构建在go-micro上，利用其进行服务发现，负载均衡，编码RPC通信，对API的请求及逆行HTTP提供，并通过rpc进行内部路由，支持插件化

 

Handler 

管理请求路由的HTTP处理程序

默认Handler使用注册表中的端口元数据来确定服务路由，未找到路由，则会退到API处理程序, 使用go-api配置注册路由

 

·1 API Handler ：/[service]/[method]

请求/响应： api.Request/api.Response

该路径用于解析服务和方法

请求通过API服务处理， API服务采用请求，api.Request和响应api.Response类型

请求/响应的定义在go-api/proto中

请求/响应主题的内容类型可以是任何东西

路由不可用的默认回退处理程序

通过--handler=api 设置

 

·2 RPC Handler： /[service]/[method]

请求/响应 ：json/protobuf

使用go-micro客户端将请求主体转发为rpc请求的默认处理程序的替代方案

允许使用具体的Go类型定义api处理程序

在不需要完全控制标题或请求 /响应的情况下很有用

可以用来运行单层后端服务，而不是其他的api服务

支持的内容类型 application/json和 application/protubuf

通过--handlder=rpc 设置

·3 反向代理： /[service]

请求/响应: http

该请求经过反向代理到服务的路径的第一个处理

这允许REST 在API 后面实现

通过--handler=proxy设置

 

·4 Event Handler： /[topic]/[event] 

异步请求处理程序向消息代理发布请求为事件

请求被格式化为go-api/proto.Event

通过--handler=event 进行设置

 

或 使用 /rpc端口直接与任何服务通话-期望参数：service，method，request， 可选address 指定路由

curl -d 'service=go.micro.srv.greeter' \

-d 'method=Say.Hello' \

-d 'request={"name": "Bob"}' \

http://localhost:8080/rpc

 

API Handler 请求/响应原型

默认处理原型，服务基于该原型使用特定的请求和响应处理，允许micro api 将HTTP请求解析为RPC 并返回到HTTP

 

安装 ：

go get github.com/micro/micro

 

micro api 运行

 

通过ACME 加密

通过使用letsencrypt的ACME，提供默认安全服务

micro --enable_acme api

 

指定主机白名单

micro --enable_acme --acme_hosts=example.com,api.example.com api

 

提供安全的TLS

该api 支持使用TLS 证书提供服务

micro --enable_tsl --tls_cert_flie=/path/to/cert --tls_key_file=path/to/key api

 

设置命名空间:

默认为服务名称空间： go.micro.api 命名空间和请求路径的组合用于解析发送查询的API服务和方法

micro api --namespace=com.example.api

 

 

micro api (localhost: 8080) 入口 api

api 服务 （go.micro.api,greeter）面向公众提供服务

| 后端服务 | (gp.micro.srv.greeter  ) 内部范围服务 |
| -------- | ------------------------------------- |
|          |                                       |

 

环境

consul agnt -dev

 

git clone https://github.com/micro/examples

 

 

 

启动服务 go.micro.srv.greeter

go run examples/greeter/srv/main.go

 

启动api服务 go.micro.api.greeter

go run examples/greeter/api/api.go

 

启动Micro API

micro api

 

**查询** 

通过micro API 进行HTTP调用

curl "http://localhost:8080/greeter/say/hello?name=Asim+Aslam"

 

HTTP path/greeter/say/hello 映射到服务 go.micro.api.greeter 方法下的Say.Hello

绕过 api服务并通过/rpc直接调用后端

curl -d 'service=go.micro.srv.greeter' \

-d 'method=Say.Hello' \

-d 'request={"name": "Asim Aslam"}' \

http://localhost:8080/rpc

 

**请求映射**

micro使用固定的命名空间和HTTP路径动态地路由到服务器。

这些服务地默认地命名空间为go.micro.api 可以通过--namespace标志设置命名空间

 

每个服务地API ：

创建每个后端服务地API服务模式，在逻辑上讲服务API前端和后端服务地分开

RPC 映射

URLs映射：

path       Service        Method

 

  **/foo/bar     go.micro.api.foo   Foo.Bar**

  **/foo/bar/baz   go.micro.api.foo   Bar.Baz**

  **/foo/bar/baz/cat  go.micro.api.foo.bar Baz.Cat**

 

**版本化地****API URL** **映射到服务名称**

**Path        Service       Method**

**/foot/bar     go.micro.api.foo   Foo.Bar**

**/v1/foot/bar    go.micro.api.v1.foo Foo.Bar**

**/v1/foo/bar/baz  go.micro.api.v1.foo Bar.Baz**

**/v2/foo/bar    go.micro.api.v2.foo Foo.Bar**

**/v2/foo/bar/baz  go.micro.api.v2.foo Bar.Baz**

 

 

**REST** **映射**

  **使用****api****反向代理并使用****go-restful****之类地库实现****RESTful****路径，从而为****restful API** **提供服务，使用****--handler=proxy****运行micro** **API** **会将代理请求反转为****API****名称地空间内地服务**

**path**           **Service          Method**

**/foo/bar       go.micro.api.foo      /foo/bar**

**/greeter       go.micro.api.greeter   /greeter:name**

**该处理程序直接与后端服务童话，忽略任何****go-micro****传输插件**

 

**统计仪表板**

**通过****--enable_****stats标志启用统计信息显示板，显示在****/stats****上**

**micro --enalbe_stats api**

 

 

**Micro Web**

 **提供了一个用于查看和查询服务地仪表板，以及一个用于****Micro Web****应用程序提供服务地反向代理。将****[/name]****通过注册表路由到响应的服务，前缀为****"go.micro.web"添加到名称中，可以在注册表中查找，并使用反向代理。根据服务解析的路径将HTTP****请求转发到响应的****WEB** **程序**

 

**API** 

 **_/(UI)**

 **_/[Service]**

 **_/rpc**

 

**特性**

**Feature            Description**

**UI**            **用于查看和查询正在运行地服务地仪表板**

**Proxy           Micro Web** **服务的反向代理****(****包括****websocket****支持****)**

 

 

**Proxy**

**micro web****为网络应用程序提供内置的****HTTP****反向代理，代理使用****/[Service]****以及命名空间****(****默认：****go.micro.web)****在服务发现中查找服务，将服务名称组为****[namespace].[name]** **该代理从请求中出去****/[Service],****将****URL****路径的其余部分转发给****web****应用程序，将头部****X-Micro-Web-Base-Path** **设置为已删除的路径。**

**Path       Service        Service Path  Header**

**/foo     go.micro.web.foo     /         /foo**

**/foo/bar   go.micro.web.foo     /bar       /foo**

**web****代理使用****Http****请求服务，没有其他的传输能力**

 

**运行****Web UI/Proxy**

 **micro web**

**通过浏览器访问** **localhost:8082**

 

**通过****ACME****提供默认安全服务**

 **micro --enable_name web**

**指定一个主机白名单**

**micro --enable_acme --acme_host=example.com,web.example.com web**

 

**提供****TLS** **安全**

 **web****代理支持使用****TLS****证书提供安全服务**

**micro --enalbe_tls --tls_cert_file=/path/to/cert --tls_key_file=/path/to/key web**

 

**设置命名空间**

**服务默认的命名空间为****go.micro.web** **名称空间和请求路径组合用于解析服务以及反向代理。**

**micro web --namespace=com.example.web**

 

**统计**

**--enable_stats** **标志启用统计信息显示板，**

**micro** **--enalbe_stats web**

 

 

**SRV** **服务**

 称为RPC或后端服务，属于后端架构的一部分，使用命名空间go.micro.srv

 

 

 

**Micro Sidecar**

  是go-micro的HTTP接口版本，将非Go程序集成到Micro环境中的方法

  构建高度可用和容错微服务的服务网格

  采用go-micro 具有相同的默认设置和可插拔性

 

 

HTTP API

-/[Service]/[method]

-/broker

-registry

-/rpc

 

特征

具有go-micro的所有功能

·服务发现

·消息总线

·RPC和代理处理程序

·负载均衡，重试，超时

·健康检测

·统计界面

·可通过go-micro插入

依赖

服务发现consul

brew install consul

consul agent-dev

 

运行

micro sidecar 

在端口8081 运行 Micro Sidecar

 

在启动时自动注册应用程序，指定应用程序的服务名和地址

micro sidecar --servce_name=foo --server_address=127.0.0.01:9090

 

ACME 加密

micro --enable_acme sidecar

指定一个主机白名单

micro --enable_acme --acme_hosts=example.com,proxy.example.com sidecar

 

 

提供TLS安全

Sidecar支持TLS证书服务

micro --enable_tls --tls_cert_file=/path/to/cert --tls_key_file=/path/to/key sidecar

 

在自动健康检查

-healthcheck_url= 启动健康检查器

执行： 自动服务注册；定期HTTP健康检测；通过非200响应取消注册

 

micro sidecar --server_name=foo --server_address=127.0.0.1:9090\ --healthcheck_url=http://127.0.0.1:9090/health

 

注册

注册服务

 

 

 

 

 

 

Handler

RPC

使用 json/protobuf查询微服务，对后端的请求将使用go-micro RPC客户端进行。

使用/[service]/[method]

所调用服务的默认命名空间为og.micro.srv

curl -H 'Content-Type:application/json'-d '{"name":"json"}'http://127.0.0.1:8081/example/call

使用/rpc端口

curl -d 'service=go.micro.srv.example'\

-d `method=Example.Call`\

-d `request={"name":"json"}`http://127.0.0.1:8808/rpc

 

Proxy

提供完整的http代理

启动： micro sidecar --handler=proxy

 

URL 映射与Micro API 相同

 

Path           Service         Method

/foo/bar    go.micro.srv.foo         Foo.Bar

/foo/bar/baz    go.micro.srv.foo         Bar.Baz

/foo/bar/baz/cat    go.micro.srv.foo.bar    Baz.Cat

 

版本化的API URL映射

 

Path    Service    Method

/foo/bar    go.micro.srv.foo    Foo.Bar

/v1/foo/bar    go.micro.srv.v1.foo    Foo.Bar

/v1/foo/bar/baz    go.micro.srv.v1.foo    Bar.Baz

/v2/foo/bar    go.micro.srv.v2.foo    Foo.Bar

/v2/foo/bar/baz    go.micro.srv.v2.foo    Bar.Baz

 

 

事件发布

curl -XPOST\

   -H "Timestamp:"\

-d "hello"\

"http://localhost:8081/borker?topic=foo"

 

CLI 代理

cli访问远程环境的代理

 micro --proxy_address=127.0.0.1:8081 list services

go.micro.srv.greeter

 

统计仪表板

通过--enable_stats标志启用统计信息显示板。它将暴露在/stats上。

 

micro --enable_stats sidecar

 

 

CLI

 micro cli为micro的命令行界面，提供了一种观察和运行环境交互的方式

服务列表

 micro list services

 go.micro.srv.example

 

获取服务

micro get service go.micro.srv.example

go.micro.srv.example

go.micro.srv.example-fccbb6fb-0301-11e5-9f1f-68a86d0d36b6 [:] 62421

 

查询服务

 

micro query go.micro.srv.example Example.Call '{"name": "John"}'

 

{

"msg": "go.micro.srv.example-fccbb6fb-0301-11e5-9f1f-68a86d0d36b6: Hello John"

}

 

查询服务健康

micro health go.micro.sv.example

node        address:port        status

go.micro.srv.example-fccbb6fb-0301-11e5-9f1f-68a86d0d36b6        [::]:62421        ok

 

 

通过CLI注册/去注册

micro register service '{"name": "foo", "version": "bar", "nodes": [{"id": "foo-1", "address": "127.0.0.1", "port": 8080}]}'

 

 

micro get service foo

 

service foo

 

version bar

 

Id  Address  Port  Metadata

foo-1  127.0.0.1  8080

 

micro deregister service '{"name": "foo", "version": "bar", "nodes": [{"id": "foo-1", "address": "127.0.0.1", "port": 8080}]}'

 

micro get service foo

 

Service not found

 

运行API 

micro api

 

运行sidecar

micro sidecar --server_name=foo --server_address=127.0.0.1:9090 --healthcheck_url=http://127.0.0.1:9090/_status/health

 

 

通过sidecar远程环境代理

 

micro --proxy_address=proxy.micro.pm list services

 

go.micro.srv.example

 

 

Bot 微型机器人

位于微服务环境中的机器人，可以通过Slack，HipChat，XMPP进行交互，通过消息传递模拟CLI的功能，可以添加其他命令来自动执行常用操作

 

支持的输入

Slack

HipChat

用于Slack运行

micro bot --inputs=slack --slack_token=SLACK_TOKEN

用于HipCahat运行

micro bot --inputs=hipcchat_username=XMPP_USER --hipchat_password=XMPP_PASSWORD

 

使用逗号分隔列表指定多个输入

micro bot --inputs=hipchat,slack --slack_token=SLACK_TOKEN --hipchat_username=XMPP_USER --hipchat_password=XMPP_PASSWORD

 

Mircro Run 

命令管理微服务的生命周期，获取源码，构建二进制文件并执行，可适用于本地开发的简单工具，未指定参数，则微运行作为可以管理其他服务的服务来运行

注： 默认运行时(GO)需要设置PATH和GOPATH中的GO 二进制文件

 

 

Run

micro run github.com/service/foo

 

Status

micro run -s github.com/service/foo

 

KILL

micro run -k github.com/service/foo

 

运行服务管理

micro run

 

推迟运行服务管理

micro run -x github.com/service/foo

 

运行并 重新启动

micro run -r github.com/service/foo

 

运行并更新源码

micro run -u github.com/service/foo

 

说明：

NAME:

  micro run - Run the micro runtime

 

USAGE:

  micro run [command options] [arguments...]

 

OPTIONS:

  -k    Kill service

  -r    Restart if dies. Default: false

  -u    Update the source. Default: false

  -x    Defer run to service. Default: false

  -s    Get service status

 

 

TODO 

·支持接收args和env变量的服务

·添加服务接口的go-run

·支持go以外的可配置运行时

·插件支持重建

·守护进程

·监控内存消耗并kill

·chroot进程

 

 

 

安装指南：

 依赖

 服务发现默认启动Consul

 

brew install consul

consul agent -dev

或 

decoker run consul

 

Multicast DNS

  进行零依赖的服务发现

将--registry=mdns传递给任何命令 

micro --registry =mdns list service