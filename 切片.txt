基于数组定义切片 a:=[...]int {1:22,3:55,6:55,9:88}
  b:=a[2:5]

对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误

使用make() 构造切片   make([]T,size,cap) T 切片的元素类型   size 切片中的元素数量    cap 切片容量

切片的本质就是对底层数组的封装，包括数组的指针、切片的长度，切片的容量cap

切片不能直接比较，唯一的合法比较操作就是与nil比较，一个nil值的切片并没有底层数组，其长度容量都为0。但是一个切片的长度容量为0 不能说这个切片就是nil。

判断一个切片是否为空，要用len()==0 而不是 s==nil

切片的赋值、拷贝： a:=make([]int,5,6)
b:=a    b[2]=100


切片遍历 支持索引和for range 遍历
s := []int{1, 3, 5}

	for i := 0; i < len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}


切片中添加元素  append()  调用append 必须用原来的切片变量接受原来的返回值
切片中添加切片e:=[...]int{1,2,3} a:=[]int{2:5,4:6,6:7}    e=append(e,a)    //切片中添加数组append(e,a...)


使用copy() 复制切片  
将一个切片的数据复制到另一个切片空间中 
copy(desSlice,srcSlice []T)  desSlice: 目标切片
srcSlice 数据来源切片

从切片中删除元素 a=append(a[:index],a[index+1：]....)

按照特点： 
值类型：int float  string bool array 传递的是数据副本
引用类型：slice 切片  传递的是地址，多个变量指向同一个内存地址


深拷贝： 拷贝的是数据本身，值类型的数据默认是深拷贝：int float array string bool struct


浅拷贝：拷贝的是数据、地址 导致多个变量指向同一块内存
引用类型的数据，默认都是浅拷贝 slice map

