指针：pointer 存储了另一个变量的内存地址的变量


*T是指针变量的类型，它指向T类型的值
var var_name *var-type  
// var-type 为指针类型    * 用于指定变量作为一个指针
var ip *int 指向整型



获取变量的地址
fmt.Printf("%p",$a)
获取指针变量中的数值 
fmt.Println("指针p中的数值：",*p)	
* 去这个变量中的内容
/*
    通过指针修改变量的数值
     */
    *p1=500
    fmt.Printf("a的值%v\n",a)

    /*
    指针的指针
     */
    var p2 **int
    p2=&p1
    fmt.Printf("p1的地址%p \n  p2的地址%p\n p2的值%v\n",&p1,&p2,*p2)
}


数组指针： 首先是一个数组，存储一个数组的地址

*[number]type


指针数组：存储指针的数组  

[number]*type

*[5]float64 指针，存储5个浮点类型的数据的数组的指针
*[5]string 指针，存储3个字符串类型的数据的数组的指针

[3]*string  数组，存储字符串的指针地址的数组
[5]*float64  数组 存储浮点型指针地址的数组

*[5]*float64  指针，一个数组的指针，存储了5个float类型的数据的指针地址的数组的指针
*[3]*string  指针，一个数组的指针，存储了3个字符串类型的数据的指针地址的数组的指针

**[4]string 指针，存储了4个字符串数据的数组的指针的指针

**[4]*strins 指针，存储了4个字符串指针地址的数组的指针 ，指针的指针


slice,map,function 存储数据的内存地址

函数指针： 一个指针，指向了一个函数的指针，因为golang中function 默认看作一个指针，没有*



指针函数： 一个函数，该函数的返回值是一个指针

函数指针.go



值传递（传递数据副本），引用传递（传递内存地址）
指针作为参数传递：
值传递，引用传递










