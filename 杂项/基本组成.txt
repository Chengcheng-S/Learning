go语言基础组成部分：
包声明   package main
引入包   import "fmt"
函数     func main(){   "{" 不能单独放到一行 
             fmt.Println("txt")
变量         }
语句&表达式
注释



运行  go run  **.go


go get 获取远程包  
go get -d 只下载不安装
go get -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用

go get -fix 在获取源码之后先运行fix，然后再去做其他的事情

go get -t 同时也下载需要为运行测试所需要的包

go get -u  强制使用网络去更新包和他依赖的包， 下载丢失的包，但不会更新已经存在的包

go get -v 显示执行的命令，操作流程的日志及信息，方便检查错误





import ：
    import "fmt"  引入fmt包，即可使用fmt下的所有函数，fmt实现了格式化IO（输入/输出）
1）点操作  import( ."fmt") 以此种方式引入的话，调用该包下的函数，则不需要前缀包名，即 Printf("...") 
2)别名操作  更改包名 import (f "fmt") ====> f.Printf('...')

3)_操作  _操作其实引入该包，而不直接使用包里的函数，而是调用了该包里的int函数
import ("database/sql*" _"github.com/ziuke/mymysql/godrv")


输出：
Print: 直接打印
Println :可以打印出字符串，和变量 打印完之后后边加一个换行符
Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量  %v 原样输出   %T 打印数据类型   %p 打印内存地址  %t 布尔类型  %s 字符串  %f 浮点型   %b 二进制整数  %d 十进制整数   %o 八进制整数  %x 十六进制整数 字母为小写 a-f    %X 十六进制整数 字母为大写字母 A-F
%c 打印字符


输入：

var x int
     var y float64
     fmt.Println("请输入一个整数！一个浮点数")
     fmt.Scanln(&x,&y) // 读取键盘输入，通过操作地址，赋值给对应的变量
     fmt.Printf("x的值%d,y的值%f\n",x,y)

     fmt.Scanf("%d,%f",&x,&y)
     fmt.Printf("x:%d,y:%f\n",x,y)



或 bufio
  fmt.Println("请输入一个字符串：")
     reader:= bufio.NewReader(os.Stdin)
     s1,_:=reader.ReadString('\n')
     fmt.Println("读取到的数据:",s1)

……………………………………………………………………

变量声明  变量需声明后才能使用，同意作用域内不支持重复声明，并且go语言的变量声明后必须使用 

变量声明必须使用

声明格式 ： var 变量名 变量类型 
       var name string
       var age int
       var isOK bool

批量声明
    var( a string
         b int 
         c bool
          ) 
变量初始化：
    go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值 整型和浮点型变量的默认值为'0' 字符串默认值为""  bool默认值为false   切片、函数、指针变量的默认值为null


var 变量名 类型 =  表达式
var age int = 12
var name ,age = '2',20


类型推导
    var name = "qi"

短变量声明：
    在函数内部，可以使用:= 方式声明并初始化变量

匿名变量：
    忽略某个值，可以使用匿名变量。匿名变量用一个下划线'_'表示    匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。
注： 1、函数外的每个语句都必须以关键字开始(var、const、func等)
2、:= 不能使用在函数外
3、‘_’ 多用于占位，表示忽略值

同一个作用域不能声明同名变量


常量声明：
   常量定义之后不能修改，程序运行期间不会改变
   关键字 'const'  const pi = 1.23456
const(n=100 
      c
      d)  声明多个常量的时候，如果省略了值则表示和上面一行的值相同

iota go语言的常量计算器，只能在常量表达式中使用
   iota在const关键字出现时将被重置为'0' const中每新增一行常量声明将使iota计数一次（iota可以理解为const语句块中的行索引），使用iota能简化定义，在定义枚举时很有用。

定义数量级：
 '<<' 左移操作
  '>>' 右移操作   

基本数据类型：
   整型

   浮点型：  float 32  float 64  打印浮点数时，可以使用fmt 配合%f   fmt.Printf("%f",math.Pi)

   复数：var c1 complex64   c1 = 1+2i 
         var c2 complex128  c2 = 3+5i


   bool:
   默认值位false； 不允许将整型强制转换位布尔型； 无法参与数值运算，无法与其他类型进行转换


字符串转义符：  \r 回车   \n 换行符   \t 制表符   \' 
单引号   \" 双引号   \\反斜杠

字符串使用双引号包裹，
单引号包裹的是字符 单独的汉字、字母、符号表示一个字符



定义多行 字符串时使用反引号 `

//  字符串长度
	fmt.Println(len(s1))
	var s2 string = "this is \n"
	var s3 string = "GOlang"
	//  字符串拼接
	fmt.Println(s2 + s3)

        s7 :=fmt.Sprintf("%s%s",s2,s3)
    fmt.Println(s7)


字符串切割： strings.Split  按照指定的字符串来切割字符串，分割后不包含指定的字符
  // 字符串切割
	fmt.Println(strings.Split(s2, "\n"))

SplitN 按照指定字符串切割字符串，并指定切割为几分
fmt.Println(strings.SplitN(s2, "\n", 3))
//[this is   go    is 
 a lang]



strings.SplitAfter 按照指定字符串切割原有字符串，切割后包含指定的字符串   

strings.SplitAfterN  按照指定字符串切割原有字符串, 切割为指定的份数, 切割完包含指定字符

strings.Fields(str)  按照空格切割字符串，连续多余空格按照一个处理

strings.Func 自定义分割字符串的标准
strings.Func(str,splt)


字符串包含：strings.Contains

字符串前缀： strings.HasPrefix()
字符串后缀： strings.HasSuffix()
字符串出现位置：strings.Index（）
join操作

数据类型转换 var_type(var) 兼容类型可以互相转换  bool 不能转化为其他形式  
strconv 对基本数据类型的字符串表示的转换
 常见的数值转换时 Atoi(string to int)  和 itoa(int to string)

go是静态语言，定义、赋值、运算必须一致
常量： 有需要的时候自动转换，
变量： 需要手动转换

 
常量： 格式  const name type = value


运算符： +、-、*、/、%、++、--
++、-- 不能参与运算，只能是一个单独的表达式

关系运算符： ==  ！== < > <= >=

逻辑运算符： && 与  ||或   ! 非

位运算符：将数值转化为二进制之后按位操作
按位&： 二元运算符  对应位的值如果都为1则结果为1，一个为0则为0
按位|  对应的值有一个为1则为1 
异或^   二元： a^b 对应的值不同为0，相同为1
        一元： ^a  按位取反  1……》0     0……》1

位清空： &^  a&^b  取决于b上的数值 如果为0 则取a上的数值； 如果为1，则结果为0

左位移运算符： << 左边操作数的值，向有操作数指定的位数

右位移运算符：>> 左边操作数的值由右操作数指定的位数向右移动




条件语句
 if bool {
	    true时执行
	} else{  false时执行}
	else{都为false时执行}
if的其他用法：   if 初始化语句; 条件{
}

eg: if num:=5; num>0{ ....else{...}}  num的作用域只在if语句之中




switch 语句
每个switch只能有一个default分支，一个分支可以有多个值，多个case值中间使用逗号分开 
分支可以是表达式 此时switch语句后不需要在跟变量判断
fallthrough 语法可以执行满足条件的case的下一个case




for循环结构  条件为true时一直循环，直到条件表达式结果为false 
for 初始语句;条件表达式;结束语句{
    循环体
}   

for的初始语句可以被忽略，但初始语句后的分号必须写
func demo(){ i:=0  for ; i<10;i++ {fmt.Println(i)} }

for的初始语句和结束语句都可以省略 func fordemo(){i:=0 for i<10 {fmt.Println(i) i++}}

for循环可以通过break、goto、return、panic语句强制退出循环

for range 键值循环 遍历数组、切片、字符串、map及通道
1）数组、切片、字符串 会返回索引和值
2）map返回键值和值
3）通道只会返回通道内的值

goto可以通过标签进行代码间的无条件跳转，可以快速跳出循环，避免重复退出，例如双层嵌套的for循环套退出的时：
goto tag_name

break 跳出循环  

continue 继续执行下次循环 ： 仅限于for循环使用 结束当前循环，又开始下一次循环的迭代过程











map：一种无序的基于key:value的数据结构，必须初始化才能使用
map[keytype]valuetype
map的默认初始值为nil，需要使用make函数来分配内存
make(map[keytype]valuetype,[cap]) cap可有可无 表示map的容量

判断某个键是否存在
value,ok :=map[key]  // 如果key存在 ok为true value为key对应的值，不存在ok为false，value为值类型的零值


map的遍历：for k,v :=range nameMap{ fmt.Println(k,v)}
遍历map时的元素顺序与添加键值对的顺序无关

键值对删除：delete(map,key)