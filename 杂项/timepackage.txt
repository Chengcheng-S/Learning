// 获取当前时间
	t1:=time.Now()

//  获取指定时间
	t2:=time.Date(2008,7,15,16,30,20,15,time.Local)

//time——string之间转换
	/*
	Format("格式模板")-》string
	模板日期必须是固定的 2006年1月2日 15:04:05
	 */
	s1:=t1.Format("06-1-2-3-4-5")

//  字符串类型数据转time类型
	/*
	time.Parse("模板",str)——》time,err
	 */
	s3:="1998年12月6日" //string
	t3,err:=time.Parse("2006年1月2日",s3)
	if err!=nil{
		fmt.Println("err",err)
	}
	fmt.Println(t3)


// 根据当前时间获取内容
	year,month,day:=t1.Date() // 年月日
	fmt.Println(year,month,day)

	hour,clock,second:=t1.Clock() //时分秒
	fmt.Println(hour,clock,second)
	fmt.Println(t1.YearDay())
	
	// 时间戳： 距离1970年1月1日零点的时间差值
	
	t1.Unix()
	
	t1.UnixNano() // 纳秒时间戳


// 时间间隔
	t5:=t1.Add(time.Minute) 可以是秒 分 时  在t1基础上加1分钟
	fmt.Println(t5)


	计算时间间隔：
	
	d1:=t5.Sub(t6)
	fmt.Println(d1)

// 睡眠 
   time.sleep(）



--------------------------------------------------
时间类型：
now:=time.Now() 获取当前的时间
now.Year() //年
now.Month()  // 月
now.Day()  // 日
now.Hour() // 时
now.Minute() //  分
now.Second() // 秒


时间戳
距离1970年1月1日至当前时间的总毫秒数，也被称为Unix时间戳
now.Unix()     //时间戳
 now.UnixNano() //纳秒时间戳

time.Unix()函数可以将时间戳转为时间格式
参数为  time.Unix(时间戳,0)

----------------------------------------------
时间间隔：
time.Duration 两个时间点之间经过的时间,以纳秒为单位
最长表示时间为290年

time包中定义的时间间隔类型的常量如下：

const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
例如：time.Duration表示1纳秒，time.Second表示1秒。


-------------------------------------------------------
时间操作
time+dur
add  ： func (t Time) Add(d Duration) Time


sub  时间间隔：
func (t Time) Sub(u Time) Duration
  返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。


Equal  
判断两个时间是否相等，会考虑时区的影响，因此不同时区标准的时间也可以正确比较,本方法和用t==u不同,这种方法会比较地点和时区信息。
   func (t Time) Equal(u Time) bool



Before
如果t代表的时间点在U按之前,返回真，否则返回假
 func (t Time) Before(u Time) bool

After
func (t Time) After(u Time) bool
如果t代表的时间点在u之后，返回真；否则返回假。

------------------------------------------------------
定时器：
time.Tick()  设置定时器，本质上为一个通道
func tickDemo() {
    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
    for i := range ticker {
        fmt.Println(i)//每秒都会执行的任务
    }
}


-------------------------------------------------------
时间格式化：
时间类型有一个自带的方法Format进行格式化
go的诞生时间2006年1月2号15点04分

如果想格式化为12小时方式，需指定PM。
now := time.Now()
    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan
    // 24小时制
    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))
    // 12小时制
    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))
    fmt.Println(now.Format("2006/01/02 15:04"))
    fmt.Println(now.Format("15:04 2006/01/02"))
    fmt.Println(now.Format("2006/01/02"))



解析字符串的时间
now := time.Now()
fmt.Println(now)
// 加载时区
loc, err := time.LoadLocation("Asia/Shanghai")
if err != nil {
    fmt.Println(err)
    return
}
// 按照指定时区和指定格式解析字符串时间
timeObj, err := time.ParseInLocation("2006/01/02 15:04:05", "2019/08/04 14:15:20", loc)
if err != nil {
    fmt.Println(err)
    return
}
fmt.Println(timeObj)
fmt.Println(timeObj.Sub(now))


