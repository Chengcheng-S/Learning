时间复杂度
程序运行所需要的时间，
时间频度(语句频度)，n称为问题的规模，当n不断变化时，时间频度也不断变化，通常情况下，算法中基本操作重复次数的时问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得n区域无穷大时，T(N)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数 记作T(n)=O(f(n))为算法的渐进时间复杂度

空间复杂度
程序运行所需要的内存大小
1、固定部分：指令空间（代码空间）、数据空间（常量、简单变量）所占的空间，属于静态空间
2、可变空间，动态分配的空间以及递归栈所需要的空间，该部分空间大小与算法有关。

 
度量时间复杂度的方法
1·事后统计法：指在程序运行结束之后直接查看运行时间的方式进行时间复杂度的统计
缺陷： 依赖计算机环境， 算法的测试困难


2·实现估计法：事先统计法采取在计算机编译程序前对该算法进行预估的方式估算
		利用时间频度以及函数的思维进行时间复杂度的解析。

3·函数符号  O最坏情况  Ω最好情况，   θ表示平均情况
对于一个算法的时间复杂度而言，n表示其执行问题的规模，O(n)表示执行该问题需要的时间量级
O(n)表示线性级别，O(n2)表示平方级别，n主要的判断方式为算法中的循环结构的执行次数
a)O(a）=O(1)      其中a为常数

b)O(an)=O(n)     其中a为常数

c)O(an2++bn+c)=O(n2)      其中a,b,c均为常数，结果只与最大项n有关



复杂度的度量方法
对于如何度量其最重要的是观察程序中的循环结构，每一个循环结构代表执行循环中的指令n次，而其余指令一般而言一行代码代表执行一次，对于一个程序而言，执行的次数相差较小其实没有什么区别，都是一瞬间执行完毕。


度量时间复杂度
O(1)/O(C)  c 代表常量

int main(){
    printf("Hello World");  //执行一次
    return 0;       //执行一次
}

如以上程序执行了两次即o(2)=o(1) 时间复杂度为o(1),称为常数级时间复杂度


O(n)
int main(){
    int n=10000,ans=0;  //执行一次
    for(int i=0;i<n;i++){   //执行n次
        ans+=i;     //执行一次
    }
    return 0;       //执行一次
}
执行了n*1+2次，即O(n*1+2),时间复杂度为O(n),称为线性阶时间复杂度


O(n^2)

int main(){
    int n=10000,ans=0;  //执行一次
    for(int i=0;i<n;i++){   //执行n次
        for(int j=0;j<n;j++){   //执行n次
            ans+=j;
        }
    }
    return 0;       //执行一次
}
执行 n*n*1+2次 即O(n*n*1+2)===> O(n^2)平方阶时间复杂度，以及三层循环结构嵌套组成的O(n^3)级别复杂度，立方阶复杂度随着嵌套的增多，甚至还有O(n!)级，称之为阶层级时间复杂度，但是这种级别复杂度极高，程序运行极其缓慢。




O(logn)

int main(){
    int i=1,n=10000;    //执行一次
    while(i<=n){    //执行logn次
        i*=2;
    }
    return 0;       //执行一次
}
i增长为倍增形式，i随着运行次数的增加变大的趋势变更大，时间复杂度一边为logn级别O(logn+2)=O(logn)


O(logn*N)
int main(){
    int n=10000,ans=0;  //执行一次
    for(int i=0;i<n;i++){   //执行n次
        int j=0;        //执行1次
        while(j<=n){    //执行log(n)次
            j*=2;
        }
    }
    return 0;       //执行一次
}

对于上文的对数级别的时间复杂度，一样可以实用别的循环进行嵌套，比如本样例O(n*(logn+1)+2)=O(n*logn)级别

除此之外还有很多种时间复杂度的组合，比如说O(2^n)这样的指数阶时间复杂度，有时甚至需要引入多个变量乃进行表示，不过最核心的还是要观察循环结构的处理。

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

在设计程序的时候一定要注意，高计算需求的地方一定不要使用太高的时间复杂度的计算方式



单链表：
链式存储结构，链表中的数据以结点表示，每个结点的构成：元素(数据元素的映像)+指针(知识后继元素的位置)
元素即存储数据的存储单元，指针则是连接每个节点的地址数据。
以"结点的序列"表示的线性表====》线性链表、单链表(链式存取结构)
单链表节点结构，DATA 数据元素   NEXT 指针，指向的区域，通常指向下一个节点，链表的尾部NEXT指向nil
data|*next
//定义结点类型
typedef struct Node {
    int data;       //数据类型，你可以把int型的data换成任意数据类型，包括结构体struct等复合类型
    struct Node *next;          //单链表的指针域
} Node,*LinkedList;
//Node表示结点的类型，LinkedList表示指向Node结点类型的指针类型

初始化
申请节点空间，同时对一个节点赋以空值
LinkedList listinit(){
    Node *L;
    L=(Node*)malloc(sizeof(Node));      //开辟空间
    if(L==NULL){                     //判断是否开辟空间失败，这一步很有必要
        printf("申请空间失败");
        //exit(0);                  //开辟空间失败可以考虑直接结束程序
    }
    L->next=NULL;       //指针指向空
}


创建单链表分为头部插入（模拟栈）、尾部插入（队列）
 // 初始化     头部插入
    LinkedList listinit() {
        Node *L;
        L = (Node *) malloc(sizeof(Node)); // 开辟空间
        if (L == nil) // 判断是否为空
        {
            printf("开辟内存空间失败");
            exit(0); //  退出程序
        }
        L->next = NULL; // 指针指向空

        int x;
        while (scanf("%d", &x) != EOF) {
            Node *p;    // 指向新的节点
            p = (Node *) malloc(sizeof(Node)); //  申请新节点
            p->data = x;    //节点数据域赋值
            p->next = L->next; // 将节点插入到表头   L-->|2|-->|1|-->NULL
            L-next=p;

        }
    }
    return L;
}

尾部插入
将新节点插入到链表尾部，加尾指针r，使其始终指向链表的尾结点
//单链表的建立2，尾插法建立单链表
  
LinkedList LinkedListCreatT() {
    Node *L;
    L = (Node *)malloc(sizeof(Node));   //申请头结点空间
    L->next = NULL;                  //初始化一个空链表
    Node *r;
    r = L;                          //r始终指向终端结点，开始时指向头结点
    int x;                         //x为链表数据域中的数据
    while(scanf("%d",&x) != EOF) {
        Node *p;
        p = (Node *)malloc(sizeof(Node));   //申请新的结点
        p->data = x;                     //结点数据域赋值
        r->next = p;            //将结点插入到表头L-->|1|-->|2|-->NULL
        r = p;
    }
    r->next = NULL;
    return L;
}


遍历单链表
建立指向链表L的节点，沿链表L逐个向后搜索
修改元素： 链表内容修改，将链表中x的值修改为y
插入操作
链表的增加结点操作主要分为查找到第i个位置，将该位置的next指针修改为指向我们新插入的结点，而新插入的结点next指针指向我们i+1个位置的结点。其操作方式可以设置一个前驱结点，利用循环找到第i个位置，再进行插入。
删除操作
删除元素要建立一个前驱结点和一个当前结点，当找到了我们需要删除的数据时，直接使用前驱结点跳过要删除的结点指向要删除结点的后一个结点，再将原有的结点通过free函数释放掉。



双向链表
每个数据结点有两个指针，分别指向前一结点和后一结点，双链表任意节点开始，
一个完整的双向链表头结点pre指针为空，尾结点 的next指针指向空。其余结点前后相连

*pre|data|*next
实现：
typedef struct line{
    int data;
    struct line *pre; // 前结点
    struct line *next; //  尾结点
}line,*a;

双向链表创建
创建头结点然后添加，对于逐步添加数据，我们采取的做法是，开辟一段新的内存空间作为新的结点，为这个结点进行的data进行赋值，然后将已成链表的上一个结点的next指针指向自身，自身的pre指针指向上一个结点。
创建双链表
line* initLine(line * head)
{
    int number,post=1,input_data;// 结点数量、当前位置、输入的数据
    printf("输入创建结点的大小\n");
    scanf("%d",&number);
    if (number<1)
    {
        return NULL; // 非法输入
    }
    head=(line *)malloc(sizeof(line));  //头结点建立
    head->pre=NULL;
    head->next=NULL;
    printf("输入第%d个数据\n",post++);
    scanf("%d:",input_data);
    head->data=input_data; // 头结点赋值

    line *list=head;
    while(post<=number)
    {
        line *body=(line *)malloc(sizeof(line));
        body->pre=NULL;
        body->next=NULL;
        printf("输入%d数据\n",post++);
        scanf("%d",&input_data);
        body->data=input_data;

        list->next=body;
        body-pre=list->next;
    }
    return head;
}

}
创建头结点——创建一个新的结点——将头结点和新节点互相连接——再度创建新的结点。。。


双向链表插入操作




堆排序

