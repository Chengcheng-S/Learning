# Polkadot 

## 混合共识

Polkadot 的共识算法：

- NPOS
- BABE
- GRANDPA

### NPOS

共识在Polkadot中，中继链上的验证者需要分配到各个平行链，为其提供区块链验证能力，是Polkadot共享安全性的一部分，因此中继链的验证者，对于整个Polkadot多链系统的安全性至关重要。

NPOS(Nominated Proof of Stake)共识算法选举验证者集合。

Polkadot中的四种角色

- **验证人 （validators）**：中继链的全节点，中继链会在验证人池中通过随机分组把验证人指定给不同的平行链，验证人会接受来自收集人打包的区块进有效性验证，然后结合共识算法对收集人提交的区块进行确认。
- **提名人（Nominators）**：在Polkadot中数字货币DOT的持有人，会选择自己信任的验证人进行DOT质押，然后分享验证人的收益。、
- **收集人 （collectors）**：是平行链的全节点，负责收集和执行平行链的交易并产生候选区块，将区块和证明交给验证人，并通过收集交易获得手续费，收集人类似于pow中的miner。
- **钓鱼人（fishermen）**：也是平行链的全节点，监控验证人的非法行为，若验证人作恶（如批准了无效的平行链区块），fishermen可以向其他验证人举报并获得相应的报酬。



波卡系统的设计中，提名人的数量理论上是不设限（越多的提名人参与投票阶段，参与选举的资金额度就越大，系统相对的就更安全）。验证者的数量则是不能太多，不然会影响系统的整体性能（数量多的话就类似于挖矿模式了，所有的节点作为验证者），因此数量是系统中的固定值

#### 选举模型

Polkadot的设计哲学中，认为选举策略需要满足下面的“三大原则：

- **Balance**：验证者在出块的时候比重相同，因此该策略在Stake分配需要尽量平均，保证网络安全
- **Support**：让尽可能多的Stake资金涌入，因此提名者只负责选投那些候选者，但是对于Stake具体分配是无权干涉的，**这部分是由NPOS 算法计算得到的**。
- **Fair representation**：Stake 多的提名者选投的验证人更可能出现在验证者集合中。（资金多的人，对结果影响大一些）

在提名者给出自己的投票之后，每一个候选者都可以给出自己对于上述选举问题的一个可行解。在上述这些可行解的集合中，利用链上的方案比较方案，按照之前的“三大原则”来比较这些方案，选取其中最优的方案最为最后验证人选举结果，这样就完成了一轮选举。

### BABE

Blind Assignment for Blockchain Extension

用于出块的引擎，类似于Ourobros  Praos 一种PoS协议。

BABE 算法是基于slots的，在Polkadot中每一个slot差不多6秒

> 每个slot时间段中BABE会选出一个leader来出块。BABE中leader的选举是通过一个随机函数（VRF）来实现的，在每个slot阶段，每一个节点会通过运算VRF函数来获得一个数值，如果这个数值小于网络中预先规定好的阈值，那么节点就会认为自己就是这个时间段的leader，于是节点就开始出块了。



由于VRF函数是随机生成数字的，所以可能造成在某一slot中没有leader或者有多个节点算出自己的VRF值小于阈值进而产生多个leader的情况。

当没有leader产生时，Polkadot就规定按照顺序来决定谁是leader，这个顺序是预先确定好的。当出现多个leader的时候，Polkadot允许多个节点都提交区块，而最终区块的确认则由**GRANDPA**来决定。



### GRABDPA

GRANDPA则是用来做区块确认的，GRANDPA的时间复杂度***\*O(n²)\****。但是Polkadot之所以采用GRANDPA是因为GRANDPA并不是每次只确认一个区块，它每一次都会确定好几个区块来做确认。

#### 具体流程：

1. 一个主节点广播之前一轮确认之后的区块高度
2. 等待网络延迟以后，每个节点都广播他们认为的可以被确认的最高的区块（pre-vote）
3. 每个节点对步骤2接受到的区块集进行计算，算出他们认为的能够被确认的最高区块，并且将结果广播出去(pre-commit)；
4. 当节点接收到足够的pre-commit的消息能够确认区块后就会形成commit的消息，一般认为大于2/3就可以被确认了。

在步骤2  pre-vote，有可能会有昨儿节点投票区块并广播出去，如此会导致分叉。

Polkadot为了防止这种情况的发生使用了一个叫做**Account Safety**的方式。

> 如果当网络中出现了要分叉的commit信息时，Polkadot的节点会马上采取Account Safety的机制。每个节点都会询问其他节点他们所看到的pre-vote的情况，节点都会回复他们收到的信息，这样就很容易检查到有哪些恶意节点投了两个区块。最后这些被抓到的作恶节点将会被踢出共识网络，永远不能进入。



> 通过结合BABE和GRANDPA我们可以看到在出块的时候Polkadot采用BABE出块，此时节点之间只要发送一次块信息即可，这样的话时间复杂度仅仅是***\*O(n)\****，在出块之后节点之间再采用GRANDPA进行块确认，此时由于确认阶段节点之间要通过二次确认来保证确认块结果的一致性，时间复杂度是***\*O(n²)\****，不过由于是多个块一次性进行确认，所以两者结合的混合共识是非常高效的，比普通的PBFT共识要高效很多。





## 共享安全性

Polkadot 给平行链提供了共享安全性，保障了不因区块链网络分片而降低安全性。

### 有效性验证

**有效性验证**指的是区块链系统对账本状态变更的合法性校验，实现全网的共识。

在Polkadot中，对平行链的区块共识需要进行以下三个级别的有效性验证：

- 第一级的有效性验证是由平行链的验证人实现，可以防止收集人作恶。
  - 每隔一段时间，中继链会把所有的验证人随机分配到不同的平行链，每个平行链会分配到多个验证人。
  - 平行链区块上的收集人收集交易，产生新区块后，将新区块、有效证明和一些相关的数据发送给平行链的验证人，验证人收到这些信息之后，验证区块的有效性，若区块有效，则将收到的内容分成多个部分，构造一棵merkle tree，然后将每一份内容、默克尔证明以及区块信息组合，进行签名并发送给其他验证人。
- 第二级有效性验证由fishermen保证，防止平行链验证人和收集人联合作恶
  - fishermen一般是全节点，需要在中继链上放置押金，然后持续从收集人节点收集区块，并验证有效性。若区块中包含了无效交易，则fishermen将提交报告，正确的话则会获得奖励，错误则会受到惩罚。
- 第三级的有效性检查由非平行链验证人执行
  - 这些验证人的选择是非公开的，且验证人数量由fishermen给出的无效报告和收集人给出的不可用报告的数量确定。如果检测到无效的平行链区块，则为其签名的验证人将会受到惩罚，它的押金将会部分或全部扣除。



#### 验证人验证平行链区块的过程

平行链接入polkadot时，需要向中继链注册一段wasm代码 STVF（state transaction verification function），验证人将使用STVF对平行链有效性进行验证。

若某个平行链PC_1 上已经确认区块是B0，当前待出区块为B1，上一个区块经中继链确认之后，在中继链上区块B 记录了B0相关信息，若平行链执行完B0之后的状态树根为R0，之后收集人打包了区块B1，得到该区块向其他平行链的跨链消息M，并生成有效性证明P 以及其他的数据（如：R1 执行完B1之后的状态树根。Hb0 平行链区块B0的hash 等）生成有效证明实际上就是执行区块消息的过程，将执行过程中的数据记录下来，并结合区块执行前后的两个状态根生成证明。

区块的有效性证明数据都是由该区块的交易涉及的状态读写集的SPV组成，因此它的大小是有限的。

收集人C将区块B1、交易的有效性证明P、该平行链的出队列中的消息集合M以及元数据一起发给其中一个验证人，验证人再将这些信息分发给这条平行链的其他验证人。

每个验证人该平行链的STVF对收到的平行链区块进行有效性验证。

> STVF的核心也是**执行平行链区块中的交易**，过程中需要读取证明数据中的读集合，同时会产生写集合，并最后生成的写集合和证明数据中的内容进行比对；此外还可以通过收到的元数据中的信息进行一些其他的验证，如根据中继链的区块hash 找到给区块中保存的B0的 状态根R0，将R0和收到的 原始的状态根（在执行区块B1之前的状态）进行对比，一致的话则区块通过验证。

最初收到平行链区块的那个验证人将生成一个Candidate Receipt，里面会记录该平行链区块B1相关的信息。签名并广播给中继链所有节点（可以认为这是中继链的交易）。当这个Candidate Receipt最终被中继链出块确认以后，平行链PC的区块B也被最终确认了。



### 可用性保障

指区块链系统在部分节点作恶的情况下，依然可以对业务系统提供可用服务保障。

平行链收集人打包了区块B，并提交给验证人进行验证，验证人经过有效性验证之后，区块被中继链确认。若是收集人没有把该区块广播到平行链的其他节点，那么平行链的其他节点就不能接收到该节点然后更新本地状态数据，导致该平行链之后无法出块。为了防止这种情况产生，通过验证以后，验证人会把平行链区块和证明通过纠删码技术分成N个片段（n 即全网验证人数量），并将这些片段广播给全网的所有验证人，每个验证人获得一个片段之后会保存一段时间。 之后只需要N/3个片段即可恢复原始数据。即使收集人节点作恶，平行链节点依然可以从中继链验证人中获取上个区块的纠删码片段并恢复原始数据。

























