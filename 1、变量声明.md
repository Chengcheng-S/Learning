## 声明

nim：静态类型，使用值之前需要声明赋值的类型

### 关键字声明（可变赋值）

var 语句声明一个**本地或者全局变量**

```python
var name:type

var name:type=value
```

nim 具有类型推断的能力，自动检测名称赋值的类型，而无需说明类型。

```python
var a:int  // 变量的类型为整数，没有显示设置值
var b=7    // 变量的值为7，类型Zion给检测
```

无法再名称中使用空格，这会将空格拆分为两个。 Nim区分大小写和下划线的含义，并且名称相同。

赋值语句为一个变量赋予新值或者更一般地，赋值到一个存储地址

`=` 是 *赋值操作符* 。赋值操作符可以重载。

**注**：使用过程对声明的多个变量进行赋值时可能会产生意外结果：编译器会 *展开* 赋值并多次调用该过程。 如果程序的结果取决于副作用，变量可能最终会有不同的值。为了安全起见，**多赋值时使用没有副作用的过程**。

同时声明多个变量

```python
var
  a=11
  b="string"
  c=3.15
  d=false
```

变量可变，但是更改前后的类型必须一致

```python
var f=3.14
f=3.15
f=7.666
f="hello nim" // error
```

### 不可变赋值

`const`  `let` 

#### 常量

**常量是绑定在一个值上的符号。常量值不能改变。编译器必须能够在编译期对常量声明进行求值**

```python
const g=78
g=32   //error

const i=-1
const i=-1+5 //error
```

变量在编译时不计算(其值在程序运行期间会更改)

#### let

在编译时，声明的不可变分配不需要知道，在执行时，可以随时设置其值，一旦设置无法更改。  let语句声明时必须给变量初始化，而var语句声明时无需初始化，

**let和const的区别**：let引进一个不能被重新赋值的变量，conts意味着“执行编译时的评估，并把它放到一个数据段”

```python
let j=78
j=-27  #  j cannot be assigned to

let k=-2
let k=6+j
```

### 赋值语句

给变量或更一般的存储单元分配一个新值，

```python
var
  x = “abc”
  y: string = “def”
  z: int
x = “xyz”
y = “lmn”
z = 3
```

## 标识符

在Nim中标识符可以是由字母、数字和下划线组成的任何字符串，但必须以字母开头。两个相连的下划线__是不允许的:

```python
letter ::= ‘A’..’z’ | ‘a’..’z’ | ‘\x80’..’\xff’
digit ::= ‘0’..’9’
IDENTIFIER ::= letter ( [‘_’] (letter | digit))*
```

## 关键字

```go
addr and as asm atomic 
bind block break 
case cast concept const continue converter
defer discard distinct div do 
elif else end enum except export 
finally for from func 
generic 
if import in include interface is isnot iterator 
let 
macro method mixin mod 
nil not notin 
object of or out 
proc ptr 
raise ref return 
shl shr static 
template try tuple type 
using 
var 
when while with without 
xor 
yield
```
