# 模板

**模板是一种简单形式的宏，它是一个运行在nim抽象语法树基础之上的子构成机制，他在编译器的传递过程中被执行**

> 模版是Nim语言中的抽象语法树，它是一种简单的替换机制，在编译期被处理，这个特性使Nim语言可以和C语言很好的运行在一起

激发一个模板和调用一个过程的语法形式是一致的：


```python
template `!=`(a,b:expr):expr=
  |  
该定义在系统模块中是存在的   
	not(a==b)
assert(5!=6)
# the compiler rewrites that to: assert(not (5 == 6))
```

类似于：`=`,`>`,`in`,`>=`,`notin`,都是模板，a>b 可以转换为b<a   a in b <===>contains(b,a)

notin和isnot 有着明显的意思， 模板类型可以是表达式，声明或者是类型描述，这些被称作是元类型，只在特定的环境中使用，这里也可以使用真实的类型，这就实现了表达式的功能

如果重载==操作符，`!=`运算符也被提供出来，并可以做正确的事情

```python
const
	debug=true
proc log(msg:string){.inline.}=
	if debug:stdout.writeln(msg)
var 
  x=4
log("x has value is "& $s)  
```

**模板参数可以是普通类型，也可以是表达式**

```python
template withFile(f: expr, filename: string, mode: FileMode,
                  body: stmt): stmt {.immediate.} =
  let fn = filename
  var f: File
  if open(f, fn, mode):
    try:
      body
    finally:
      close(f)
  else:
    quit("cannot open: " & fn)
 
withFile(txt, "ttempl3.txt", fmWrite):
  txt.writeln("line 1")
  txt.writeln("line 2")
```

### 普通模板和立即模板

普通模板(ordinary template )即是**重载的**方式实现的，这种模板的参数在模板激活之前**需要检验**，所以**普通模板不能接受没有声明的指示符（undeclared identifiers ）**

```python
template declareInt(x:expr)=
  var x:int
declareInt(x) // 错误不能识别标识符x   
```



立即模板(immediate template)不参与重载的机制，所以模板的参数在模板激活之前不需要检验，因此它可**以接受没有声明的标识符**

```python
template declareInt(x:expr) {.immediate.}=
   var x :int
declareInt(x)   //  有效 该模板不会出错   
```

### 模板传参

若模板有一个**stmt**参数，应该放在**模板声明的最后**，因为语句通过一个特别的语法传递给模板。

```pyton
template withFile(f,fn,mod:expr,actions:stmt):stmt {.immediate.}=
   var f:File
   if open(f,fn,mod):
     try:
        actions
     finally:
        close(f)
   else:
     quit("cannot open" &fn)
withFile(txt,"naem.txt",fmWrite)
    txt.writeLine("line1")
    txt.writeLine("line1")
```

本例中**writeLine属于actions参数**

### 符号绑定在模板内

模板是一个精简的宏，开辟了一个新的范围，大多数符号都是来源于模板范围中的定义。

```
//module A
var 
  lastId=0
template genId*:expr=
   inc(lastId)
   lastId
```

```
//module B
import A
echo genId() //  正常工作，因为`lastId`已经被绑定在`genId`的定义域之中
```

一般的符号可能受mixin和bind语句的影响

### 标识符构建

在模板中标识符的构建是通过反引号实现的

```
template typedef(name:expr,typ:typedesc){.immdiate.}=
   type 
      `T name`*{.inject.}=typ
      `P name`*{.inject.}=ref `T name`
typedef(myint,int)
var x :PMyInt
```

本例中name 初始化为myint，所以T name 编程了Tmyint

### 模板规则的查询参数

模板中的参数p可以以表达式x.p 的形式出现。模板参数可以作为一个域名或者一个全局符号，可以被具有相同名称的阐述所覆盖(当限定符完全一致时)

```
# module 'm'

type
  Lev = enum
    levA, levB

var abclev = levB

template tstLev(abclev: Lev) =
  echo abclev, " ", m.abclev

tstLev(levA)
# 运行的结果: 'levA levA'
```

这个**全局变量**可以通过**bind语句捕获**

```
# module 'm'

type
  Lev = enum
    levA, levB

var abclev = levB

template tstLev(abclev: Lev) =
  bind m.abclev   #模版内部通过m.abclev捕获全局变量
  echo abclev, " ", m.abclev

tstLev(levA)
# 输出: 'levA levB'
```

每一个默认的模板都是干净的： 模板内部声明的局部标识符在模板的实例化语境中不能获取。

```
template newException*(exceptn: typedesc, message: string): expr =
  var
    e: ref exceptn  # e is implicitly gensym'ed here
  new(e)
  e.msg = message
  e   #这个语句起何作用？？？

# so this works:
let e = "message"
raise newException(EIO, e)
```

模版中定义一个符号在**实例范围中是否可见**，是受inject和gensym控制的。**Gensym**类型的变量是**不可见**的，**injec**t类型的变量在实例域是**可见**的。

默认实体**type，var let** 和**const**是**gensym**类型的变量， **proc,interator ,converter,template,macro** 是**inject**类型。

```
template withFile(f, fn, mode: expr, actions: stmt): stmt {.immediate.} =
  block:
var f: File  # since 'f' is a template param, it's injected implicitly
         #因为f是模版参数，所以暗含着它是内置类型的
    ...

withFile(txt, "ttempl3.txt", fmWrite):
  txt.writeLine("line 1")
  txt.writeLine("line 2")
```

inject型和gensym语句是**第二类**注释，在模板定义的范围**之外**就**没有**语义了。

### 方法调用语法的局限性

在x.f重写f(x)之前，表达式x.f中的x需要语法检查(符号查找和类型检查), 因此当使用`.`来使用模板或者宏时`.`的语法有一些约束

```
template declareVar(name: expr): stmt =
  const name {.inject.} = 45

# Doesn't compile:不能够编译
```

```
from sequtils import toSeq

iterator something: string =
  yield "Hello"
  yield "World"

var info = toSeq(something())
```

**在toSeq（）过程把something()转换为序列之前，编译器已经认为它是个迭代器了，所以不能编译**











