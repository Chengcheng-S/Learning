# 异常

Nim的异常类型是对象类型，Nim中的异常类型命名应该以`Error`为后缀， 在system中定义了异常类型的基类，若要抛出异常，必须为这个异常的`msg`属性赋值

## raise语句

使用`raise`引发异常

```python
var 
	e:ref OSError
new(e)
e.msg="the error because of raise"
raise e
```

运行之后产生一个错误信息

```
Error: unhandled exception: the error because of raise 
[OSError]
```

### 简洁的写法

```python
raise newException(OSError,"the error beacuse of raise")
```

system模块提供的`nesException`方法简化raise语句

## try

```python
var
  f: File
if open(f, "numbers.txt"):
  try:
    let a = readLine(f)
    let b = readLine(f)
    echo "sum: ", parseInt(a) + parseInt(b)
  except OverflowError:
    echo "overflow!"
  except ValueError:
    echo "could not convert string to integer"
  except IOError:
    echo "IO error!"
  except:
    echo "Unknown exception!"
    # reraise the unknown exception:
    raise
  finally:
    close(f)
```

执行try中的程序。引发一个异常。那么就会执行响应的except语句。若后面的except语句没有明确列出这个异常，则会执行一个空的语句

finally语句内的程序都会被执行，若一个异常没有得到处理，那么这个异常会从堆栈向上传播，

使用``getCurrentException方法或者getCurrentExceptionMsg方法``来访问异常对象。

```python
try:
  doSomethingHere()
except:
  let
    e = getCurrentException()
    msg = getCurrentExceptionMsg()
  echo "Got exception ", repr(e), " with message ", msg
```

## 方法上的异常注解

使用`{.raise.}`对某一个方法进行注解，编译器就会检测这个方法，会不会抛出异常，若会，则编译失败

```python
proc complexProc() {.raises: [IOError, ArithmeticError].} =
  ...
 
proc simpleProc() {.raises: [].} =
  ...

```















