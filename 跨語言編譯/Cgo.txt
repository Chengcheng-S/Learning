通过 import “c”启用CGO的特性，go build 命令会在编译和连接阶段启动gcc编译器

```go
package main

//#include<stdio.h>

import "C"

func main(){
	C.puts(C.CString(str))
}
```

通过import "C" 启动CGO特性，包含C语言的<stdio.h>头文件，通过cgo下的C.CString()函数将go字符串转为C的字符串，最后通过C.puts输出
注：可以用注释符//和/**/包围C代码
import “C” 和包含C代码之间是没有空行的

自定义C函数

```go
package main

/*
#include <stdio.h>

static void SayHello(const char* s){
	puts(s);
}
*/
import "C"

func main() {
	//println("hello C go！")
	C.puts(C.CString("hello, \n"))

	/*
		自定义C函数
	*/
	C.SayHello(C.CString("自定义的C函数"))

}
```


注：  注意，如果之前运行的命令是go run hello.go或go build hello.go的话，此处须使用go run .或go build .



CGO 不止用于golang中调用C函数，也可以导出C函数给C语言调用
抽象 一个hello.h的模块，全部接口函数都在hello.h文件定义
void  SayHello(/*const*/ char* s);

创建一个hello.go 用golang重写c语言中的接口 SayHello() 函数
...

```go
import "C"

//export SayHello   将golang实现的sayhello函数导出为c语言函数
func sayhello(s *C.char){
	fmt.Println(C.CString(s))
}
通过面向C语言接口的编程技术，简化函数的使用，可以将sayhello当作一个标准库的函数使用
package main
//#include<hello.h>
import "C"
func main(){
	C.SayHello(C.CString("go——>c\n"))
}
```



面向C接口的GO编程




CGO基础

import "C" 表示CGO 启用 上边的注释中包含C的语句，确保在CGO的前提下，可以在当前目录中包含c/c++源文件



类型转换
在Go语言中访问C语言的符号时，一般是通过虚拟的“C”包访问，比如C.int对应C语言的int类型

Go字符串切片
在CGO生成的_cgo_export.h头文件中还会为Go语言的字符串、切片、字典、接口和管道等特有的数据类型生成对应的C语言类型：

结构体、联合、枚举类型
C语言的结构体、联合、枚举类型不能作为匿名成员被嵌入到Go语言的结构体中。在Go语言中，我们可以通过C.struct_xxx来访问C语言中定义的struct xxx结构体类型
若c struct中的成员名称为go的关键字可以使用_name的方式进行访问

C语言结构体中位字段对应的成员无法在Go语言中访问，如果需要操作位字段成员，需要通过在C语言中定义辅助函数来完成。对应零长数组的成员，无法在Go语言中直接访问数组的元素，但其中零长的数组成员所在位置的偏移量依然可以通过unsafe.Offsetof(a.arr)来访问。



联合类型使用C.union_name 访问，go不支持联合类型，将转为对应大小的字节数组。
在golang中操作联合类型
1、定义辅助函数
2、使用"encoding/binary"手工解码成员
3、使用unsafe强制转换为对应的类型

```go
union B {
	int i;
	float f;
};
fmt.Println("b.i:", *(*C.int)(unsafe.Pointer(&b)))
	fmt.Println("b.f:", *(*C.float)(unsafe.Pointer(&b)))
```


枚举类型使用C.enum_name 进行访问
在C语言中，枚举类型底层对应int类型，支持负数类型的值。我们可以通过C.ONE、C.TWO等直接访问定义的枚举值


数组、字符串和切片
C.CString针对输入的Go字符串，克隆一个C语言格式的字符串；返回的字符串由C语言的malloc函数分配，不使用时需要通过C语言的free函数释放

C.CBytes函数的功能和C.CString类似，用于从输入的Go语言字节切片克隆一个C语言版本的字节数组，同样返回的数组需要在合适的时候释放。

C.GoString用于将从NULL结尾的C语言字符串克隆一个Go语言字符串。

C.GoStringN是另一个字符数组克隆函数。

C.GoBytes用于从C语言数组，克隆一个Go语言字节切片。

本质：
当Go语言字符串和切片向C语言转换时，克隆的内存由C语言的malloc函数分配，最终可以通过free函数释放。当C语言字符串或数组向Go语言转换时，克隆的内存由Go语言分配管理。


在C语言中可以通过GoString和GoSlice来访问Go语言的字符串和切片。如果是Go语言中数组类型，可以将数组转为切片后再行转换。如果字符串或切片对应的底层内存空间由Go语言的运行时管理，那么在C语言中不能长时间保存Go内存对象。

指针间的转换
在Go语言中两个指针的类型完全一致则不需要转换可以直接通用。如果一个指针类型是用type命令在另一个指针类型基础之上构建的，换言之两个指针底层是相同完全结构的指针，那么我我们可以通过直接强制转换语法进行指针间的转换。
go禁止两个非同类型指针相互转换
cgo两个不同类型的指针间的相互转换

```go
var p *X
var q *Y

q = (*Y)(unsafe.Pointer(p)) // *X => *Y
p = (*X)(unsafe.Pointer(q)) // *Y => *X
```

为了实现X类型指针到Y类型指针的转换，我们需要借助unsafe.Pointer作为中间桥接类型实现不同类型指针之间的转换。unsafe.Pointer指针类型类似C语言中的void*类型的指针。

任何类型的指针都可以通过强制转换为unsafe.Pointer指针类型去掉原有的类型信息，然后再重新赋予新的指针类型而达到指针间的转换的目的



数值和指针的转换
Go语言禁止将数值类型直接转为指针类型
Go语言针对unsafe.Pointr指针类型特别定义了一个uintptr类型。我们可以uintptr为中介，实现数值类型到unsafe.Pointr指针类型到转换。再结合前面提到的方法，就可以实现数值和指针的转换了



首先是int32到uintptr类型，然后是uintptr到unsafe.Pointr指针类型，最后是unsafe.Pointr指针类型到*C.char类型。



切片间的相互转换

```go
var p []X
var q []Y

pHdr := (*reflect.SliceHeader)(unsafe.Pointer(&p))
qHdr := (*reflect.SliceHeader)(unsafe.Pointer(&q))

pHdr.Data = qHdr.Data
pHdr.Len = qHdr.Len * unsafe.Sizeof(q[0]) / unsafe.Sizeof(p[0])
pHdr.Cap = qHdr.Cap * unsafe.Sizeof(q[0]) / unsafe.Sizeof(p[0])
```



函数调用
CGO可以将go函数导出为c函数 也可以将c函数在go中调用



