# 泛型

泛型二叉树

```python
type
	BinaryTreeObj[T]=object
    le,ri:BinaryTreeObj[T]
    data: T   
    BinaryTree*[T] = ref BinaryTreeObj[T] # type that is exported
 
proc newNode*[T](data: T): BinaryTree[T] =
  # constructor for a node
  new(result)
  result.data = data
 
proc add*[T](root: var BinaryTree[T], n: BinaryTree[T]) =
  # insert a node into the tree
  if root == nil:
    root = n
  else:
    var it = root
    while it != nil:
      # compare the data items; uses the generic ``cmp`` proc
      # that works for any type that has a ``==`` and ``<`` operator
      var c = cmp(it.data, n.data)
      if c < 0:
        if it.le == nil:
          it.le = n
          return
        it = it.le
      else:
        if it.ri == nil:
          it.ri = n
          return
        it = it.ri
 
proc add*[T](root: var BinaryTree[T], data: T) =
  # convenience proc:
  add(root, newNode(data))
 
iterator preorder*[T](root: BinaryTree[T]): T =
  # Preorder traversal of a binary tree.
  # Since recursive iterators are not yet implemented,
  # this uses an explicit stack (which is more efficient anyway):
  var stack: seq[BinaryTree[T]] = @[root]
  while stack.len > 0:
    var n = stack.pop()
    while n != nil:
      yield n.data
      add(stack, n.ri)  # push right subtree onto the stack
      n = n.le          # and follow the left pointer
 
var
  root: BinaryTree[string] # instantiate a BinaryTree with ``string``
add(root, newNode("hello")) # instantiates ``newNode`` and ``add``
add(root, "world")          # instantiates the second ``add`` proc
for str in preorder(root):
  stdout.writeln(str)    
```

泛型是Nim来确定参数表示过程、迭代器或者类型参数的手段，是最有效的高类型安全容器

### is操作符

is运算符实在编译时检查是否类型相等，它对于泛型代码里的类型特殊化十分有用

```
type 
 Table[key,value]=object
   keys:seq[key]
   values:seq[value]
   when not (key is string)
```

### type operator

type 运算符用于得到一个表达式类型

```
var x=0
var y:type(x)  // y has type int
```

如果type被用于确定一个过程、迭代器、转换器 call c(X)(x可能表示一个空的参数列表) c 解释成一个迭代器要

```
import strutils

var z:type("a,b,c".split)
```

> strutils contains both a ``split`` proc and iterator, but since an
>
> iterator is the preferred interpretation, `y` has the type ``string``:

### Type Classes

type是一个伪类型，它可以用来匹配类型重载决议或上下文的操作符。Nim支持以下的内置type类型：

| type class |     matches     |
| :--------: | :-------------: |
|   object   | any object type |
|   tuple    | any tuple type  |
|    enum    | any enumeration |
|    proc    |  any proc type  |
|    ref     |  any ref type   |
|    prt     |  any ptr type   |
|    var     |  any var type   |
|  distinct  | any array type  |
|    set     |  sny set type   |
|    seq     |  any seq type   |
|    auto    |    any type     |
|            |                 |

type类可以使用标准的布尔操作符组合在一起形成更复杂的type类型

```
//create a type class that will match all tuple and object types

type RecordType=(tuple or object)
prco printFileds(rec:RecordType)=
   for key,value in fieldPairs(rec):
      echo key,"=",value   
```

注意： 第三行必须带括号，没有括号时，调用过程会出错，类型不匹配(逻辑运算符优先级要高于赋值预算符。)

程序以这种方式利用 type类 被认为是 隐式的泛型。他们用在程序中，将会为每一个独特的综合参数类型被实例化一次。

Nim 也允许 type类和普通类型 作为类型约束，来约束泛型类型参数

```
proc onlyIntOrString[T: int|string](x, y: T) = discard

onlyIntOrString(450, 616) # valid
onlyIntOrString("xx","yy")
#onlyIntOrString(5.0, 0.0) # type mismatch
#onlyIntOrString("xy", 50) # 'T' 不能同时代表两种类型。
```

默认情况下，在重载决议时，每一个命名的type类将绑定到一个具体的类型，

```
proc `==`*(x,y:tuple):bool=
   reslut= true
   for a,b in fields(x,y):
      if a!=b:result = false
```

要求a，b时相同的元组类型

或者，**distinct类型修饰符可以用在type类里，允许每个参数匹配类绑定到一个不同类型的type类**， **如果一个过程的参数没有指定一个类型，Nim将用distinc auto type类(**任何类)

```
proc concat(a,b):string=
    result =$a & $b
```

过程以隐式的泛型风格写过程，将经常需要引用匹配泛型类型的类型参数**，通过`.`**进行访问

```
type Matrix[T, Rows, Columns] = object
  ...
proc `[]`(m: Matrix, row, col: int): Matrix.T =
  m.data[col * high(Matrix.Columns) + row]
```

type 运算符能够被用在 proc 参数上有同样的效果，当匿名类型或distinct 类型使用时，当一个泛型类型实例化为type类而不是一个具体的类型,这将导致另一个更具体的类型

```
seq[ref object]  # Any sequence storing references to any object type

type T1 = auto
proc foo(s: seq[T1], e: T1)
  # seq[T1] is the same as just `seq`, but T1 will be allowed to bind
  # to a single type, while the signature is being matched

Matrix[Ordinal] # Any Matrix instantiation using integer values
```

### 用户自定义类型

concepts 用于指定一个匹配类型必须满足要求的任意集合

```
type
  Comparable = concept x, y
    (x < y) is bool

  Container[T] = concept c
    c.len is Ordinal
    items(c) is iterator
    for value in c:
      type(value) is T
```

concepts是一个匹配结果：

1. 主体中的所有表达式都可以针对测试类型进行编译
2. 主体中的静态计算的布尔表达式都必须为**true**

跟在concept关键字后面的标识符表示当前匹配类型的实例。当在期待一个值的语境中，这些实例都可以作为这个类型的变量。

注：is 操作符允许一个容易验证的精确类所需操作的特征，但是由于类型推断和默认参数仍然引用在所提供的块里，他也可能使用不显示细节的协议来编码。

**special rule**： 当写concepts时提供更多的便利，任何类型的值出现在一个可调用表达式将被视为一个**指定类型的变量那个用于重载决议，除非类型值通过它的显式的typedesc[T]形式。**

```
type
  OutputStream= concept s
    write(var s, string)
```

测试类型concepts被完全实例化一次，任何的静态代码包含他们也会执行一次

### 泛型中符号查找

泛型中的符号绑定规定规则：  有**open**  和**close**符号，**一个closed符号不能被重新绑定到实例化的语句中**，一个open符号可以， **默认的重载符号时打开的**，**其他符号时关闭的**

```
type
  index= distinct int
proc `==` (a,b:int):bool{.borrow.}

var a= (0,0.index)
var b=(0,0.index)
echo a==b
```

泛型 == 对于元组（在系统模块中定义）使用 == 操作符操作元组的部件。然而 == 因为Index 类型被定义在元组 == 后面，然而这个编译例子作为考虑到当前的定义符号的实例化。

**一个符号能通过一个mixin****声明被迫打开**：

```
proc create*[T]():ref T=
   mixin init
   new result
   init result
//此处没有重载init 所以需要声明它是显示打开符号    
```

### bind 声明

绑定声明与mixin语句相对，它能够被用于明确的声明应该早期被绑定的标识符（标识符应该在定义的模板/泛型的范围内能够被查出）

```
//module a
var lastId=0
template genId* :expr=
  bind lastId
  inc(lastId)
  lastId
```

```
//module B
imort A
echo genId()
```

bind 很少用，因为来自定义范围的符号绑定是默认的



```
ype
  Pair[T,U] = object
    first:T
    second:U

method getFirst*[T,U](pair:Pair[T,U]): T = 
  result = pair.first

method getSecond*[T,U](pair:Pair[T,U]): U =
  result = pair.second

method setFirst*[T,U](pair:var Pair[T,U];value:T) = 
  pair.first = value

method setSecond*[T,U](pair:var Pair[T,U];value:U) = 
  pair.second = value
  
var 
  var1:Pair[string,int]


var1.setFirst("yrs")
var1.setSecond(22)
echo var1.getFirst()
echo var1.getSecond()
```





```
proc print[T](value:T) = 
  echo value
  
print[int](1)
print(1)
print("yrs")
```













