# GOlang中的复合数据类型

## 指针

pointer 存储了另一个变量的内存地址的变量。支持指针类型`*T`,指針的指針`**T`

```go
var var_name *var-type  
```

默认值 nil，没有 NULL 常量，操作符 "&" 取变量地址，"*" 透过指针访问⺫标对象。

## 数组

由一个固定长度的特定类型元素组成的序列，一个数组可以有0或多个元素组成，因为数组元素时固定的所以go中很少使用数组。

1. 數組是值類型，賦值和傳參會複製整個數組，而不是指針，
2. 長度必須是常量，且是類型的組成部分([3]int,[2]int 不是同一種類型)，
3. 支持`==`,`!=`因爲内存總是被初始化過的
4. • 指针数组 [n]*T，数组指针 *[n]T。

对于数组中的元素可以使用索引下标来获取，而`len`可以获取数组的元素个数

```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}
​
// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```

默认情况下，数组的每个元素都被初始化为元素对应的类型零值

对于一维数组，在数组长度位置可以用...表示数组的长度，编译器会根据初始化值得个数来计算

```go
var a =[...]int{7,8,9}
fmt.Printf("%T\n",a) // [3]int  
```

数组得长度时数组类型的一部分，且必须为常量表达式,数组的长度需要在编译阶段确定

```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]
​
// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}
​
// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```



## Slice

可变的序列，序列中的每个元素都有相同的类型，一个slice类型一般写作[]T, 无固定长度，slice是一个轻量级的数据结构，可以访问数组子序列/全部的元素的功能，其底层为`引用数组对象`，由三部分组成`指针、长度、容量`

1. 引用類型，但自身是結構體，值拷貝傳遞
2. len 表示元素的數量，讀寫操作不能越界
3. cap 最大容量，不能超出限制
4. slice==nil  len、cap==0

> 指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

多个slice可以共享底层的数据，并且引用的数组部分区间可以重叠

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素.`slice[:]` 全部元素

因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换言之，复制一个slice只是对底层的数组创建了一个新的slice别名。

数组的反转应用：

```go
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
```

注：slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者的两种风格的混合语法初始化。

与数组不同的式 slice之间不能比较，所以不能使用==操作两个slice，可以使用`bytes.Equal`函数来判断两个字节类型的slice是否相等

对于其他类型的元素，需要展开进行比较：

```go
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

slice 不支持比较运算的原因：一个slice是间接引用，另一个silce甚至包含数组的全部元素；` 因为slice的元素是间接引用的，一个固定值的slice在不同的时间可能包含不同的元素，因为底层数组的元素可能会被修改。`

> 并且Go语言中map等哈希表之类的数据结构的key只做简单的浅拷贝，它要求在整个声明周期中相等的key必须对相同的元素。对于像指针或chan之类的引用类型，==相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。
>
> ​																						----《GO语言圣经》



slice 唯一合法的比较操作就是与nil比较

```go
if  slice ==nil{//do  something}
```

一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，

检测一个slice是否为空，使用`len(s)==0` 而不是 s==nil来判断

内置的make函数创建一个指定元素类型、长度和容量的slice

```go
make([]T,len)
make([]T,len,cap)
```

在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过slice才能引用底层匿名数组的变量,slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。

## Map

在golang中一个map就是一个哈希表的引用。(哈希表是一个无需的key/value组合，其中所有的key都是不同的，然后通过指定的key可以在常数时间复杂度内检测、更新或删除对应的value)。

map中的key类型必须一致， value的类型也必须一致。但是key---value之间可以是不同的类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。(尽量不用浮点数作key，因为极端情况下会出现NaN)

创建：

```go
b:=make(map[T]T)
a:=make(map[T1]T2){
	T1:T2
	T1:T2
}

b[T1]=T2

空map    make(map[int]string){}

预先给 make 函数⼀个合理元素数量参数，有助于提升性能。因为事先申请⼀⼤块内存，
可避免后续操作时频繁扩张。
```

元素删除

```go
delete (map,key)   //remove element map[key]
```

**map中的元素并不是一个变量**，所以不能进行`&`操作

```go
_=&age["mk"]  // compile error: cannot take address of map element
```

禁止对map元素取地址的原因是因为map可能随着元素数量的增长而重新分配更大的内存空间，从而导致之前的地址无效

如果一个查找失败将返回value类型对应的零值，而且`x += y`和`x++`等简短赋值语法也可以用在map上，所以上面的代码可以改写成

```go
ages["bob"] += 1
ages["bob"]++
```

map的遍历

```go
for key,value :=range maps{
	fmt.Printf("%v=====>%v\n",key,value)
}
```

注：map的迭代顺序是不确定的，并且不同的哈希函数可能导致不同的遍历顺序。每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。若要强制按照顺序遍历key/value的时候，必须显式的对key进行排序，可以使用sort下的strings 函数对字符串slice进行排序

```go
import "sort"

var names []string
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
```

map类型的零值为nil，也就是未引用任何的哈希表

```go
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
```

注：map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值得map存入元素将导致panic

```go
ages["carol"] = 21 // panic: assignment to entry in nil map
```

在使用map之前`首先要创建map`，

通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值。判断数据是否在map之中

```go
age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }

或
if age,ok:=range["tom"];!ok{.....}
```

map之间也不能进行相等比较；唯一的例外是和nil进行比较。map的零值为`nil`，nil的map既没有键也不能添加键

Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能

### Map 存储方式

Map是一种通过key来获取value的一个**数据结构**，其**底层存储方式为数组**，在存储时key不能重复，当key重复时，value进行覆盖，通过对Key进行hash运算，然后对数组长度取余，得到key的存储位置，然后将key和value组装为一个结构体，放入数组下标

### hash 冲突

数组一个下标处只能存储一个元素，也就是说一个数组下标只能存储一对key，value,

对于重名的key 需要使用hash冲突解决，

#### **开放定址法**：

存储一个key，value时，发现hashkey(key)的下标已经被别key占用，那我们在这个数组中空间中重新找一个没被占用的存储这个冲突的key。 其中又有线性探索法，线性补偿探索法，随机探索法

##### 线性探索

从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个空位置存储这个key，当数组都找不到的情况下会扩容（事实上当数组容量快满的时候就会扩容了）；

查找某一个key的时候，找到key对应的下标，比较key是否相等，如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，说明key不存在。

#### 拉链法

理解为链表，当key和hash冲突时，在冲突位置上形成一个链表，通过指针互相连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空。

##### 开放定址（线性探测）和拉链的优缺点

- 拉链法比线性探测处理简单
- 线性探测查找是会被拉链法会更消耗时间
- 线性探测会更加容易导致扩容，而拉链不会
- 拉链存储了指针，所以空间上会比线性探测占用多一点
- 拉链是动态申请存储空间的，所以更适合链长不确定的







## 结构体

聚合数据类型，由零个或者多个任意类型得值聚合成得实体，每个值称为结构体得成员

声明：

```go
type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
```

对成员得访问如下

```go
dilbert.Salary -= 5000 // demoted, for writing too few lines of code
```

或者对成员取地址，然后通过指针访问

```go
position := &dilbert.Position
*position = "Senior " + *position // promoted, for outsourcing to Elbonia
```

点操作符也可以指向结构体得指针一起工作

```go
var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player)"
```

等价于

```go
(*employeeOfTheMonth).Position += " (proactive team player)"
```

结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。

 划重点：结构体的成员`首字母`为`大写字母`开头，那么该成员就是可以被外部访问的(导出的),一个结构体中允许导出和非导出的存在(即成员的字段可以是大写 ，也可以小写)。

结构体类型的零值是每个成员都对是零值。通常会将零值作为最合理的默认值，结构体没有任何成员的话就是空结构体，写作struct{} ，其大小为0，不包含任何信息，又是还是有价值的

```go
seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ...first time seeing s...
}
```

### 匿名字段

匿名字段不过是⼀种语法糖，从根本上说，就是⼀个与成员类型同名 (不含包名) 的字段。 被匿名嵌⼊的可以是任何类型，当然也包括指针。不能同时嵌⼊某⼀类型和其指针类型，因为它们名字相同。

```go
type User struct{
	name string
}
type Per struct{
	User 
	Age int
}
```



## json

基本的json类型有数字 、bool、string其中字符串是以双引号包含的Unicode字符序列，支持Go语言类似的反斜杠转义特性，

一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成以系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。

```go
boolean         true
number          -273.15
string          "She said \"Hello, BF\""
array           ["gold", "silver", "bronze"]
object          {"year": 1980,
                 "event": "archery",
                 "medals": ["gold", "silver", "bronze"]}
```

假定一个struct

```go
type Movie struct {
    Title  string
    Year   int  `json:"released"`
    Color  bool `json:"color,omitempty"`
    Actors []string
}

var movies = []Movie{
    {Title: "Casablanca", Year: 1942, Color: false,
        Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
    {Title: "Cool Hand Luke", Year: 1967, Color: true,
        Actors: []string{"Paul Newman"}},
    {Title: "Bullitt", Year: 1968, Color: true,
        Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
    // ...
}
```

## 文本和HTML模板

有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。

一个模板是一个字符串或一个文件，里边包含了一个或者多个{{}}包含的对象，大部分的字符串只是按面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。

在一个action中，`|`操作符表示将前一个表达式的结果作为后一个函数的输入,

生成模板的输出需要两个处理步骤，第一步是哟啊分析模板并转为内部表示，然后基于指定的输入执行的模板，分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板templ。注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。

```go
func daysAgo(t time.Time) int {
    return int(time.Since(t).Hours() / 24)
}

report, err := template.New("report").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ)
if err != nil {
    log.Fatal(err)
}
```

template.Must辅助函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为nil（如果不是nil则发出panic异常），然后返回传入的模板。

```go
var report = template.Must(template.New("issuelist").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ))

func main() {
    result, err := github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    if err := report.Execute(os.Stdout, result); err != nil {
        log.Fatal(err)
    }
}
```

html/template模板包。它使用和text/template包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。

使用命令查看包下相关信息

```go
go doc package_name
```

## 引用类型

go中的引用类型包括	`slice`,`map`,`channel`,他们有复杂的内部结构，除了申请内存之外，还需要初始化相关的属性。

对于Go来说，map，function，channel都是特殊的指针，指向各自特定的实现，一个为`nil`的slice，除了不能索引外，其他的操作都是可以的，可以使用`append`进行填充。interface并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：(Type, Value)。只有当类型和值都是`nil`的时候，才等于`nil`。

说一说new和make的区别

new(T)与make(T,args) 均用来分配内存，new(T)会为T类型的新值分配已置零的内存空间，并返回地址(指针),即类型为*T的值，返回一个指针，改指针指向新分配的、类型为T的零值。适用于值类型， 数组、结构体

make(T,args)返回初始化之后的T类型的值，该值并不是T类型的零值，也不是*T,是经过初始化之后的T的引用。make()只适用于slice、map、channel













