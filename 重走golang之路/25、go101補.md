# 類型轉換

## 類型轉換規則

在Go中，如果一个值`v`可以被显式地转换为类型`T`，则此转换可以使用语法形式`(T)(v)`来表示。 在大多数情况下，特别是`T`为一个类型名（即一个标识符）时，此形式可简化为`T(v)`。

一个值`x`可以被隐式转换为一个类型`T`，这同时也意味着`x`可以被显式转换为类型`T`

### 顯然的類型轉換規則

兩個類型表示同一個類型，則他們的值可以相互轉換爲這兩個類型當中的任意一個

- `byte`<===>`uint8`
- `rune`<====>`int32`

### 底層類型相關的類型轉換規則

給定一個非接口值x和一個非接口類型T, 假設x的類型為Tx,

- 如果類型Tx和T的底層類型相同，則x可以被顯示轉換為類型T
- 如果類型Tx和T中至少有一個是非定義類型并且他們的底層類型相同(考慮結構體字段),則x可以被隱式的轉換爲類型T
- 如果類型Tx和T的底層類型不同，但是兩者都是非定義的指針類型并且他們的基類的底層類型相同，(忽略結構體字段標簽),則x只能被顯示轉換爲類型T

### 通道相關的類型轉換規則

给定一个通道值`x`，假设它的类型`Tx`是一个双向通道类型，`T`也是一个通道类型（无论是双向的还是单向的）。如果`Tx`和`T`的元素类型相同并且它们中至少有一个为非定义类型，则`x`可以被**隐式**转换为类型`T`。

### 接口實現相關的類型轉換規則

给定一个值`x`和一个接口类型`I`，如果`x`的类型（或者默认类型）为`Tx`并且类型`Tx`实现了接口类型`I`，则`x`可以被隱式转换为类型`I`。 此转换的结果为一个类型为`I`的接口值。此接口值包裹了

- `x`的一个副本（如果`Tx`是一个非接口值）；
- `x`的动态值的一个副本（如果`Tx`是一个接口值）。

给定一个动态类型为`T`的接口值`x`，`x`可以通过类型断言的方式`x.(T)`安全地转换为类型`T`。

给定一个接口值`x`和一个接口类型`I`，如果`x`的动态类型实现了接口类型`I`，则`x`可以通过类型断言的方式`x.(I)`安全地转换为接口类型`I`。

### 類型不確定值相關的類型轉換規則

如果一个类型不确定值可以表示为类型`T`的值，则它可以被**隐式**转换为类型`T`。

```go
func main() {
	var _ []int = nil
	var _ map[string]int = nil
	var _ chan string = nil
	var _ func()() = nil
	var _ *bool = nil
	var _ interface{} = nil

	var _ int = 123.0
	var _ float64 = 123
	var _ int32 = 1.23e2
	var _ int8 = 1 + 0i
}
```

### 常量相關的類型轉換規則

常量的类型转换结果一般仍然是一个常量。

给定一个常量值`x`和一个类型`T`，如果`x`可以表示成类型`T`的一个值，则`x`可以被显式地转换为类型`T`；特别地，如果`x`是一个类型不确定值，则它可以被**隐式**转换为类型`T`。

### 非常量類型轉換

非常量浮点数和整数值可以被显式转换为任何浮点数和整数类型。非常量复数值可以被显式转换为任何复数类型。

注：

- 非常量复数值不能被转换为浮点数或整数类型。
- 非常量浮点数和整数值不能被转换为复数类型。
- 在非常量数值的转换过程中，溢出和舍入是允许的。当一个浮点数被转换为整数时，小数部分将被舍弃（向零靠拢）。

```go
func main() {
	var a, b = 1.6, -1.6 // 类型均为float64
	fmt.Println(int(a), int(b)) // 1 -1

	var i, j int16 = 0x7FFF, -0x8000
	fmt.Println(int8(i), uint16(j)) // -1 32768

	var c1 complex64 = 1 + 2i
	var _ = complex128(c1)
}
```

### 字符串相關轉換規則

1. 如果一个值的类型（或者默认类型）为一个整数类型，则此值可以被当作一个码点值（rune值）显式转换为任何字符串类型。
2. 一个字符串可以被显式转换为一个字节切片类型，反之亦然。 字节切片类型是指底层类型为`[]byte`的类型。
3. 一个字符串可以被显式转换为一个码点切片类型，反之亦然。 码点切片类型是指底层类型为`[]rune`的类型。

### 非類型安全指針轉換

非类型安全指针类型是指底层类型为`unsafe.Pointer`的类型。

1. 任何类型安全指针类型的值可以被显式转化为一个非类型安全指针类型，反之亦然。
2. 任何uintptr值可以被显式转化为一个非类型安全指针类型，反之亦然。

# 賦值

賦值可以看作是隐式類型轉換，賦值語句中的目標值必須爲一個可尋址的值，一個map元素或者`nil`, 賦值中，原值的直接部分被複製給了目標值。

注：函數傳參和結果返回均爲賦值

## 值比較

在任何比較中，第一個比較值必須能被賦值給第二個比較值的類型，或者反之

如果兩個值中有一個為接口值，而另一個為非接口值比你高且他的類型爲一個不可比較類型，則這兩個值不可比較，即使此非接口值可以被隐式转换为接口值的类型(即此不可比较类型实现了接口值的类型)

注：即使slice/map/function為不可比較類型，但是他們的值可以和`nil`進行比較

- 两个类型不确定的布尔值可以相互比较。
- 两个类型不确定的数字值可以相互比较。
- 两个类型不确定的字符串值可以相互比较。

兩個nil不能互相比較，任何比較的結果均爲一個類型不確定的bool

```go
// 一些类型为不可比较类型的变量。
var s []int
var m map[int]int
var f func()()
var t struct {x []int}
var a [5]map[int]int

func main() {
	// 这些比较编译不通过。
	/*
	_ = s == s
	_ = m == m
	_ = f == f
	_ = t == t
	_ = a == a
	_ = nil == nil
	_ = s == interface{}(nil)
	_ = m == interface{}(nil)
	_ = f == interface{}(nil)
	*/

	// 这些比较编译都没问题。
	_ = s == nil
	_ = m == nil
	_ = f == nil
	_ = 123 == interface{}(nil)
	_ = true == interface{}(nil)
	_ = "abc" == interface{}(nil)
}
```

## 值比較的細節

1. 如果`T`是一个布尔类型，则这两个值只有在它们同为`true`或者`false`的时候比较结果才为`true`。

2. 如果`T`是一个整数类型，则这两个值只有在它们在内存中的表示完全一致的情况下比较结果才为`true`。

3. 如果`T`

   是一个浮点数类型， 则这两个值只要满足下面任何一种情况，它们的比较结果就為`true`

   - 它们都为`+Inf`；
   - 它们都为`-Inf`；
   - 它们都为`-0.0`或者都为`+0.0`。
   - 它们都不是`NaN`并且它们在内存中的表示完全一致。

4. 如果`T`是一个复数类型，则这两个值只有在它们的实部和虚部均做为浮点数进行进行比较的结果都为`true`的情况下比较结果才为`true`。

5. 如果`T`是一个指针类型（类型安全或者非类型安全），则这两个值只有在它们所表示的地址值相等或者它们都为nil的情况下比较结果才为`true`。

6. 如果`T`是一个通道类型，则这两个值只有在它们引用着相同的底层内部通道或者它们都为nil时比较结果才为`true`。

7. 如果`T`是一個結構體類型，則他們相應的字段將逐對進行比較，只有一對元素不相等，兩個結構體值就不相等

8. 數組類型，對應的元素進行比較，并且長度也是比較的内容，只要有一項不符合，則`false`

注：動態類型均爲同一個不可比較類型的兩個接口值得比較將panic

```go
func main() {
	type T struct {
		a interface{}
		b int
	}
	var x interface{} = []int{}
	var y = T{a: x}
	var z = [3]T{{a: y}}

	// 这三个比较均会产生一个恐慌。
	_ = x == x
	_ = y == y
	_ = z == z
}
```



# 語法糖

## 嵌套函數調用

基本規則：

> 如果一个函数（包括方法）调用的返回值个数不为零，并且它的返回值列表可以用做另一个函数调用的实参列表，则此前者调用可以被内嵌在后者调用之中，但是此前者调用不可和其它的实参混合出现在后者调用的实参列表中。
>
> 語法糖：
>
> 如果一个函数调用刚好返回一个结果，则此函数调用总是可以被当作一个单值实参用在其它函数调用中，并且此函数调用可以和其它实参混合出现在其它函数调用的实参列表中。

```go
package main

import "fmt"

func main() {

	x:=3
	f1(x)
	
	fmt.Println(f2(f1(x)))
	
	s:="golang"
	f3(s)
	fmt.Println(f4(f3(s)))
}

func f1(x int)int{
	y:=x+2
	return y 
}

func f2(y int)int{
	return  y*2
}

func f3(z string)string{
	return z+"ok" 
}

func f4(k string)string{
	return k+"\tno\n"
}
```



### 容器和容器元素的可尋址性

> 基本規則：
>
> 如果個容器是可尋址的，則他的元素也是可尋址的，但是 映射除外，但是映射本身可以尋址
>

### 修改值

> 不可尋址的值不可修改
>
> 儘管映射不可尋址，但是他們可以修改

### 空組合字面量

如果一个类型`T`的值可以用组合字面量表示，则`T{}`表示此类型的零值。，對於map或者slice等類型  零值為nil。
