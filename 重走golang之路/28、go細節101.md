# 細節

**一個包可以在一個源文件中被引入多次**，前提是每次引入的名稱都不相同

### switch系列

在`switch`和`select`流程控制代碼塊中，**`default`分支可以放在所有的`case`分支之前或者所有的case分支之後**。

```go
switch n:=rand.Intn(3);n {
	case 1:
		fmt.Println("n==1")

	default:
		fmt.Println("n==2")

	case 0:
		fmt.Println("n==0")
	}
```

`switch`流程控制代碼塊中的數字常量**case表達式不能重複，但是布爾常量case表達式可以重複**

```go
 main() {
	switch 123 {
	case 123:
	case 123: // error: duplicate case
	}    // 編譯失敗
	
	
switch false{
	case false:
	   ...
	case false:
		...
}	// 編譯通過
```

**switch流程控制代碼塊裏的switch表達式總是被估值為類型確定值**

```go
switch 123 {
	case int64(123):  // error: 类型不匹配
	case uint32(789): // error: 类型不匹配
	}
//	此處的123被認定爲是一個int值，而不是一個類型不確定的值
```

switch中的**缺省默認值為類型確定值`true`**

```go
switch { // <=> switch true {
	case true:  fmt.Println("true")
	case false: fmt.Println("false")
	}
```

**嵌套延遲函數可以修改外層函數的返回結果**

```go
func F() (r int) {
	defer func() {
		r = 789
	}()

	return 123 // <=> r = 123; return
}=====> 實際返回789
```

`os.Exit`退出一個程序， `runtime.Goexit` 退出協程

## 指針

**指針類型的基類型可以為此指針類型自身**

- 切片類型的元素類型可以是此切片類型自身
- map類型的元素類型可以是此map類型自身
- channel元素類型可以是次channel自身
- function輸入參數和返回值類型可以是此function類型自身

## `range`

**用`range`遍历nil数组指针时，如果忽略或省略第二个迭代变量，则此遍历是没问题的。遍历中的循环步数为相应数组类型的长度。**

```go
var a *[5]int // nil
	for i, _ := range a {
		fmt.Print(i)
	}//  0----4
```



**不可寻址的数组的元素依旧是不可寻址的，但是不可寻址的切片的元素总是可寻址的。**

**可以从不可寻址的切片派生子切片，但是不能从不可寻址的数组派生子切片。**

**对于切片`s`，循环`for i = range s {...}`并不等价于循环`for i = 0; i < len(s); i++ {...}`。**

```go
var i int

func fa(s []int, n int) int {
	i = n
	for i = 0; i < len(s); i++ {}
	return i
}

func fb(s []int, n int) int {
	i = n
	for i = range s {}
	return i
}

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(fa(s, -1), fb(s, -1)) // 6 5
	s = nil
	fmt.Println(fa(s, -1), fb(s, -1)) // 0 -1
}
```

**結構體比較中，`__`的字段將會被忽略**

**`reflect.DeepEqual(x,y)`和`x==y`結果可能會不同**

```
如果x和y为（同类型的）两个引用着不同其它值的指针值，则x == y的估值结果总为false，但函数调用DeepEqual(x, y)的结果可能为true，因为函数reflect.DeepEqual将比较x和y所引用的两个值。


```

使用os.IsNotExist(err)而不是err == os.ErrNotExist来检查文件是否存在。

```go
_, err := os.Stat("a-nonexistent-file.abcxyz")
	fmt.Println(os.IsNotExist(err))    // true
	fmt.Println(err == os.ErrNotExist) // false

1.13+版本
	fmt.Println(errors.Is(err, os.ErrNotExist)) // true
```



**`[Sp|Fp|P]rintf`函数支持位置参数。**

```go
// The next line prints: coco
	fmt.Printf("%[2]v%[1]v%[2]v%[1]v", "o", "c")
```
