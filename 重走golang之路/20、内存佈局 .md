# 内存佈局

瞭解對象的内存佈局，有助於理解值傳遞、引用傳遞等概念

```makefile
+--------+
 | 1 | int
 +--------+
 +--------+
 | 3.14 | float32
 +--------+
 +---+---+---+---+
 | 1 | 2 | 3 | 4 | [4]int
 +---+---+---+---+

```

string

```makefile
+---------+---------+
 | pointer | len = 5 | s = "hello"
 +---------+---------+
 |
 |
 +---+---+---+---+---+
 | h | e | l | l | o | [5]byte
 +---+---+---+---+---+
 |
 +---------+---------+
 | pointer | len = 2 | sub = s[1:3]
 +---------+---------+
```

struct

```mariadb
+---+---+---+---+---+---+---+---+
 | 1 | 2 | 0 | 0 | 3 | 0 | 0 | 0 | struct { a byte; b byte; c int32 } = { 1, 2, 3 }
 +---+---+---+---+---+---+---+---+
 a b c
 +-----------+-----+
 | pointer a | b | struct { a *int; b int }
 +-----------+-----+
 |
 |
 +-----+
 | int |
 +-----+
```

slice

```
+---------+---------+---------+
 | pointer | len = 8 | cap = 8 | x = []int{0, 1, 2, 3, 4, 5, 6, 7 }
 +---------+---------+---------+
 |
 |
 +---+---+---+---+---+---+---+---+
 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | [8]int
 +---+---+---+---+---+---+---+---+
 |
 +---------+---------+---------+
 | pointer | len = 2 | cap = 5 | y = x[1:3:6]
 +---------+---------+---------+
```

interface

```
+---------+---------+
 | *itab | *data | struct Iface
 +---------+---------+
 | |
 +------+ +------+
 | Itab | | data |
 +------+ +------+
```

new

```
+---------+
 | pointer | s = new([3]int)
 +---------+
 |
 |
 +---+---+---+
 | 0 | 0 | 0 | [3]int
 +---+---+---+
```

make

```
+---------+---------+---------+
 | pointer | len = 1 | cap = 3 | slice = make([]int, 1, 3)
 +---------+---------+---------+
 |
 |
 +---+---+---+
 | 0 | 0 | 0 | [3]int
 +---+---+---+
 +---------+
 | pointer | map = make(map[string]int); 实际返回的是⼀个指针包装对象。
 +---------+
 |
 |
 ..................
 . .
 . hashmap.c Hmap .
 . .
 ..................
 +---------+
 | pointer | channel = make(chan int); 实际返回的是⼀个指针包装对象。
 +---------+
 |
 |
 ................
 . .
 . chan.c Hchan .
 . .
 ................
```

## 指針陷阱

對象内存分配會受編譯參數影響，当函数返回对象指针时，必然在堆上分配。 可如果该函数被内联，那么这个指针就不会跨栈帧使⽤，就有可能直接在栈上分配，以实 现代码优化⺫的。因此，是否阻⽌内联对指针输出结果有很⼤影响。 允許指針指向對象成員，并確保該對象是可達狀態。


