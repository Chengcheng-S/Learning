# 语法糖

### 重声明与重绑定

```go
f,err:=os.Open(name)
```



```go
d,err:=f.Stat()
```

> 看起来好像声明了d和err。但是请注意，这两个语句中都出现了错误。这种复制是合法的：err由第一个语句声明，但只在第二个语句中重新赋值。这意味着对f.Stat的调用使用上面声明的现有err变量，并且只给它一个新值。

在a:=声明中，即使变量v已经声明，也可能出现，前提是：

- 此声明与v的现有声明位于同一范围内（如果v已经在外部范围中声明，则声明将创建一个新变量)
- 初始化中的相应值可分配给v
- 至少还有一个由声明创建的其他变量

这里值得注意的是，in-Go函数参数和返回值的范围与函数体相同，尽管它们在词汇上出现在包围主体的大括号之外。

## 控制流

> Go的控制结构与C语言的控制结构有关，但在重要方面有所不同。没有do或while循环，只有一个稍微泛化的for；switch更灵活；if和switch接受一个可选的初始化语句，比如for；break和continue语句使用可选的标签来标识要中断或继续的内容；还有新的控制结构，包括一个类型开关和一个多路通信多路复用器，选择。语法也略有不同：没有括号，并且主体必须始终用大括号分隔。

### if 

```go
if x>0{
	return y
}
```

因为if和switch接受一个初始化语句，所以通常会看到一个用于设置局部变量的语句。

```go
if err:=file.Chmod(0664);err!=nil{
    log.Print(err)
    return err
}
```

> 当if语句没有流入下一个语句时，即主体以break、continue、goto或return结尾时，省略了不必要的else。

```go
f,err:=os.Open(name)
if err!=nil{
	return err
}
codeUsing(f)
```

> 在这种情况下，代码必须防范一系列错误条件。如果成功的控制流沿着页面向下运行，消除了出现的错误情况，代码读起来很好。由于错误情况往往以return语句结束，因此生成的代码不需要else语句。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### For

GO-for 与C类似但不同，它统一了for和while，没有do while。有三种形式，其中只有一种有分号。

 like a C for

```go
for init;condition;post{}    
```

like a C while

```go
for condition{}
```

like a C for(;;)

```go
for {}
```

简短的声明使得在循环中声明索引变量变得很容易。

```go
sum:=0
for i:=0;i<10;i++{
	sum+=i
}
```

若在数组、切片，字符串或map上循环，或者在channel中读取数据，可以使用range子句

```go
for key,value:=range Map{
    map[key]=value
}
```

若只需要第一项，

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

如果只需要在范围（值）中的第二项，则使用空白标识符（下划线）来丢弃第一个：

```go
sum := 0
for _, value := range array {
    sum += value
}
```

注：**Go没有逗号运算符**，和++ ，`--`,因此，如果要在for中运行多个变量，则应使用并行赋值（

```go
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch

Go的switch比C的更通用，表达式不需要是常量甚至整数，在找到匹配项之前，会自上而下地计算大小写，如果开关没有表达式，则会打开true。

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

，多个匹配使用`,`分隔

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

跳出某个标签，在循环上加上标签并`break`该标签来实现

```go
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]<<shift)
		}
	}
```

continue语句也接收可选的标签，但他只适用于循环

```go
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### type Switch

switch还可以用来发现接口变量的动态类型。这种类型switch使用类型断言的语法，在括号中包含关键字type。

如果switch在表达式中声明变量，则变量在每个子句中将具有相应的类型。

```go
var t interface{}
t=functionSomeType()
switch t:=t.(type){
default:
    fmt.Printf("unexpected type %T\n", t)    
case bool:
    fmt.Printf("boolean %t\n", t)             
case int:
    fmt.Printf("integer %d\n", t)             
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) 
case *int:
    fmt.Printf("pointer to integer %d\n", *t)     
}
```

## function

### multiple return values

Go的一个不寻常的特性是函数和方法可以返回多个值。

```go
func (file *File) Write(b []byte) (n int, err error)
```

### 返回值命名

> Go函数的返回或结果“参数”可以被命名并用作常规变量，就像传入的参数一样。在命名时，当函数开始时，它们被初始化为其类型的零值；如果函数执行没有参数的返回语句，则结果参数的当前值将用作返回值。
>
> 且这些命名不是强制性的

```go
func nextInt(b []byte, pos int) (value, nextPos int) 
```

由于命名结果是初始化的，并绑定到一个未加密的返回，因此它们可以简化和澄清。

```
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### defer

> Go的defer语句安排在执行defer的函数返回之前立即运行一个函数调用（deferred函数）。
>

```go
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

defer函数的参数(若为方法，则包括接收器)**在延迟执行时计算，而不是在调用执行时计算**。除了避免担心变量在函数执行时会改变值，这意味着一个延迟的调用站点可以延迟多个函数的执行。

defer执行顺序，则是**后进先出的顺序**，

## Data

### new

new 分配内存的内置函数，但是其不会初始化内存，只会将内存归于零，

**new(T)为T类型的值分配已经置零，并且返回其地址，*T的值**

> 返回指向新分配的类型为T的零值的指针。

由于new返回的内存是零的，所以在设计数据结构时，最好安排好每种类型的零值，而无需进一步初始化。值类型，数组，结构体

零值是有用的属性是可传递的。

#### 构造器 复合文字

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

> 注意，与C语言不同，返回局部变量的地址是完全可以的；与变量相关联的存储在函数返回后仍然存在。实际上，获取复合文本的地址在每次计算时都会**分配一个新的实例**，
>

作为一种限制情况，如果复合文本根本不包含任何字段，它将为该类型创建一个零值。表达式new（File）和&File{}是等价的。

还可以为数组、切片和map创建复合文本，字段标签是索引或映射键（视情况而定）。

### make

GO中的另一个分配原语，即为make

不同于new  其只创建slice，map，channel，返回类型为**T的初始化非零值**。

这三种类型实际上表示在使用之前必须初始化额数据结构的引用。

对于slice、channel、map，make初始化内部数据结构并准备好要使用的值。

```go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

注：

- make只适用于map，slice，channel，不返回指针。
- new 获取显式指针分配或显式获取变量的地址

### Arrays

数组在Go中的工作方式和在C中的工作方式大不相同

- 数组是值类型，**将一个数组分配给另一个数组将复制所有元素**。
- 如果将数组传递给函数，它将收到数组的副本，而不是指向它的指针。
- 数组的大小是其类型的一部分，类型[10]int和[20]int是不同的。

### slice

切片包装数组，为数据序列提供更通用、更强大、更方便的接口。除了具有显式维度的项（如转换矩阵）外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。

切片保存了对底层数组的引用，将一个切片分配给另一个切片，则两者都引用同一个数组。如果一个函数接受一个切片参数，它对切片元素所做的更改将对调用者可见，类似于将指针传递给底层数组。

> 切片的长度可以更改，只要它仍然适合底层数组的限制；只需将它分配给它本身的一个切片即可。一个切片的容量（可由内置函数cap访问）报告切片可能假定的最大长度。
>
> 如果数据超出容量，则重新分配片。

### 二维切片

Go的数组和切片是一维的，要创建二维数组或切片的等效对象，需要定义数组数组或切片切片

```go
type a [3][3]int   // 3x3 array
type a [][] byte   // a slice of byte slices
```

### Map

Map： 将一种类型（键）的值与另一种类型的值（元素或值）相关联。键可以是定义了相等运算符的任何类型，例如整数、浮点和复数、字符串、指针、接口（只要动态类型支持相等）、结构和数组。

切片不能用作map键，因为它们没有定义相等。与切片一样，map包含对底层数据结构的引用。如果将map传递给更改映射内容的函数，则更改将在调用方中可见。

> map可以使用通常的复合文本语法和冒号分隔的键值对来构造，因此在初始化期间很容易构建它们。

分配和获取映射值在语法上与对数组和切片执行相同的操作一样，只是索引不需要是整数。

```go
offset := timeZone["EST"]
```

尝试访问不存在的键，将得到对应的零值，

删除值

```‘go
delete(timeZone, "PDT")  // Now on Standard Time
```

### Printing

Go中的格式化打印使用类似于C的printf系列的样式，但是更丰富、更通用。这些函数位于fmt包中，名称大写：fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on

字符串函数（Sprintf等）返回字符串，而不是填充提供的缓冲区。

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

打印结构时，修改后的格式%+v将用结构的名称注释结构字段，对于任何值，可选格式%\v将以全Go语法打印该值。

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

```
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

> 当应用于string或[]byte类型的值时，也可以通过%q使用带引号的字符串格式。如果可能，替代格式%#q将使用反引号。
>
> %q格式也适用于整数和符文，产生一个单引号的符文常量。
>
> %x还处理字符串、字节数组和字节片以及整数，生成一个长的十六进制字符串，并且在格式为（%x）的情况下，它在字节之间放置空格
>
> %T 打印格式

如果要**控制自定义类型的默认格式**，只需在类型上定义一个带有signature String（）字符串的方法。

```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

如果需要打印类型为T的值以及指向T的指针，则**String的接收器必须是value类型**；此示例使用了指针，因为对于结构类型来说，指针更有效、更惯用。

String方法能够调用Sprintf，因为打印例程是完全可重入的，String方法能够调用Sprintf，因为打印例程是完全可重入的，

> 不要通过调用Sprintf来构造一个String方法，这种方法会无限期地重复出现在String方法中。如果Sprintf调用尝试将接收方直接打印为字符串，而字符串又将再次调用该方法，则可能会发生这种情况。

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
```

fix：将参数转换为基本字符串类型，而基本字符串类型没有方法。

```go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
```

`a..`参数可以是特定类型，例如…int表示选择整数列表中最小值的min函数：

```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```

### Append

```go
func append(slice []T, elements ...T) []T
```

其中T是任何给定类型的占位符，实际上Go中不支持泛型，不能在Go中编写类型t由调用方确定的函数。这就是append内置的原因：它需要编译器的支持。

append的作用是将元素追加到片段的末尾并返回结果。

```go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

将切片追加到切片，使用`..`

```go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

如果没有这个…，它就不能编译，因为类型是错误的；y不是int类型。

## Initialization

### 常量

Go中的常量在编译时创建，即使在函数中定义为局部变量，也只能是数字，字符，字符串或bool，由于编译时间限制，定义他们的表达式只能是常量表达式，编译器必须是可计算的表达式。

在Go中，使用iota枚举器创建枚举常量，由于iota可以是表达式的一部分，并且表达式可以隐式地重复，因此很容易构建复杂的值集。

```go
type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
```

### Variables

变量可以像常量一样初始化，但初始值设定项可以是在运行时计算的通用表达式

```go
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
```

### init function

每个源文件都可以定义自己的init函数，init在包中的所有变量声明都对其初始化器求值后被调用，并且只有在所有导入的包都已初始化之后才对其求值。

除了不能表示为声明的初始化之外，init函数的一个常见用法是在实际执行开始之前验证或修复程序状态的正确性。

## Method

### Pointers vs Values

可以为任何命名类型（指针或接口除外）定义方法；接收方不必是结构

关于指针与接收器值的规则是，**可以对指针和值调用值方法，但只能在指针上调用指针方法。**

> 出现此规则是因为**指针方法可以修改接收方**；对值调用它们会导致方法接收值的副本，因此任何修改都将被丢弃。因此，语言不允许这种错误。
>

## Interface and other types

### interfaces

Go中的接口提供了一种指定对象行为的方法：如果某个对象可以这样做，那么它就可以在这里使用。一个类型可以实现多个接口。

### 接口转换和类型断言

type switch 是转换的一种形式，接受一个接口，对于switch中的case，某种意义上将其转换为该实例类型的值

```go
type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```

第一种情况查找具体的值；第二种情况将接口转换为另一种接口。

类型断言接受接口值并从中提取指定显式类型的值。该语法借用了switch类型的子句，但使用显式类型而不是type关键字：

```go
value.(typeName)
```

结果是一个具有静态类型typeName的新值，该类型必须是**接口所持有的具体类型**，或者是值可以转换为第二个接口类型，提取值中已知的字符串：

```go
str:=value.(string)
```

但如果结果显示该值不包含字符串，则程序将崩溃并出现运行时错误。为了避免这种情况，可以使用`str,ok:=value.(string)`用法来安全地测试该值是否为字符串

```go
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

若类型断言失败，str依然存在，并且是string类型，但是其值为零，即空字符串

多重判断：

```go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```

### Generality

如果一个类型的存在只是为了实现一个接口，并且永远不会有超出该接口的导出方法，那么就不需要导出该类型本身。

此种情况下，构造函数应该返回接口值而不是实现类型。

### Interfaces and methods

因为几乎任何东西都可以附加方法，所以几乎任何东西都可以满足接口要求。

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

ResponseWriter本身是一个接口，它提供对将响应返回给客户端所需的方法的访问。

```go
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

## The blank identifier

空标识符可以被分配或声明为任何类型的值，而该值被无害地丢弃。

### 多重赋值中的空白标识符

在for-range循环中使用空标识符是一般情况下的一种特殊情况：多重赋值。

> 如果赋值要求在左边有多个值，但程序不会使用其中一个值，赋值左边的空白标识符就避免了创建伪变量的需要，并明确表示该值将被丢弃。例如，当调用返回值和错误的函数，但只有错误是重要的时，使用空白标识符丢弃无关的值。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

### 未使用的导入和变量

> 导入包或声明变量而不使用它是错误的。未使用的导入会使程序膨胀并使编译缓慢，而初始化但未使用的变量至少是一种浪费的计算，并且可能表明存在更大的错误。然而，当一个程序处于活动开发阶段时，经常会出现未使用的导入和变量，如果只是为了继续编译而删除它们，而只是为了以后再需要它们，这会很烦人。空标识符提供了一种解决方法。

简言之:Go中未使用已导入的包是错误的，但有时不需要使用该包，但是需要使用该包的init函数，因此使用空标识符是很有必要的

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
}
```

### Import for side effect

```go
import _ "net/http/pprof"
```

### interface checks

类型不需要显式声明其实现的接口，相反，类型只通过实现接口的方法来实现接口。

事实上大多数接口转换都是静态的，在编译期进行检查，

如果只需要询问一个类型是否实现接口，而不实际使用接口本身，可能作为错误检查的一部分，则使用空白标识符忽略类型断言值：

```go
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

> 如果一个类型，json.RawMessage-需要自定义JSON表示，它应该实现json.marshaller，但没有静态转换会导致编译器自动验证。如果类型无意中未能满足接口，JSON编码器仍将工作，但不会使用自定义实现。为了保证实现是正确的，可以使用包中使用空白标识符的全局声明
>
> ```go
> var _ json.Marshaler = (*RawMessage)(nil)
> ```

### Embedding

Go中没有子类的概念，但是可以通过结构或者接口中嵌入类型来实现

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Reader
    Writer
}
```

> 嵌入与子类化有一个重要的区别。当嵌入一个类型时，该类型的方法成为外部类型的方法，但是当调用它们时，方法的接收方是内部类型，而不是外部类型。

## Concurrency

### Share by communicating

Go并发不同于以往 共享值在通道上传递，事实上，从来没有被单独的执行线程主动共享。

在任何给定时间，只有一个goroutine可以访问该值。数据竞争在设计上是不可能发生的。

不要通过共享内存进行通信，而是通过通信共享内存。

### Goroutine

goroutine有一个简单的模型：**它是一个与同一地址空间中的其他goroutine同时执行的函数。**它是轻量级的，其成本仅比堆栈空间的分配多一点。而且堆栈开始时很小，所以很便宜，并且通过根据需要分配（和释放）堆存储来增长。

goroutine被多路复用到多个OS线程上，因此如果一个线程阻塞，比如在等待I/O时，其他线程继续运行。

在函数或方法调用前面加上go关键字，以便在新goroutine中运行调用。当调用完成时，goroutine将安静地退出。

在Go中，函数文本是闭包：实现确保函数引用的变量在它们处于活动状态时仍然存在。

### channels

类似于map，channel也是通过make分配的，结果值作为对底层数据结构的引用，如果提供了可选的整型参数，它将设置通道的缓冲区大小。对于无缓冲或同步通道，默认值为零。

无缓冲信道结合了通信-值的交换和同步，以保证两个goroutines处于已知状态。

> 在有数据要接收之前，接收器总是阻塞。如果信道是无缓冲的，发送方阻塞，直到接收方接收到该值。如果通道有一个缓冲区，发送方只阻塞直到值被复制到缓冲区；如果缓冲区已满，这意味着等待直到某个接收器检索到一个值。

### Channels of channels

Go的一个最重要的属性是通道是一个一流的值，可以像其他任何一个一样被分配和传递。此属性的常见用法是实现安全的并行解复用。

```go
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}

func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
```



```go
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

### Parallelization

如果计算可以分解成独立执行的独立部分，那么就可以**并行化**，每一部分完成时都有一个信号通道。

```go
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // signal that this piece is done
}
```

## Error

错误有类型error，一个简单的内置接口。

```go
type error interface {
    Error() string
}
```

在可行的情况下，错误字符串应该标识其来源，

### panic

内置函数panic，它实际上会**创建一个运行时错误**，从而停止程序，该函数接受任意类型的单个参数，通常是在程序结束时打印的字符串。这也是一种表示不可能发生的事情的方式，例如退出一个无限循环。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

### recover

调用panic时，包括对运行时错误的隐式处理，例如索引超出边界的切片或类型断言失败，它*将立即停止当前函数的执行，并开始展开goroutine的堆栈，同时运行任何延迟的函数。***如果展开到达goroutine堆栈的顶部，程序将终止。**但是，可以使用**内置函数recover重新获得对goroutine的控制并恢复正常执行。**

> 调用recover停止展开并返回传递给panic的参数。因为展开时运行的唯一代码是在延迟函数内部，所以recover只在延迟函数内部有用。
>
> recover的一个应用程序是关闭服务器中发生故障的goroutine，而不杀死其他正在执行的goroutine。

```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```