# go中的细节

## for range中的坑

1、for  range 惯用的是 短变量声明(`:=`)的形式，值得注意的是这些`for k,v:=range map`    k,v 每次在循环体中都会被重用，而不是重新声明

```go
 var m = [...]int{1, 2, 3, 4, 5}

    for i, v := range m {
        go func() {
            time.Sleep(time.Second * 3)
            fmt.Println(i, v)
        }()
    }

    time.Sleep(time.Second * 10)
   
```

输出的结果为： 

```go
4 5
4 5
4 5
4 5
4 5
```

每个goroutine中输出的i,v 都是range循环结束之后的最终值,而不是goroutine启动时的值，可行的方法是在每次迭代中向goroutine传入 i，v

```go
for i, v := range m {
        go func(i, v int) {
            time.Sleep(time.Second * 3)
            fmt.Println(i, v)
        }(i, v)
    }
```



2、range后面接受的表达式类型包括(array, &array,slice,map,string,channel)

```go
 var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int

    fmt.Println("a = ", a)

    for i, v := range a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }

    fmt.Println("r = ", r)
}
```

因为range中传递的是值得副本所以副本得更改不会影响原始值得更改，所以输出得结果为

```go
a =  [1 2 3 4 5]
r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
```



```go
var a = []int{1, 2, 3, 4, 5}
var r = make([]int, 0)

for i, v := range a {
        if i == 0 {
            a = append(a, 6, 7)
        }

        r = append(r, v)
    }

    fmt.Println("r = ", r) // [1,2,3,4,5]
    fmt.Println("a = ", a)//[1,2,3,4,5,6,7]
```

在这个例子中，原slice a在for range过程中被附加了两个元素6和7，其len由5增加到7，但这对于r却没有产生影响。这里的原因就在于a的副本a'的内部表示struct中的 len字段并没有改变，依旧是5，因此for range只会循环5次，也就只获取a对应的underlying数组的前5个元素。

3、对于map,string,channel  range 都是迭代副本，

string，内部为struct{*byte, len},每次迭代得单位都是`rune`而不是byte，index

map，对于map来说，内部表示为一个指针，指针副本也指向真实得map，也就是说range操作得是源map,

```go
	m := make(map[int]int,5)
	m[1]=1
	m[2]=2
	m[3]=3
	m[4]=4

	for k,v :=range m{
		if k==2{
			delete(m,4)
		}
		fmt.Println(v) // 不定序得1~4
	}
	fmt.Println(m) // 1，2，3
```

channel：channel内部表示为一个指针，指向得源channel

```go
func main() {
    var c = make(chan int)

    go func() {
        time.Sleep(time.Second * 3)
        c <- 1
        c <- 2
        c <- 3
        close(c)
    }()

    for v := range c {
        fmt.Println(v)
    }
}
```

1. 被遍历的容器值是的一个副本。 注意，只有被迭代的直接部分被复制了。此副本是一个匿名的值，所以它是不可被修改的。

   - 如果`aContainer`是一个数组，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素。
   - 如果`aContainer`是一个切片（或者映射），那么在遍历过程中对此切片（或者映射）元素的修改将体现到循环变量中。 原因是此切片（或者映射）的副本和此切片（或者映射）共享元素（或条目）。
2. 在遍历中的每个循环步，`aContainer`副本中的一个键值元素对将被赋值（复制）给循环变量。 所以对循环变量的直接部分的修改将不会体现在`aContainer`中的对应元素中。 （因为这个原因，并且`for-range`循环是遍历映射条目的唯一途径，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。）
3. 所有被遍历的键值对将被赋值给**同一对**循环变量实例。
