# 底层编译

Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出现错误的用法。编译时类型检查检查可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和chan等所有的内置类型，都有严格的类型转换规则。

对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）可以消除大部分野指针和内存泄漏相关的问题。

通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的

注意：unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，同时引起人们的注意。此外，有一些环境因为安全的因素可能限制这个包的使用。

unsafe包被广泛地用于比较低级的包, 例如runtime、os、syscall还有net包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。



## unsafe.Sizeof,Alignof和Offsetof

unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个Sizeof函数调用是一个对应uintptr类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。

```go
import "unsafe"
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
```

Sizeof函数返回的大小，包括数据结构中的固定部分，例如字符串对应的结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在`32位平台上是4个字节`，`在64位平台上是8个字节`。

计算机在加载和保存数据时，如果`内存地址`合理的`对齐`的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。

由于地址对齐这个元素，一个聚合类型(结构体、数组)的大小至少是所有字段或元素大小的总和，或者更大(有可能存在内存空洞，即编译器自动添加欸有被使用的内存空间用于保证每个字段或者元素的地址相对于结果后或者数组的开始地址能够合理的对齐）

批注：内存空洞可能存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响

| 类型                          | 大小                            |
| ----------------------------- | ------------------------------- |
| bool                          | 1个字节                         |
| intN, uintN, floatN, complexN | N/8个字节(例如float64是8个字节) |
| int, uint, uintptr            | 1个机器字                       |
| *T                            | 1个机器字                       |
| string                        | 2个机器字(data,len)             |
| []T                           | 3个机器字(data,len,cap)         |
| map                           | 1个机器字                       |
| func                          | 1个机器字                       |
| chan                          | 1个机器字                       |
| interface                     | 2个机器字(type,value)           |



`unsafe.Alignof`函数返回对应参数的类型需要对齐的倍数，和Sizeof类似Algnof也是返回一个常量表达式，对应一个常量，通常情况下布尔和数字类型需要对齐到他们本身的大小(至多8byte),其余类型对齐到机器字大小

`unsafe.Offsetof`函数的参数必须是一个字段`x.f`返回字段`f`相对于`x`的偏移量，包括存在的空洞

## unsafe.Pointer

不同于以往的指针类型,`unsafe.Pointer` 是特别定义的一种指针类型,可以包含任何类型变量的地址，自然也可以通过`*p`来获取unsafe.Pointer指针指向真实变量的值(解引用)。和普通指针一样，unsafe.Pointer指针也是**可以比较**的，并且支持和nil常量比较判断是否为空指针。

普通指针和unsafe.Pointer之间是可以互相转换的，而且被转回普通的指针类型并不需要和原始的`*T`类型相同。

```go
var  f float64=7.33333
fmt.Println(*(*int64)(unsafe.Pointer(&f)))
// 将float指针转为int64的指针
```

指针转换语法可以在不破坏类型系统的前提下向内存写入任意的值。

一个`unsafe.Pointer`指针也可以被转化为`uintptr`类型，然后保存到指针型数值变量中,可以作必要的`指针数值运算`(注意是指针数值，意味着uintptr为一个数字而非指针)这种转换是可逆的,但是uintptr转为unsafe.Pointer指针可能会破坏类型系统，并不是所有的数字是有效的内存地址

```go
pb:=(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&sa))+unsafe.Offsetof(sa.b)))
	*pb=75
	fmt.Println(sa.b)
```



```go
// NOTE: subtly incorrect!
tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
pb := (*int16)(unsafe.Pointer(tmp))
*pb = 42
```

引入了uintptr类型的临时变量，可能破坏程序的平衡性，以上的程序也会出现错误。原因如下：

```makefile
垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动是对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&x.b地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！
```

当调用一个库函数，并且返回的是uintptr类型地址时，返回的结果应该立即转换为unsafe.Pointer以确保指针指向的是相同的变量。

```go
package reflect

func (Value) Pointer() uintptr
func (Value) UnsafeAddr() uintptr
func (Value) InterfaceData() [2]uintptr // (index 1)
```

注： uintptr没有指针的语义，即uintptr会被gc回收，而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。

unsafe 包中的几个函数都是在**编译期**间执行完毕，

### 修改私有成员

对于一个结构体，通过**offset**函数可以获取其**成员的偏移量**。进而获取成员的地址，读写该内存的地址，就可以改变成员值。

*结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。*

```go
package main

import (
	"fmt"
	"unsafe"
)

/*
修改成员变量
 */

func main() {
	p:=Programmer{"jak","golang"}
	fmt.Println(p)

	name:=(*string)(unsafe.Pointer(&p))
	*name="tom"
	langoaue := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p))+unsafe.Sizeof(string(""))))
	*langoaue = "goust"
	fmt.Println(p)
}

type Programmer struct {
	name string
	language string
}

```

首先定义了一个结构体，赋予两个结构体字段，可以使用`unsafe.Pointer`改变字段得值，且go中的指针是不能运算的需要转为unsafe.uintptr 才可以

给其新增一个age int字段

在其他包中可以进行赋值，然后通过sizeof方法获取其偏移量，从而修改内存

```go
func main() {
    p := Programmer{"stefno", 18, "go"}
    fmt.Println(p)
    lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Sizeof(int(0)) + unsafe.Sizeof(string(""))))
    *lang = "Golang"
    fmt.Println(p)
}
```

lang的内存地址=结构体的内存地址+name的偏移量+age的偏移量

### 获取slice长度

slice的构成

```go
type silce struct{
	array unsafe.Pointer
    len  int
    cap  int
}
```

可以通过unsafe.Pointer和uintptr进行转换，获取slice的字段

```go
func main() {
    s := make([]int, 9, 20)
    var Len = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(8)))
    fmt.Println(Len, len(s)) // 9 9
    var Cap = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(16)))
    fmt.Println(Cap, cap(s)) // 20 20
}
```

转换流程如下：

```go
Len: &s => pointer => uintptr => pointer => *int => int
Cap: &s => pointer => uintptr => pointer => *int => int
```



### 获取map的长度

```go
type hmap struct {
    count     int
    flags     uint8
    B         uint8
    noverflow uint16
    hash0     uint32
    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer
    nevacuate  uintptr
    extra *mapextra
}
```

不用的slice  map返回的是指针

```go
func main() {
    mp := make(map[string]int)
    mp["qcrao"] = 100
    mp["stefno"] = 18
    count := **(**int)(unsafe.Pointer(&mp))
    fmt.Println(count, len(mp)) // 2 2
}
```

转换过程：

```go
&mp => pointer => **int => int
```

### 字符串和byte的零拷贝转换

```go
func string2bytes(s string) []byte {
    stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))
    bh := reflect.SliceHeader{
        Data: stringHeader.Data,
        Len:  stringHeader.Len,
        Cap:  stringHeader.Len,
    }
    return *(*[]byte)(unsafe.Pointer(&bh))
}
func bytes2string(b []byte) string{
    sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))
    sh := reflect.StringHeader{
        Data: sliceHeader.Data,
        Len:  sliceHeader.Len,
    }
    return *(*string)(unsafe.Pointer(&sh))
}
```



















