# 调度器

## go栈

**g0**栈用于**执行调度器**的代码，执行完成之后，要**跳转**到**用户代码**的地方。涉及到栈和寄存器切换，函数调用和返回主要依靠**CPU寄存器的切换**，goroutine也是如此。



## goroutine的退出

![runtime.main 启动流程](https://static.bookstack.cn/projects/qcrao-Go-Questions/e932d4f3dd079514ef956943600f5fac.png)

对于 main goroutine，在执行完用户定义的 main 函数的所有代码后，直接调用 exit(0) 退出整个进程，非常霸道。

对于普通 goroutine 则没这么“舒服”，需要经历一系列的过程。先是跳转到提前设置好的 goexit 函数的第二条指令，然后调用 runtime.goexit1，接着调用 `mcall(goexit0)`，而 mcall 函数会切换到 g0 栈，运行 goexit0 函数，清理 goroutine 的一些字段，并将其添加到 goroutine 缓存池里，然后进入 schedule 调度循环。到这里，普通 goroutine 才算完成使命。

## goroutine调度时机

| 情形            | 说明                                                         |
| :-------------- | :----------------------------------------------------------- |
| 使用关键字 `go` | go 创建一个新的 goroutine，Go scheduler 会考虑调度           |
| GC              | 由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存 |
| 系统调用        | 当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来 |
| 内存同步访问    | atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行 |

### 与线程的区别

- 内存占用： 创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。
- 创建和销毁：**Thread** 创建和销毀都会有**巨大的消耗**，因为要和**操作系统**打交道，是**内核级**的，通常解决的办法就是**线程池**。而 goroutine 因为是由 **Go runtime** 负责管理的，创建和销毁的**消耗非常小**，是**用户级**。
- 切换：当 threads 切换时，需要保存各种寄存器，以便将来恢复。 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。goroutines 切换成本比 threads 要小得多。

## GPM

GPM 是Go 调度器的三个核心组件

G是goroutine，保存goroutine的一些状态信息以及CPU的一些寄存器的值

- 当goroutine被调用CPU时，调度器负责把CPU寄存器的值保存在g对象的成员变量之中
- 当goroutine被调度器运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。

M：machine的首字母 表示一个工作线程/系统线程，G需要调度到M上才可以运行。 （结构体 m 就是我们常说的 M，它保存了 M 自身使用的栈信息、当前正在 M 上执行的 G 信息、与之绑定的 P 信息……）

当 M 没有工作可做的时候，在它休眠前，会“自旋”地来找工作：检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作。

P： 取 processor （处理器）的首字母，为 M 的执行提供“上下文”，保存 M 执行 G 时的一些资源。



一个 **M 只有绑定 P** 才能**执行 goroutine**，当 M 被**阻塞**时，整个 P 会被**传递给**其他 M ，或者说整个 P 被接管。

GMP 成就go scheduler， G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G。

*M 会从与它绑定的 P 的本地队列获取可运行的 G，也会从 network poller 里获取可运行的 G，还会从其他 P 偷 G。*



M的变化： M 只有**自旋**和**非自旋**两种状态。自旋的时候，会努力找工作；**找不到**的时候会进入**非自旋**状态，之后**会休眠**，直到有工作需要处理时，被其他工作线程唤醒，又进入**自旋状态**。

**![M 的状态流转图](https://static.bookstack.cn/projects/qcrao-Go-Questions/2718ac731f8fe5e12b24fd1656672955.png)**

#### M抢夺G的过程

共经历三个过程：先**从本地队列找**，定期会**从全局队列找**，最后实在没办法，就去**别的 P 偷**。

![M 找工作的过程](https://static.bookstack.cn/projects/qcrao-Go-Questions/09e757d021fb9886f63ae42adabb3a55.png)



先获取当前指向的 g，也就是 g0，然后拿到其绑定的 p，如果没有获取到，则尝试从全局队列获取。如果还没有获取到就会尝试去“偷”，

在偷之前，先看大的局势。如果其他所有的 P 都处于空闲状态，就说明其他 P 肯定没有工作可做，就没必要再去偷了，跳到 stop 部分。

在真正的“偷”工作之前，把自己的**自旋状**态设置为 **true，**全局自旋数量加 1。

### 调度循环启动

![从 g0 到 gp](https://static.bookstack.cn/projects/qcrao-Go-Questions/3bcf586a4c512dbdb8c5fd9ff9259390.png)

### GO shceduler

go程序由：**用户程序**和**运行时**组成。之间通过**函数调用**来实现内存管理、channel 通信、goroutines 创建等**功能**。*用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。*



Runtime 维护所有的 goroutines，并通过 scheduler 来进行调度。Goroutines 和 threads 是**独立的**，但是 goroutines 要**依赖 threads 才能执行**。

由 GMP 组成

- g  gorutione
- m  内核线程
- p  ：虚拟的 Processor，它维护一个处于 Runnable 状态的 g 队列

`m` 需要获得 `p` 才能运行 `g`。

当然还有一个核心的结构体：`sched`，它总览全局。

> Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。

go scheduler 核心：

- 重用线程
- 限制同时运行(不包含阻塞)的线程数为n,n等于CPU核心数目
- 线程私有的 runqueues，并且可以从其他线程 stealing goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程。



Go scheduler 是 **Go runtime 的一部分**，它**内嵌在 Go 程序里**，和 Go 程序一起运行。因此**它运行在用户空间**，在 kernel 的上一层。和 Os scheduler 抢占式调度（preemptive）不一样，Go scheduler 采用协作式调度。



goroutine状态：

| 状态      | 解释                                                         |
| :-------- | :----------------------------------------------------------- |
| Waiting   | 等待状态，goroutine 在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes |
| Runnable  | 就绪状态，只要给 M 就可以运行                                |
| Executing | 运行状态。goroutine 在 M 上执行指令，                        |



## M:N 模型

Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型

在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着



## workstealing

Go scheduler 的职责就是将所有处于 runnable 的 goroutines **均匀分布到在 P 上运行的 M**。

当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。这被称为 `Work-stealing`，Go 从 1.1 开始实现。

> Go scheduler 使用 M:N 模型，在任一时刻，M 个 goroutines（G） 要分配到 N 个内核线程（M），这些 M 跑在个数最多为 GOMAXPROCS 的逻辑处理器（P）上。每个 M 必须依附于一个 P，每个 P 在同一时刻只能运行一个 M。如果 P 上的 M 阻塞了，那它就需要其他的 M 来运行 P 的 LRQ 里的 goroutines。

