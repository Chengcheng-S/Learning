# GO101

## go中的關鍵字

用來聲明各種代碼的關鍵字：`const`,`func`，`import`,`type`,`var`,`package`

組合類型： `struct`,`interface`,`chan`,`map`

流程控制關鍵字`go`,`defer`

其他關鍵字:

`break`,`return`,`continue`,`default`,`case`,`switch`,`fallthrough`,`for`,`goto`,`if`,`range`,`select`,`else`

## 零值

類型零值即類型默認值

1. bool 零值表示真假中的假
2. 數值類型零值為0
3. 字符串類型的零值為空字符串

## 基本類型字面量表示形式

一個值的字面形式稱爲一個字面量，他表示此值在代碼中文子體現的形式(和内存中的表現形式相對應)，一個值可能會有多個字面量

### bool字面量

Go白皮书没有定义布尔类型值字面量形式。 我们可以将`false`和`true`这两个预声明的有名常量当作布尔类型的字面量形式。布尔类型的零值可以使用预声明的`false`来表示。

### 整數類型的字面量類型

整數類型值有四種字面量形式：十進制、八進制、十六進制、二進制

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B

15  //十進制表示，必須不能用0開頭
```

注： 二進制形式和以`0o,0O`開頭的八進制形式從(1.13版本開始支持)

### 浮點型的字面量

一个浮点数的完整字面量形式包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个整数指数部分。 

```go
1.23
01.23 // == 1.23
.23
1.
// 一个e或者E随后的数值是指数值（底数为10）。
// 指数值必须为一个可以带符号的十进制整数字面量。
1.23e2  // == 123.0
123E2   // == 12300.0
123.E+2 // == 12300.0
1e-1    // == 0.1
.1e0    // == 0.1
0010e-2 // == 0.1
0e+5    // == 0.0
```

### 虛部字面量

一个虚部值的字面量形式由一个浮点数字面量或者一个整数字面量和其后跟随的一个小写的字母`i`组成。 

```go
1.23i
1.i
.23i
123i
0123i   // == 123i（兼容性使然。见下）
1.23E2i // == 123i
1e-1i
011i   // == 11i（兼容性使然。见下）
00011i // == 11i（兼容性使然。见下）
// 下面这几行从Go 1.13开始才能编译通过。
0o11i    // == 9i
0x11i    // == 17i
0b11i    // == 3i
0X.8p-0i // == 0.5i
```

### 數值字面表示中使用下劃綫分段來增强可讀性

从Go 1.13开始，下划线`_`可以出现在整数、浮点数和虚部数字面量中，以用做分段符以增强可读性。 但是要注意，在一个数值字面表示中，一个下划线`_`不能出现在此字面表示的首尾，并且其两侧的字符必须为（相应进制的）数字字符或者进制表示头。

```go
// 合法的使用下划线的例子
6_9          // == 69
0_33_77_22   // == 0337722
0x_Bad_Face  // == 0xBadFace
0X_1F_FFP-16 // == 0X1FFFP-16
0b1011_0111 + 0xA_B.Fp2i

// 非法的使用下划线的例子
_69        // 下划线不能出现在首尾
69_        // 下划线不能出现在首尾
6__9       // 下划线不能相连
0_xBadFace // x不是一个合法的八进制数字
1_.5       // .不是一个合法的十进制数字
1._5       // .不是一个合法的十进制数字
```

### rune的字面量

`rune`类型是`int32`类型的别名。 因此，rune类型（泛指）是特殊的整数类型。rune之可以用整數類型的字面量表示。多種整形也可以用rune表示

```go
'a' // 一个英文字符
'π'
'众' // 一个中文字符



'\141'   // 141是97的八进制表示
'\x61'   // 61是97的十六进制表示
'\u0061'
'\U00000061'

```

注意：`\`之后必须跟随三个八进制数字字符（0-7）表示一个byte值， `\x`之后必须跟随两个十六进制数字字符（0-9，a-f和A-F）表示一个byte值， `\u`之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0）， `\U`之后必须跟随八个十六进制数字字符表示一个rune值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的Unicode码点值，否则编译将失败。

如果一个rune字面量中被单引号包起来的部分含有两个字符， 并且第一个字符是`\`，第二个字符不是`x`、 `u`和`U`，那么这两个字符将被转义为一个特殊字符。 目前支持的转义组合为：

```go
\a   (rune值：0x07) 铃声字符
\b   (rune值：0x08) 退格字符（backspace）
\f   (rune值：0x0C) 换页符（form feed）
\n   (rune值：0x0A) 换行符（line feed or newline）
\r   (rune值：0x0D) 回车符（carriage return）
\t   (rune值：0x09) 水平制表符（horizontal tab）
\v   (rune值：0x0b) 竖直制表符（vertical tab）
\\   (rune值：0x5c) 一个反斜杠（backslash）
\'   (rune值：0x27) 一个单引号（single quote）
```

rune类型的零值常用 `'\000'`、`'\x00'`或`'\u0000'`等来表示。



### 字符串字面量形式

Go字符串的字面量形式有两种。 一种是解释型字面表示（interpreted string literal，双引号风格）。 另一种是直白字面表示（raw string literal，反引号风格）

```go
// 解释形式
"Hello\nworld!\n\"你好世界\""

// 直白形式
`Hello
world!
"你好世界"`
```

解釋型風格中`\n`將被轉義為換行符,每个`\"`将被转义为一个双引号字符。 双引号风格的字符串字面量中支持的转义字符和rune字面量基本一致，除了一个例外：双引号风格的字符串字面量中支持`\"`转义，但不支持`\'`转义；而rune字面量则刚好相反

## 類型不確定

在Go中，有些值的类型是不确定的，有些值的类型有很多可能性。 这些值称为类型不确定值。对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的`nil``nil`是没有默认类型的

### 運算符

- 在很多其它流行语言中，位反运算符是用`~`表示的。
- 和一些其它流行语言一样，加号运算符`+`也可用做字符串衔接运算符（见下）。
- 和C及C++语言一样，`*`除了可以当作乘号运算符，它也可以用做指针解引用运算符； `&`除了可以当作位与运算符，它也可以用做取地址运算符。 后面的[指针](https://gfw.go101.org/article/pointer.html)一文将详解内存地址和指针类型。
- 和Java不一样，Go支持无符号数，所以Go不需要无符号右移运算符`>>>`。
- Go不支持幂运算符， 我们必须使用`math`标准库包中的`Pow`函数来进行幂运算。 
- 清位运算符`&^`是Go中特有的一个运算符。 `m &^ n`等价于`m & (^n)`。

### 更多關於`fmt.Printf`函數調用的輸出格式

`%v` 將被替換爲對應實參表示形式

`%T`替換爲實參的類型

`%x` 替換爲對應的十六進制

`%s`實參的字符串形式

`%%` 替換爲一個%

`+` 打印符号

## 表達式、語句、簡單語句

一個表達式表示一個值，一條語句表示一個操作，實際中，有些表達式可能同時表示多個值，有些語句可能由多個語句組成。某些場合下語句也可以被視爲表達式。

Go中，某些語句被稱爲簡單語句，GO中各種流程控制語句的某些部分可能會被要求必須為簡單語句或者表達式

### 表達式舉例

Go中大多數的表達式都是單值表達式，一個單值表達式只表示一個值，多值表達式則是表示多個值

若一個函數至少返回一個值，則他的調用屬於表達式，函數的返回值較多時，其調用成爲多值表達式。，沒有返回值的函數調用不屬於表達式

通道的接收數據操作(不包括賦值部分)也屬於表達式。

### 簡答語句

1. 變量短聲明語句
2. 純賦值語句，包含`x op=y`形式
3. 有返回結果的函數或方法調用，以及通道的接收數據操作(語句可以做表達式)
4. 通道的發送數據操作
5. 空語句
6. 自增，自減

### 非簡單語句

非簡單語句的不完整列表

1. 標準變量聲明語句
2. (有名)常量聲明語句
3. 類型聲明語句
4. (代碼)包引入語句
5. 顯示代碼塊（一個顯示代碼塊起始於`{`,終止于`}`，可以包含多個子語句）
6. 函數聲明
7. 跳轉語句流程控制
8. 函數返回(return)語句
9. 延遲函數和協程創建語句



### 例子

```go
// 一些非简单语句：
import "time"
var a = 123
const B = "Go"
type Choice bool
func f() int {
	for a < 10 {
		break
	}

	// 这是一个显式代码块。
	{
		// ...
	}
	return 567
}

// 一些简单语句的例子：
c := make(chan bool) // 通道将在以后讲解
a = 789
a += 5
a = f() // 这是一个纯赋值语句
a++
a--
c <- true // 一个通道发送操作
z := <-c  // 一个使用通道接收操作
          // 做为源值的变量短声明语句

// 一些表达式的例子：
123
true
B
B + " language"
a - 789
a > 0 // 一个类型不确定布尔值
f     // 一个类型为“func ()”的表达式

// 下面这些即可以被视为简单语句，也可以被视为表达式。
f() // 函数调用
<-c // 通道接收操作
```

## 協程

协程有时也被称为绿色线程。绿色线程是由程序的运行时（runtime）维护的线程。一个绿色线程的开销（比如内存消耗和情景转换）比一个系统线程常常小得多。 只要内存充足，一个程序可以轻松支持上万个并发协程。

GO不支持創建系統綫程，所以協程是一個Go程序内部唯一的并發實現方式。每个Go程序启动的时候只有一个对用户可见的协程，我们称之为主协程。 一个协程可以开启更多其它新的协程。

### 狀態

活動中的協程可以處於兩個狀態：運行狀體、阻塞狀態。一個協程可以在兩個狀態之間相互切換，比如使用`sywc.WaitGroup.Wait`,將從運行狀態切換到阻塞狀態。儅協程工作完成之後，主協程從阻塞狀態切換運行狀態

![协程状态](https://gfw.go101.org/article/res/goroutine-states.png)



一個處於睡眠中或者在等待系統調用返回的協程被認爲是出於運行狀態，而不是阻塞狀態。当一个新协程被创建的时候，它将自动进入运行状态，一个协程只能从运行状态而不能从阻塞状态退出。 如果因为某种原因而导致某个协程一直处于阻塞状态，则此协程将永远不会退出。

### 調度

并非所有处于运行状态的协程都在执行。在任一时刻，只能最多有和逻辑CPU数目一样多的协程在同时执行。通過`runtime.NumCPU`查詢當前程序可利用的邏輯CPU數目，每个逻辑CPU在同一时刻只能最多执行一个协程。Go运行时（runtime）必须让逻辑CPU频繁地在不同的处于运行状态的协程之间切换，从而每个处于运行状态的协程都有机会得到执行。 这和操作系统执行系统线程的原理是一样的。

![](https://gfw.go101.org/article/res/goroutine-schedule.png)



在此图中，运行状态被细分成了多个子状态。 一个处于排队子状态的协程等待着进入执行子状态。一个处于执行子状态的协程在被执行一会儿（非常短的时间片）之后将进入排队子状态。

Go編譯器采用了`M P G`模型算法來實現協程的調度，M 表示系統綫程  G 表示協程   P表示邏輯處理器

> 多数的调度工作是通过逻辑处理器（**P**）来完成的。 逻辑处理器像一个监工一样通过将不同的处于运行状态协程（**G**）交给不同的系统线程（**M**）来执行。 一个协程在同一时刻只能在一个系统线程中执行。一个执行中的协程运行片刻后将自发地脱离让出一个系统线程，从而使得其它处于等待子状态的协程得到执行机会。
>
> ​                                                                                             ----《GO 白皮書》

### 延遲函數調用

`defer`+函數名====> 延遲函數調用，類似於協程，被延遲的函數調用的所有返回值必須全部被捨棄

当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出階段后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。



## 組合類型

指針類型： 類C指針

結構體類型：類C結構體

函數類型-： 在Go中是一種一等公民類別

容器類型： 數組類型：長度固定；  切片類型： 動態長度和容量； 映射類型： 字典類型，標準編譯器中映射時使用哈希表實現的

通道類型： 同步并發的協程

接口類型： 在多態 反射中發揮重要角色



在Go中，

- 底层类型为内置类型`bool`的类型称为**布尔类型**；
- 底层类型为任一内置整数类型的类型称为**整数类型**；
- 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；
- 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；
- 整数类型、浮点数类型和复数类型统称为**数字值类型**；
- 底层类型为内置类型`string`的类型称为**字符串类型**。



### 接口類型的動態值和動態類型

接口类型类型的值称为接口值。一个接口值可以包裹装载一个非接口值。包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型实现了此接口类型。

### 一個值得具體類型和具體值 

對於一個(類型確定的)非接口值,它的具體類型就是它的類型，它的具體值就是它自己。一个零值接口值没有具体类型和具体值。 对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。

### 不可比較類型

切片類型、映射類型、函數類型、任何包含有不可比較類型字段的結構體類型和任何元素類型為不可比較類型的數組類型。  均不支持(==,!=)比較

## GO中指針的限制

### GO指針不支持算術運算

指针是不能参与算术运算的。比如，对于一个指针`p`， 运算`p++`和`p-2`都是非法的。

如果`p`为一个指向一个数值类型值的指针，`*p++`将被编译器认为是合法的并且等价于`(*p)++`。 换句话说，取地址操作符`&`和解引用操作符`*`的优先级都高于自增`++`和自减`--`操作符。

### 一個指針類型不能被隨意轉爲另一個指針類型

### 一個指針不能和其他任意指針類型的值進行比較

GO指針支持(==  !=)，

1.  兩個指針是相同類型
2. 其中一個并且只有一個指針用類型不確定的`nil`表示
3. 一個指針可以被隱式轉爲另一個指針的類型，兩個指針類型的底層類型必須一直并且其中一個指針類型為非定義的(結構體字段的標簽)

### 一個指針不能賦值非其他任意類型的指針值



## GO中的類型的類別

|           每个值在内存中只分布在一个内存块上的类型           |           每个值在内存中会分布在多个内存块上的类型           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![值部](https://gfw.go101.org/article/res/value-parts-single.png) | ![值部](https://gfw.go101.org/article/res/value-parts-multiple.png) |
| 布尔类型 各种数值类型 指针类型 非类型安全指针类型 结构体类型 数组类型 |   切片类型 映射类型 通道类型 函数类型 接口类型 字符串类型    |



## 關於字符串一些簡單的事實

1. 字符串值(bool 以及各種數值類型的值)可以被用作常量
2. GO支持兩種風格的字符串字面量表示形式：反引號(直白字面表示)，  雙引號風格(解釋型字面表示)
3. 字符串類型的零值為空字符串，一個空字符串字面上可以表示爲`"" 和`` `
4. 可以用運算符`+`,`+=`銜接字符串
5. 字符串類型是可比較類型，同一個字符串可以用`==`和`!=`比較，并且和整数/浮点数一样，同一个字符串类型的值也可以用`>`、`<`、`>=`和`<=`比较运算符来比较。 当比较两个字符串值的时候，它们的底层字节将逐一进行比较。如果一个字符串是另一个字符串的前缀，并且另一个字符串较长，则另一个字符串为两者中的较大者。

### 語法糖： 將字符串當作字節切片使用

内置函数`copy`和`append`可以用来复制和添加切片元素，两个函数的调用中的第一个实参为一个字节切片的话，那么第二个实参可以是一个字符串。 （对于`append`函数调用，字符串实参后必须跟随三个点`...`。） 换句话说，在此特例中，字符串可以当作字节切片来使用。

```go
	hello := []byte("Hello ")
	world := "world!"

	// helloWorld := append(hello, []byte(world)...) // 正常的语法
	helloWorld := append(hello, world...)            // 语法糖
	fmt.Println(string(helloWorld))

	helloWorld2 := make([]byte, len(hello) + len(world))
	copy(helloWorld2, hello)
	// copy(helloWorld2[len(hello):], []byte(world)) // 正常的语法
	copy(helloWorld2[len(hello):], world)            // 语法糖
	fmt.Println(string(helloWorld2))
```



## 函數

## 函數簽名和函數類型

一个函数类型的字面表示形式由一个`func`关键字和一个函数签名字面表示表示形式组成。 ，一個函數簽名由一個輸入參數類型列表和一個輸出結果類型列表組成，函數名和結果名可以出現在函數簽名的字面表示形式中

func 關鍵字可以出現在函數簽名的字面形式中

函數類型字面量 舉例

```go
func (int, string, string) (int, int, bool) // 标准函数字面形式
func (a int, b string, c string) (int, int, bool)
func (x int, _ string, z string) (int, int, bool)
func (int, string, string) (x int, y int, z bool)
func (int, string, string) (a int, b int, _ bool)
```

参数列表必须用一对小括号`()`括起来，即使此列表为空。 如果一个函数类型一个结果列表为空，则它可以在函数类型的字面形式中被省略掉。 当一个结果列表含有最多一个结果，则此结果列表的字面形式在它不包含结果名称的时候可以不用括号`()`括起来。

### 函數原型

由函數名和一個函數類型(或者一個函數簽名組成)，其字面形式由一個`func`關鍵字、一個函數名和一個函數簽名字面形式組成

```go
func Double(n int) (result int)
```

一个函数原型可以看作是一个不带函数体的函数声明； 或者说一个函数声明由一个函数原型和一个函数体组成



### 所有函數的調用傳參均屬於值複製

赋值一样，传参也属于值（浅）复制。当一个值被复制时，只有它的直接部分被复制了。



### 有返回值的函數的調用是一種表達式

一个有且只有一个返回值的函数的每个调用总可以被当成一个单值表达式使用。 比如，它可以被内嵌在其它函数调用中当作实参使用，或者可以被当作其它表达式中的操作数使用。

如果一个有多个返回结果的函数的一个调用的返回结果没有被舍弃，则此调用可以当作一个多值表达式使用在两种场合：

1. 此调用可以在一个赋值语句中当作源值来使用，但是它不能和其它源值掺和到一块。
2. 此调用可以内嵌在另一个函数调用中当作实参来使用，但是它不能和其它实参掺和到一块。

# 通道

`不要讓計算通過共享内存來通信，而是通過通信共享内存`

Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为通道。(FIFO)，一些協程可以向此通道發送數據，另外一些協程可以從此通道接收數據

## Channel

所有的通道類型均爲課比較類型，这两个通道引用着同一个底层的内部通道对象。 比较这两个通道的结果为`true`。

## 通道的操作

### 關閉通道

```go
close(ch)
```

### 發送數據

```go
ch<-x           // <-  數據發送符
```

### 接收數據

```go
<-ch
```

### 通道容量

```go
cap(ch)
```

### 通道長度

```go
len(ch)
```

注：通道賦值和其他類型賦值一樣，是**未同步**的，同理，將通道中發送出來的數據賦值給另一個值也是**未同步的。**

## channe 操作詳解



|   操作   | 一个零值nil通道 | 一个非零值但已关闭的通道 | 一个非零值且尚未关闭的通道 |
| :------: | :-------------: | :----------------------: | :------------------------: |
|   关闭   |     panic`      |          panic           |          成功关闭          |
| 发送数据 |    永久阻塞     |          panic           |      阻塞或者成功发送      |
| 接收数据 |    永久阻塞     |         永不阻塞         |      阻塞或者成功接收      |

1. 關閉一個nil通道或者一個已經關閉的通道將``panic`
2. 向一個已經關閉的通道發送數據也會導致`panic`
3. 向一個nil通道發送數據或者從一個nil通道接收數據將使當前協程永久阻塞

### 通道的元素值傳的傳遞都是複製過程

在一个值被从一个协程传递到另一个协程的过程中，此值将被复制至少一次。 如果此传递值曾经在某个通道的缓冲队列中停留过，则它在此传递过程中将被复制两次。 一次复制发生在从发送协程向缓冲队列推入此值的时候，另一个复制发生在接收协程从缓冲队列取出此值的时候。 和赋值以及函数调用传参一样，当一个值被传递时，只有它的直接部分被复制

### 關於通道和協程的垃圾回收

一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。 另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。 事实上，一个协程只有在退出后才能被垃圾回收。

### 數據接收和發送操作都屬於簡單的語句

数据接收和发送操作都属于簡單語句。 另外一个数据接收操作总是可以被用做一个单值表达式。 简单语句和表达式可以被用在一些流程控制的某些部分。

### 通道遍歷

`for range`也適用於通道， 此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列中为空为止。 和应用于数组/切片/映射的`for-range`语法不同，应用于通道的`for-range`语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。

# 方法

## 聲明

可以爲類型`T`和`*T`顯示聲明一個方法，但必須滿足四個條件

1. T  必須是以一個定義類型
2. T 必須和此方法聲明定義在同一個代碼包中
3. T  不能是一個指針類型
4. T  不能是一個接口類型

类型`T`和`*T`称为它们各自的方法的属主类型， 类型`T`被称作为类型`T`和`*T`声明的所有方法的属主基类型。

在很多其它面向对象的编程语言中，属主参数名总是为隐式声明的`this`或者`self`。这样的名称不推荐在Go编程中使用。

指针类型的属主参数称为*指针类型属主*，非指针类型的属主参数称为*值类型属主*。

方法名可以是空標識符，一個類型可以擁有無數個空標識符的方法，只不過這額方法不能調用罷了。

### 屬主函數傳參是值傳遞

和普通参数传参一样，属主参数的传参也是一个值复制过程。 所以，在方法体内对属主参数的直接部分的修改將不會反映到方法躰之外



# 接口

## 接口類型

一個接口類型指定了一個方法原型的集合，換言之 一個接口類型定義了一個方法集，在Go中接口值可以用來包括非接口值，然後通過值包裹，反射和多態得以實現

```go
interface{}    // 一個非定義空接口類型

type X interface{}  // 一個定義的空接口類型
```

## 方法集



- 對於一個非接口類型，他的方法集由它聲明的方法原型組成
- 對於一個接口類型，它的方法集就是他所指定的方法集

注意：因为任何方法集都是一个空方法集的超集，所以**任何类型都实现了任何空接口类型**。 这是Go中的一个重要事实。

## 值包裹

任何一個接口值，都可以看作是一個用來包裹一個非接口值得盒子，欲將一個非接口值包裹在一個接口值中，此非接口值必須實現了此接口值得類型

當一個非接口值被包裹在一個接口值中，此非接口值稱爲此接口值得`動態值`，才非接口值稱爲`動態類型`

接口值的动态值的直接部分是不可修改的，除非它的动态值被整体替换为另一个动态值。

接口值得動態值得直接部分是不可修改的，除非他的動態值被整體替換為了另一個動態值。接口類型的零值也是預聲明的``nil``標識符來表示。一個nil接口的值中什麽也沒有包裹，將一個接口值修改爲nil 將清空包裹在此接口值中的非接口的值

注： 在Go中，很多其他非接口類型的零值也是用`nil`標識符來表示。 非接口類型的nil零值也可以被包裹在接口值中。一個包裹了一個nil非接口值，不是一個nil接口值，因爲它并沒有包裹什麽

当一个类型不确定值（除了类型不确定的`nil`）被转换为一个空接口类型（或者赋给一个空接口值），此类型不确定值将首先转换为它的默认类型。 （或者说，此类型不确定值将被推断为一个它的默认类型的类型确定值。）

## ``type-switch`

`type-switch`流程控制的语法或许是Go中最古怪的语法。 它可以被看作是类型断言的增强版。它和`switch-case`流程控制代码块有些相似。 一个`type-switch`流程控制代码块的语法如下所示：

```go
switch aSimpleStatement; v := x.(type) {
case TypeA:
	...
case TypeB, TypeC:
	...
case nil:
	...
default:
	...
}
```

## 接口值相關的比較



接口值相关的比较有两种情形：

1. 比较一个非接口值和接口值；
2. 比较两个接口值。

对于第一种情形，非接口值的类型必须实现了接口值的类型（假设此接口类型为`I`），所以此非接口值可以被隐式转化为（包裹到）一个`I`值中。 这意味着非接口值和接口值的比较可以转化为两个接口值的比较。所以下面我们只探讨两个接口值比较的情形。

比较两个接口值其实是比较这两个接口值的动态类型和和动态值。

下面是（使用`==`比较运算符）比较两个接口值的步骤：

1. 如果其中一个接口值是一个nil接口值，则比较结果为另一个接口值是否也为一个nil接口值。
2. 如果这两个接口值的动态类型不一样，则比较结果为`false`。
3. 对于这两个接口值的动态类型一样的情形，
   - 如果它们的动态类型为一个不可比较类型，则将产生一个恐慌。
   - 否则，比较结果为它们的动态值的比较结果。

简而言之，两个接口值的比较结果只有在下面两种任一情况下才为`true`：

1. 这两个接口值都为nil接口值。
2. 这两个接口值的动态类型相同、动态类型为可比较类型、并且动态值相等。

```go
package main

import "fmt"

func main() {
	var a, b, c interface{} = "abc", 123, "a"+"b"+"c"
	fmt.Println(a == b) // 第二步的情形。输出"false"。
	fmt.Println(a == c) // 第三步的情形。输出"true"。

	var x *int = nil
	var y *bool = nil
	var ix, iy interface{} = x, y
	var i interface{} = nil
	fmt.Println(ix == iy) // 第二步的情形。输出"false"。
	fmt.Println(ix == i)  // 第一步的情形。输出"false"。
	fmt.Println(iy == i)  // 第一步的情形。输出"false"。

	var s []int = nil // []int为一个不可比较类型。
	i = s
	fmt.Println(i == nil) // 第一步的情形。输出"false"。
	fmt.Println(i == i)   // 第三步的情形。将产生一个恐慌。
}
```

两个包裹了不同非接口类型的`nil`零值的接口值是不相等的。

# Unsafe

`unsafe.Pointer`類似於Clang中的``void*`,底層為`unsafe.Pointer`,零值被預聲明為`nil`

`func Alignof(variable ArbitraryType) uintptr`。 此函数用来取得一个值在内存中的地址对齐保证,注意，同一个类型的值做为结构体字段和非结构体字段时地址对齐保证可能是不同的。 当然，这和具体编译器的实现有关。对于目前的标准编译器，同一个类型的值做为结构体字段和非结构体字段时的地址对齐保证总是相同的。 gccgo编译器对这两种情形是区别对待的。

`func Offsetof(selector ArbitraryType) uintptr`。 此函数用来取得一个结构体值的某个字段的地址相对于此结构体值的地址的偏移。 在一个程序中，对于同一个结构体类型的不同值的对应相同字段，此函数的返回值总是相同的。

`func Sizeof(variable ArbitraryType) uintptr`。 此函数用来取得一个值的尺寸（亦即此值的类型的尺寸）。 在一个程序中，对于同一个类型的不同值，此函数的返回值总是相同的。

注：

- 这三个函数的返回值的类型均为内置类型`uintptr`。
- 尽管这三个函数之一的任何调用的返回结果在同一个编译好的程序中总是一致的，但是这样的一个调用在不同架构的操作系统中（或者使用不同的编译器编译时）的返回值可能是不一样的。
- 这三个函数的调用总是在编译时刻被估值，估值结果为类型为`uintptr`的常量。
- 传递给`Offsetof`函数的实参必须为一个字段选择器形式`value.field`。 此选择器可以表示一个内嵌字段，但此选择器的路径中不能包含指`针类型的隱式字段`

```go

func main() {
	type T struct {
		c string
	}
	type S struct {
		b bool
	}
	var x struct {
		a int64
		*S
		T
	}

	fmt.Println(unsafe.Offsetof(x.a)) // 0
	
	fmt.Println(unsafe.Offsetof(x.S)) // 8
	fmt.Println(unsafe.Offsetof(x.T)) // 16
	
	// 此行可以编译过，因为选择器x.c中的隐含字段T为非指针。
	fmt.Println(unsafe.Offsetof(x.c)) // 16
	
	// 此行编译不过，因为选择器x.b中的隐含字段S为指针。
	//fmt.Println(unsafe.Offsetof(x.b)) // error
	
	// 此行可以编译过，但是它将打印出字段b在x.S中的偏移量.
	fmt.Println(unsafe.Offsetof(x.S.b)) // 0
}
```

## 非安全指針相關的類型轉換

- 一個類型安全指針可以被顯式的轉換爲一個非類型安全指針，反之亦然
- 一個uniptr值可以被顯示轉換爲一個非類型安全指針類型，反之亦然，注：一個nil非類型安全指針類型不應該轉爲ninptr并運行算術運算符后再賺回來

## 冷知識

### 一、非類型安全指針值是指針但是uinptr值是整數

每一个非零安全或者不安全指针值均引用着另一个值。但是一个uintptr值并不引用任何值，它被看作是一个整数，尽管常常它存储的是一个地址的数字表示。(uinptr可以參與算術運算)

```go
func createInt() *int {
	return new(int)
}

func foo() {
	p0, y, z := createInt(), createInt(), createInt()
	var p1 = unsafe.Pointer(y) // 和y一样引用着同一个值
	var p2 = uintptr(unsafe.Pointer(z))

	// 此时，即使z指针值所引用的int值的地址仍旧存储
	// 在p2值中，但是此int值已经不再被使用了，所以垃圾
	// 回收器认为可以回收它所占据的内存块了。另一方面，
	// p0和p1各自所引用的int值仍旧将在下面被使用。

	// uintptr值可以参与算术运算。
	p2 += 2; p2--; p2--

	*p0 = 1                         // okay
	*(*int)(p1) = 2                 // okay
	*(*int)(unsafe.Pointer(p2)) = 3 // 危险操作！
}
```



### 二、不再被使用的内存塊的回收時間不確定

GO的GC： GO運行時隨時檢查那些内存塊將不再被程序中的任何仍在使用中的值所引用并且回收這些内存塊。  GC 啓動時間不確定，并且此過程可能需要一段不確定的時期

### 三、一個值的地址在程序運行中可能被改變

### 四、一個值的生命範圍可能并沒有顯式的那麽大

### 五、`*unsafe.Pointer`是一個類型安全指針

类型`*unsafe.Pointer`是一个类型安全指针类型。 它的基类型为`unsafe.Pointer`。 既然它是一个类型安全指针类型，根据上面列出的类型转换规则，它的值可以转换为类型`unsafe.Pointer`，反之亦然。

```go
package main

import "unsafe"

func main() {
	x := 123                // 类型为int
	p := unsafe.Pointer(&x) // 类型为unsafe.Pointer
	pp := &p                // 类型为*unsafe.Pointer
	p = unsafe.Pointer(pp)
	pp = (*unsafe.Pointer)(p)
}
```

## 非類型安全指針使用模式

### 一、將類型`*T1`的一個值轉爲非類型安全指針，然後將此非類型安全指針轉爲類型`*T2`

其中`T1`和`T2`为两个任意类型。 然而，只有在`T1`的尺寸不小于`T2`并且此转换具有实际意义的时候才应该实施这样的转换。

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	type MyString string
	ms := []MyString{"C", "C++", "Go"}
	fmt.Printf("%s\n", ms)  // [C C++ Go]
	// ss := ([]string)(ms) // 编译错误
	ss := *(*[]string)(unsafe.Pointer(&ms))
	ss[1] = "Rust"
	fmt.Printf("%s\n", ms) // [C Rust Go]
	// ms = []MyString(ss) // 编译错误
	ms = *(*[]MyString)(unsafe.Pointer(&ss))
}
```

### 二、將一個非類型安全指針值轉爲一個uintptr值，然後使用此uintptr

### 三、將一個非類型安全指針轉爲一個uintptr值，然後此uintotr值參與各種運算，再將算數運算的結果uintptr值轉會非類型安全指針

```go
type T struct {
	x bool
	y [3]int16
}

const N = unsafe.Offsetof(T{}.y)
const M = unsafe.Sizeof(T{}.y[0])

func main() {
	t := T{y: [3]int16{123, 456, 789}}
	p := unsafe.Pointer(&t)
	// "uintptr(p) + N + M + M"为t.y[2]的内存地址。
	ty2 := (*int16)(unsafe.Pointer(uintptr(p)+N+M+M))
	fmt.Println(*ty2) // 789
}
```

### 四、將非類型安全指針值轉爲uintptr值並傳遞給`syscall,Syscall`函數調用

### 五、将`reflect.Value.Pointer`或者`reflect.Value.UnsafeAddr`方法的`uintptr`返回值立即转换为非类型安全指针。

### 六、将一个`reflect.SliceHeader`或者`reflect.StringHeader`值的`Data`字段转换为非类型安全指针，以及其逆转换。



# Defer

## 補充

### 很多有返回值的内置函數是不能被延遲調用的

append 可以被延遲調用

### 延遲調用的函數值得估值時刻

```go
func main() {
	var f = func() {
		fmt.Println(false)
	}
	defer  f()
	f= func() {
		fmt.Println(true)
	}
}

```

以上程序輸出結果為`false`，***一個被延遲調用的函數值是在其調用被推入延遲調用堆棧之前被估值的***

```go
func main() {
	defer fmt.Println("此行可以被执行到")
	var f func() // f == nil
	defer f()    // 将产生一个恐慌
	fmt.Println("此行可以被执行到")
	f = func() {} // 此行不会阻止恐慌产生
}
```

一個被延遲調用的函數值可能是一個`nil`這種情況下會造成panic，對於這種情形，panic產生在此延遲調用被執行而不是被推入延遲調用棧的時候

### 延遲方法調用的屬主參數的估值時刻

延遲調用的實參也是在此調用被推入延遲調用堆棧之前估值的，方法的屬主實參也不例外

```go
func main() {
	var t T
	defer t.M(1).M(2)
	t.M(3).M(4)
}
type T int
func (t T)M(n int)T{
	print(n)
	return t
}
```

t.M(1)是t.M(2)的屬主實參，因此它將在M(2)調用之前被推入延遲調用堆棧之前被估值，程序輸出結果為`1342`

### 延遲調用使得代碼更簡潔

### 延遲調用可能會導致性能損失

延迟调用并非没有缺点。对于早于1.13版本的官方标准编译器来说，延迟调用将导致一些性能损失。 从Go官方工具链1.13版本开始，官方标准编译器被一些常见的延迟调用场景做了很大的优化。 

### 延遲調用導致的暫時性内存泄漏

一个较大的延迟调用堆栈可能会消耗很多内存，而且延迟调用堆栈中尚未执行的延迟调用可能会导致某些资源未被及时释放。

# 代碼塊和標識符作用域

## 代碼塊

- 萬物代碼塊，一個程序只有一個萬物代碼塊，他包含著一個程序中的所有代碼
- 包代碼塊， 一個包代碼塊包含著一個代碼包中的所有代碼，但不包括此代碼包中的源代碼文件中的所有引入聲明
- 文件代碼塊， 一個文件代碼塊包含著一個源文件中的所有代碼，包括文件中包的引入聲明
- 局部代碼塊，一般來説`{}`中的代碼形成了一個局部代碼塊，但是也有一些局部代码块并不包含在一对大括号中，这样的代码块称为隐式代码块，而包含在一对大括号中的局部代码块称为显式代码块。 组合字面量中的大括号和代码块无关。

不内嵌在任何其他局部代碼塊中的局部代碼塊成爲頂層(包級)局部代碼塊，頂層局部代碼塊肯定都是函數體。

注： 一個函數聲明中的輸入參數和輸出結果變量都被看作是聲明在此函數躰代碼塊内，雖然它看上去像是聲明在函數體代碼塊之外。

### 各種代碼塊的層級關係

- 所有的包代碼快軍直接内嵌在萬物代碼塊中
- 所有的文件代碼塊也 直接内嵌在萬毒代碼塊中(go白皮書認爲文件代碼快内嵌在包代碼塊中)
- 每個頂層局部代碼塊同時直接内嵌在一個包代碼塊和一個文件代碼塊中(go白皮書認爲頂層代碼快内嵌在包代碼塊中)
- 一個非頂層局部代碼塊肯定直接内嵌在另一個局部代碼塊中

代碼層級關係圖

![代码块层级关系](https://gfw.go101.org/article/res/blocks.png)

### 各種代碼元素的可聲明位置

- 包引入
- 定義類型和類型辨別名
- 有名變量
- 變量
- 函數
- 跳轉標簽

在一個代碼元素的聲明中，一個標識符和一個代碼元素綁定到一起，在此聲明中，被聲明的代碼元素將被賦予此標識符作爲它的名稱，此後，就可以用此標識符代替此代碼元素

各代碼元素可以直接聲明在何種代碼塊中

|                                  | 万物代码块 | 包代码块 | 文件代码块 | 局部代码块 |
| :------------------------------: | :--------: | :------: | :--------: | :--------: |
| 预声明的（即内置的）代码元素(1)  |    可以    |          |            |            |
|              包引入              |            |          |    可以    |            |
| 定义类型和类型别名（不含内置的） |            |   可以   |    可以    |    可以    |
|     有名常量（不含内置常量）     |            |   可以   |    可以    |    可以    |
|     变量（不含内置变量）(2)      |            |   可以   |    可以    |    可以    |
|       函数（不含内置函数）       |            |   可以   |    可以    |            |
|             跳转标签             |            |          |            |    可以    |

1） 預聲明代碼元素聲明在`builtin`標準庫中

2） 不包含結構體字段變量聲明

- 包引入不能聲明在包代碼塊和局部代碼塊中
- 函數不能被聲明在局部代碼塊中(匿名函數可以聲明在局部代碼塊中，但是它不屬於元素)
- 跳轉標簽只能被聲明在局部代碼塊中

注：

- 如果包含兩個代碼元素生命的最内層代碼塊為同一個，則這兩個代碼元素不能同名
- 聲明在一個包中的包級代碼元素的名稱不能和此包中任何源文件中的包引入同名
- 如果包含两个跳转标签的最内层函数体为同一个，则这两个标签不能同名；
- 一个跳转标签的所有引用必须处于包含此跳转标签声明的最内层函数体代码块内
- 各种控制流程中的隐式代码块对元素声明有特殊的要求。 一般说来，声明语句不允许出现在这样的隐式代码块中，除了一些变量短声明：
  - 每个`if`、`switch`或者`for`关键字后可以紧跟着一条变量短声明语句；
  - 一个`select`控制流程中的每个`case`关键字后可以紧跟着一条变量短声明语句。

声明在包代码块中并且在所有局部代码块之外的代码元素称为包级元素。 包级元素可以是有名常量、变量、函数、定义类型或类型别名。

# 表達式估值順序

一個表達式將在其所依賴的其他表達式估值之後進行估值。

## 包級變量初始化順序

在运行时刻，当一个包被加载的时候，不依赖于任何其它未初始化包级变量的未初始化包级变量将按照它们在代码中的声明顺序被初始化。 此过程可能需要重复若干次，直到此过程中不再有任何包级变量被初始化。 对于一个成功编译了的Go程序，当所有这样的过程结束之后，所有的包级变量都应该被初始化了。

在包级变量初始化过程中，呈现为空标识符的包级变量和其它包级变被同等对待。

```go
var (
	_ = f("w", x)
	x = f("x", z)
	y = f("y")
	z = f("z")
)

func main() {
	f("\n")
}

func f(s string, deps ...int) int {
	fmt.Println(s)
	return 0
}

```

運行時  w,需要依賴於x，  x依賴於z  ，所以最開始需要初始化兩個獨立的常量 y，z   然後在去初始化x  w  所以執行順序為 `yzxw`

##   通常估值順序

当估值一个表达式、赋值语句或者函数返回语句中的操作数时，所有的函数调用、方法调用和通道操作将按照它们在代码中的出现顺序进行估值。

注：一個顯示類型轉換`T(x)`不屬於函數調用

```go
y[z.f()], ok = g(h(a, b), i()+x[j()], <-c), k()
```

在此赋值语句中，

- `c`是一个通道表达式，它将被估值为一个通道值；
- `g`、`h`、`i`、`j`和`k`是一些函数表达式，它们将被估值为一些函数值；
- `f`是表达式`z`值的一个方法。

估值順序

- 此赋值中涉及到的函数调用、方法调用和通道操作必须按照这样的顺序执行：`z.f()`→`h()`→`i()`→`j()`→`<-c`→`g()`→`k()`；
- 调用`h()`在表达式`h`、`a`和`b`估值之后调用；
- `y[]`在方法调用`z.f()`执行之后被估值；
- 方法调用`z.f()`在表达式`z`估值之后执行；
- `x[]`在调用`j()`执行之后被估值。

## 賦值語句中的表達式估值和賦值執行順序

> 一条赋值语句的执行分为两个阶段。 首先，做为目标值的元素索引表达式中的容器值表达式和索引值表达式、做为目标值的指针解引用表达式中的指针值表达式、以及此赋值语句中的其它非目标值表达式将按照上述通常估值顺序估值。 然后，各个单值赋值将按照从左到右的顺序执行。

第一階段為估值階段，第二階段為實施階段

- 如果一个目标值表达式是一个空标识符，则它的最基本形式依旧是一个空标识符；
- 如果一个目标值表达式是一个容器（数组或者切片或者映射）元素索引表达式`c[k]`，则它的最基本形式为`(*cAddr)[k]`，其中一个`cAddr`为指向`c`的指针；
- 对于其它情形的任何一个目标值表达式，它必然是可寻址的，则它的最基本形式为它的地址的解引用形式。

## `switch-case`流程中的表達式估值

在进入一个分支代码块之前，各个`case`关键字后跟随的表达式将按照从上到下和从左到右的顺序进行估值，直到某个比较结果为`true`为止。

```go
package main

import "fmt"

func main() {
	f := func(n int) int {
		fmt.Printf("f(%v) is called.\n", n)
		return n
	}

	switch x := f(3); x + f(4) {
	default:
	case f(5):
	case f(6), f(7), f(8):
	case f(9), f(10):
	}

```

在运行时刻，各个`f()`调用将按照传给它们参数的大小顺序进行估值，直到和调用`f(7)`的比较结果为`true`为止。 所以调用`f(8)`、`f(9)`和`f(10)`将不会被估值。

## `select-case`表達式估值順序

当执行一个`select-case`流程控制代码块时，各个`case`关键值后跟随的所有通道操作中的通道表达式和所有通道发送操作中的发送值表达式都将被按照它们在代码中的出现次序（从上到下从左到右）估值一次。

注意：以通道接收操作做为源值的赋值语句中的目标值表达式只有在此通道接收操作被选中之后才会被估值。

# 值複製成本

在GO中，值複製很常見。 賦值、傳參、通道發送操作均涉及發哦複製

## 值尺寸

一個值的尺寸表示此值得直接部分在内存中佔多少個字節，其間接部分(如果存在的話)對他的尺寸沒有貢獻

在GO中如果兩個值得類型為同一種類的類型，并且它們的惡行的種類部位字符串、接口、數組和結構體，則這兩個值得尺寸總是相等的

對於官方標準編譯器來説，任何一個特定類型的所有值的尺寸都是相同的。換言之，一個值的尺寸為此值的類型尺寸

一個數組的尺寸取決於它的元素類型的尺寸和他的長度，他的尺寸為他的元素類型的尺寸和他的長度的乘積。

一個結構體的尺寸取決於他的各個字段的類型尺寸和這些字段的排列順序，爲了程序執行性能，編譯器需要保證某些類型的值在内存中存放時必須滿足特定的内粗地址對齊的要求，地址對其可能會造成相鄰的兩個字段之間在内存中被插入填充一些多於的字節。所以一個結構體類型的尺寸必定不小於此結構躰類型的各個字段的和

下表列出了各种种类的类型的尺寸（对标准编译器1.14来说）。 在此表中，一个word表示一个原生字。在32位系统架构中，一个word为4个字节；而在64位系统架构中，一个word为8个字节。

|             类型种类              |               值尺寸                |                         GO白皮書要求                         |
| :-------------------------------: | :---------------------------------: | :----------------------------------------------------------: |
|               布尔                |               1 byte                |                         未做特别要求                         |
|        int8, uint8 (byte)         |               1 byte                |                            1 byte                            |
|           int16, uint16           |               2 bytes               |                           2 bytes                            |
|   int32 (rune), uint32, float32   |               4 bytes               |                           4 bytes                            |
| int64, uint64, float64, complex64 |               8 bytes               |                           8 bytes                            |
|            complex128             |              16 bytes               |                           16 bytes                           |
|             int, uint             |               1 word                | 架构相关，在32位系统架构中为4个字节，而在64位系统架构中为8个字节 |
|              uintptr              |               1 word                |                  必须足够存下任一个内存地址                  |
|              字符串               |               2 words               |                         未做特别要求                         |
|               指针                |               1 word                |                         未做特别要求                         |
|               切片                |               3 words               |                         未做特别要求                         |
|               映射                |               1 word                |                         未做特别要求                         |
|               通道                |               1 word                |                         未做特别要求                         |
|               函数                |               1 word                |                         未做特别要求                         |
|               接口                |               2 words               |                         未做特别要求                         |
|              结构体               | 所有字段尺寸之和 + 所有填充的字節數 |      一个不含任何尺寸大于零的字段的结构体类型的尺寸为零      |
|               数组                |        元素类型的尺寸 * 长度        |          一个元素类型的尺寸为零的数组类型的尺寸为零          |



## 值複製成本

複製一個值的成本正比於此值的尺寸。但是，值尺寸并不是唯一決定因素。不同的CPU架構可能會對某些特定尺寸的值複製進行了優化

对于标准编译器，除了大尺寸的结构体和数组类型，其它类型均为小尺寸类型。

为了防止在函数传参和通道操作中因为值复制代价太高而造成的性能损失，我们应该避免使用大尺寸的结构体和数组类型做为参数类型和通道的元素类型，应该在这些场合下使用基类型为这样的大尺寸类型的指针类型。 另一方面，我们也要考虑到太多的指针将会增加垃圾回收的压力。所以到底应该使用大尺寸类型还是以大尺寸类型为基类型的指针类型做为参数类型或通道的元素类型取决于具体的应用场景。

# 并發同步

并發同步是指如何控制若干并發計算(協程),從而避免在它們之間產生數據競爭的現象，避免在他們無所事事的時候消耗CPU資源，有時候也稱爲數據同步

## 將通道用作future/promise

支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。

### 返回單向接收通道作爲函數結果

```go
package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest() <-chan int32 {
	r := make(chan int32)

	go func() {
		time.Sleep(time.Second * 3) // 模拟一个工作负载
		r <- rand.Int31n(100)
	}()

	return r
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano())

	a, b := longTimeRequest(), longTimeRequest()
	fmt.Println(sumSquares(<-a, <-b))
}
```

### 將單向通道類型用作實參

```go

func longTimeRequest(r chan<- int32)  {
	time.Sleep(time.Second * 3) // 模拟一个工作负载
	r <- rand.Int31n(100)
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano())

	ra, rb := make(chan int32), make(chan int32)
	go longTimeRequest(ra)
	go longTimeRequest(rb)

	fmt.Println(sumSquares(<-ra, <-rb))
}
```

## 使用通道實現通知

通知可以被看作是特殊的请求/回应用例。在一个通知用例中，我们并不关心回应的值，我们只关心回应是否已发生。 所以我们常常使用空结构体类型`struct{}`来做为通道的元素类型，因为空结构体类型的尺寸为零，能够节省一些内存

### 向一個通道發送一個值來實現單對單通知

如果一个通道中无值可接收，则此通道上的下一个接收操作将阻塞到另一个协程发送一个值到此通道为止。 所以一个协程可以向此通道发送一个值来通知另一个等待着从此通道接收数据的协程。

```go
func main() {
	values := make([]byte, 32 * 1024 * 1024)
	if _, err := rand.Read(values); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	done := make(chan struct{}) // 也可以是缓冲的

	// 排序协程
	go func() {
		sort.Slice(values, func(i, j int) bool {
			return values[i] < values[j]
		})
		done <- struct{}{} // 通知排序已完成
	}()

	// 并发地做一些其它事情...

	<- done // 等待通知
	fmt.Println(values[0], values[len(values)-1])
}
```

### 從一個通道接受一個值來實現單對單通知

如果一个通道的数据缓冲队列已满（非缓冲的通道的数据缓冲队列总是满的）但它的发送协程队列为空，则向此通道发送一个值将阻塞，直到另外一个协程从此通道接收一个值为止。 可以他用過從一個通道接收數據來實現單對單通知，一般使用非緩衝通道來實現

```go
func main() {
	done := make(chan struct{})
		// 此信号通道也可以缓冲为1。如果这样，则在下面
		// 这个协程创建之前，我们必须向其中写入一个值。

	go func() {
		fmt.Print("Hello")
		// 模拟一个工作负载。
		time.Sleep(time.Second * 2)

		// 使用一个接收操作来通知主协程。
		<- done
	}()

	done <- struct{}{} // 阻塞在此，等待通知
	fmt.Println(" world!")
}
```

### 多和單  單對多通知

```go
type T = struct{}

func worker(id int, ready <-chan T, done chan<- T) {
	<-ready // 阻塞在此，等待通知
	log.Print("Worker#", id, "开始工作")
	// 模拟一个工作负载。
	time.Sleep(time.Second * time.Duration(id+1))
	log.Print("Worker#", id, "工作完成")
	done <- T{} // 通知主协程（N-to-1）
}

func main() {
	log.SetFlags(0)

​	ready, done := make(chan T), make(chan T)
​	go worker(0, ready, done)
​	go worker(1, ready, done)
​	go worker(2, ready, done)

​	// 模拟一个初始化过程
​	time.Sleep(time.Second * 3 / 2)
​	// 单对多通知
​	ready <- T{}; ready <- T{}; ready <- T{}
​	// 等待被多对单通知
​	<-done; <-done; <-done
}
```



## `sync.Once`類型

每個`*sync.Once`值都有一個`Do(f func())`方法，此方法只有一個類型爲`func`的參數

对一个可寻址的`sync.Once`值`o`，`o.Do()`（即`(&o).Do()`的简写形式）方法调用可以在多个协程中被多次并发地执行， 这些方法调用的实参应该（但并不强制）为同一个函数值。 在这些方法调用中，有且只有一个调用的实参函数（值）将得到调用。 此被调用的实参函数保证在任何`o.Do()`方法调用返回之前退出。 换句话说，被调用的实参函数内的代码将在任何`o.Do()`方法返回调用之前被执行。

一般而言，`sync.Once`值被用來確保一段代碼在一個并發程序中被執行且今被執行一次

```go
func main() {

	log.SetFlags(0)
	x:=0
	doSomthing:= func() {
		x++
		log.Println("hello")
	}

	var wg sync.WaitGroup
	var once sync.Once

	for i := 0; i <5 ; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(doSomthing)
			log.Println("world")
		}()
	}

	wg.Wait()
	log.Println("x is ",x)
}

```

結果為：

```go
F:\GO\bin\src\>go run gr.go
hello
world
world
world
world
world
x is  1
```

## `sync.Mutex`和`sync.RWMutex`

`*sync.Mutex`和`*sync.RWMutex`类型都实现了`sync.Locker`接口類型，所以這兩個類型有兩個方法`Lock{}`,`Unlock()`,用來保護一份數據不會被多個使用者同時讀取和修改

`*sync.RWMutex`类型还有两个另外的方法：`RLock()`和`RUnlock()`，用来支持多个读取者并发读取一份数据但防止此份数据被某个数据写入者和其它数据访问者（包括读取者和写入者）同时使用。

注意：`m.Lock()`和`m.Unlock()`分别是`(&m).Lock()`和`(&m).Unlock()`的简写形式。一个锁并不会绑定到一个协程上；换句话说，一个锁的获取者和此锁的持有者（以及释放者）可能不是一个协程，尽管在实践中这种情况比较少见。

```go
var m sync.RWMutex
	go func() {
		m.RLock()
		fmt.Print("a")
		time.Sleep(time.Second)
		m.RUnlock()
	}()
	go func() {
		time.Sleep(time.Second * 1 / 4)
		m.Lock()
		fmt.Print("b")
		time.Sleep(time.Second)
		m.Unlock()
	}()
	go func() {
		time.Sleep(time.Second * 2 / 4)
		m.Lock()
		fmt.Print("c")
		m.Unlock()
	}()
	go func () {
		time.Sleep(time.Second * 3 / 4)
		m.RLock()
		fmt.Print("d")
		m.RUnlock()
	}()
	time.Sleep(time.Second * 3)
	fmt.Println()
```

## `sync.Cond`類型

該類型提供了一種有效的方式來實現多個協程閒的通知

每个`sync.Cond`值拥有一个`sync.Locker`类型的名为`L`的字段。 此字段的具体值常常为一个`*sync.Mutex`值或者`*sync.RWMutex`值。

`sync.Cond`類型有三個方法`Wait()`,`Signal()`,`Broadcast()`

每個`Cond`維護著一個先進先出的等待協程隊列，對於一個可以尋址的`Cond`值`C`

- c.Wait()  必須在`c.L`字段值的鎖被成功獲取的時候調用；，否則`c.Wait()`調用將造成一個panic，一個c.Wait() 調用將

1.  首先將當前協程推入到c所維護的等待協程隊列；
2. 然後調用`c.L.Unlock()`釋放`c.L`的鎖；
3. 然後當前協程進入阻塞狀態(*当前协程将被另一个协程通过`c.Signal()`或`c.Broadcast()`调用唤醒而重新进入运行状态。*)一旦当前协程重新进入运行状态，`c.L.Lock()`将被调用以试图重新获取`c.L`字段值的锁。 此`c.Wait()`调用将在此试图成功之后退出。

- 一个`c.Signal()`调用将唤醒并移除`c`所维护的等待协程队列中的第一个协程（如果此队列不为空的话）。
- 一个`c.Broadcast()`调用将唤醒并移除`c`所维护的等待协程队列中的所有协程（如果此队列不为空的话）。

注：`c.Signal()`和`c.Broadcast()`调用常用来通知某个条件的状态发生了变化。 一般说来，`c.Wait()`应该在一个检查某个条件是否已经得到满足的循环中调用。

```go
package main

import (
	"fmt"
	"math/rand"

	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	const N = 10
	var values [N]string

	cond := sync.NewCond(&sync.Mutex{})
	cond.L.Lock()

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d) // 模拟一个工作负载
			cond.L.Lock()
			// 下面的修改必须在cond.L被锁定的时候执行
			values[i] = string('a' + i)
			cond.Broadcast() // 可以在cond.L被解锁后发出通知
			cond.L.Unlock()
			// 上面的通知也可以在cond.L未锁定的时候发出。
			//cond.Broadcast() // 上面的调用也可以放在这里
		}(i)
	}

	// 此函数必须在cond.L被锁定的时候调用。
	checkCondition := func() bool {
		fmt.Println(values)
		for i := 0; i < N; i++ {
			if values[i] == "" {
				return false
			}
		}
		return true
	}
	for !checkCondition() {
		cond.Wait() // 必须在cond.L被锁定的时候调用
	}

	cond.L.Unlock()
}
```

因为上例中只有一个协程（主协程）在等待通知，所以其中的`cond.Broadcast()`调用也可以换为`cond.Signal()`。 如上例中的注释所示，`cond.Broadcast()`和`cond.Signal()`不必在`cond.L`的锁被成功获取的时候调用。

为了防止数据竞争，对自定义条件的修改必须在`cond.L`的锁被成功获取的时候才能执行。 另外，`checkCondition`函数和`cond.Wait`方法也必须在`cond.L`的锁被成功获取的时候才可被调用。

# GO中内存順序保證

## 内存順序

很多编译器优化（在编译时刻）和CPU处理器优化（在运行时刻）会常常调整指令执行顺序，从而使得指令执行顺序和代码中指定的顺序不太一致。 指令顺序也稱爲内存順序

## GO中的内存模型

不同的CPU架构提供了不同的栅栏（fence）指令来防止各种指令执行顺序调整，Go语言的设计哲学是用尽量少的易于理解的特性来支持尽量多的使用场景，同时还要尽量保证代码的高执行效率。 所以Go内置和标准库并没有提供直接插入各种栅栏指令的途径。 事实上，这些栅栏指令被使用在Go中提供的各种高级数据同步技术的实现中。 

### 一個協程的創建發生在此協程中的任何代碼執行之前

通道操作幾本順序保證

1. 一个通道上的第***n\***次成功发送操作的开始发生在此通道上的第***n\***次成功接收操作完成之前，无论此通道是缓冲的还是非缓冲的。
2. 一个容量为***m\***通道上的第***n\***次成功接收操作的开始发生在此通道上的第***n+m\***次发送操作完成之前。 特别地，如果此通道是非缓冲的（`m == 0`），则此通道上的第***n\***次成功接收操作的开始发生在此通道上的第***n\***次发送操作完成之前。
3. 一个通道的关闭操作发生在任何因为此通道被关闭而从此通道接收到了零值的操作完成之前。

 对一个非缓冲通道来说，其上的第***n\***次成功发送的完成的发送和其上的第***n\***次成功接收的完成应被视为同一事件

### 互斥鎖相關的順序保證

1. 对于一个可寻址的`sync.Mutex`类型或者`sync.RWMutex`类型的值`m`，第***n\***次成功的`m.Unlock()`方法调用保证发生在第***n+1\***次`m.Lock()`方法调用返回之前。
2. 对一个可寻址的`RWMutex`类型值`rw`，如果它的第***n\***次`rw.Lock()`方法调用已成功返回，并且有一个`rw.RLock()`方法调用保证发生在此第***n\***次`rw.Lock()`方法调用返回之后，则第***n\***次成功的`rw.Unlock()`方法调用保证发生在此`rw.RLock()`方法调用返回之前。
3. 对一个可寻址的`RWMutex`类型值`rw`，如果它的第***n\***次`rw.RLock()`方法调用已成功返回，并且有一个`rw.Lock()`方法调用保证发生在此第***n\***次`rw.RLock()`方法调用返回之后，则第***m\***次成功的`rw.RUnlock()`方法调用（其中`m <= n`）保证发生在此`rw.Lock()`方法调用返回之前。

### `sync.WaitGroup`值做出的顺序保证

一个可寻址的`sync.WaitGroup`值`wg`维护的计数不为0，并且有一个`wg.Wait()`方法调用在此给定时刻之后调用。 如果有一组`wg.Add(n)`方法调用在此给定时刻之后调用，并且我们可以保证这组调用中只有最后一个返回的调用会将`wg`维护的计数修改为0， 则这组调用中的每个调用保证都发生在此`wg.Wait()`方法调用返回之前。

# 有間接底層部分的類型

- 字符串類型
- 函數
- 切片
- 映射
- 通道
- 接口

## 容器類型比較

|  类型  | 容器值是否支持添加新的元素？ | 容器值中的元素是否可以被替换？ | 容器值中的元素是否可寻址？ | 访问容器值元素是否会更改容器长度？ | 容器值是否可以有间接底层部分？ |
| :----: | :--------------------------: | :----------------------------: | :------------------------: | :--------------------------------: | :----------------------------: |
| 字符串 |              否              |               否               |             否             |                 否                 |             是(1)              |
|  数组  |              否              |             是(2)              |           是(2)            |                 否                 |               否               |
|  切片  |            否(3)             |               是               |             是             |                 否                 |               是               |
|  映射  |              是              |               是               |             否             |                 否                 |               是               |
|  通道  |            是(4)             |               否               |             否             |                 是                 |               是               |

(1) 对于标准编译器和运行时来说。
       (2) 对于可寻址的数组值来说。

(3) 一般说来，一个切片的长度只能通过将另外一个切片赋值给它来被整体替换修改，这里我们不视这种情况为“添加新的元素”。 其实，切片的长度也可以通过调用`reflect.SetLen`来单独修改。增加切片的长度可以看作是一种变相的向切片添加元素。 但`reflect.SetLen`函数的效率很低，因此很少使用。
       (4) 对于带缓冲并且缓冲未满的通道来说。

# Go中的nil

`nil`是go中的一個預聲明標識符，可以表示很多類型的零值

- pinter (all)
- map
- slice
- function
- channel
- interface

## 預聲明的標識符nil沒有默認類型

go中很多預聲明的標識符都有默認類型如： `true`,`false` 默認類型為`bool`  `iota`默認類型為`int`

预声明标识符`nil`是Go中唯一一个没有默认类型的类型不确定值

```go
func main() {
	// 代码中必须提供充足的信息来让编译器推断出某个nil的类型。
	_ = (*struct{})(nil)
	_ = []int(nil)
	_ = map[int]bool(nil)
	_ = chan string(nil)
	_ = (func())(nil)
	_ = interface{}(nil)

	// 下面这一组和上面这一组等价。
	var _ *struct{} = nil
	var _ []int = nil
	var _ map[int]bool = nil
	var _ chan string = nil
	var _ func() = nil
	var _ interface{} = nil

	// 下面这行编译不通过。
	var _ = nil
}·
```

### `nil`不是一個關鍵字，可以被更内層的同名標識符所遮擋

```go
nil := 123
	fmt.Println(nil) // 123

	// 下面这行编译报错，因为此行中的nil是一个int值。
	var _ map[string]int = nil
```

不同類型的`nil`的尺寸可能不同

| 类型（`T`） | `T(nil)`的尺寸 |
| :---------: | :------------: |
|    指针     |     1 word     |
|    切片     |    3 words     |
|    映射     |     1 word     |
|    通道     |     1 word     |
|    函数     |     1 word     |
|    接口     |    2 words     |

### 兩個不同類型的`nil`值是不能互相比較的

```go
type IntPtr *int
// 类型IntPtr的底层类型为*int。
var _ = IntPtr(nil) == (*int)(nil)

// 任何类型都实现了interface{}类型。
var _ = (interface{})(nil) == (*int)(nil)

// 一个双向通道可以隐式转换为和它的
// 元素类型一样的单项通道类型。
var _ = (chan int)(nil) == (chan<- int)(nil)
var _ = (chan int)(nil) == (<-chan int)(nil)
```

### 同一類型的兩個`nil`可能不能互相比較

映射类型、切片类型和函数类型是不支持比较类型。 比较同一个不支持比较的类型的两个值（包括nil值）是非法的。

```go
var _ = ([]int)(nil) == ([]int)(nil)
var _ = (map[string]int)(nil) == (map[string]int)(nil)
var _ = (func())(nil) == (func())(nil)

//映射类型、切片类型和函数类型的任何值都可以和类型不确定的裸nil标识符比较
var _ = ([]int)(nil) == nil
var _ = (map[string]int)(nil) == nil
var _ = (func())(nil) == nil


```



### 兩個`nil`值可能并不相等

如果可被比较的两个nil值中的一个的类型为接口类型，而另一个不是，则比较结果总是`false`。

### 訪問`nil`的map條目不會造成panic

访问一个nil映射将得到此映射的类型的元素类型的零值。

```go
fmt.Println( (map[string]int)(nil)["key"] ) // 0
fmt.Println( (map[int]bool)(nil)[123] )     // false
fmt.Println( (map[int]*int64)(nil)[123] )   // <nil>
```

### `range`关键字后可以跟随nil通道、nil映射、nil切片和nil数组指针

遍历nil**映射**和nil**切片**的循环步数均为**零**。

遍历一个ni**l数组指针**的循环步数为对应**数组类型的长度**。 （但是，如果此数组类型的长度不为零并且第二个循环变量未被舍弃或者忽略，则对应`for-range`循环将导致一个恐慌。）

遍历一个nil通道将使当前协程**永久阻塞**。

### 通过nil非接口属主实参调用方法不会造成恐慌

### 类型`T`的零值可以用预声明的`nil`标识符表示，则`*new(T)`的估值结果为一个`T`类型的nil值

```go
func main() {
	fmt.Println(*new(*int) == nil)         // true
	fmt.Println(*new([]int) == nil)        // true
	fmt.Println(*new(map[int]bool) == nil) // true
	fmt.Println(*new(chan string) == nil)  // true
	fmt.Println(*new(func()) == nil)       // true
	fmt.Println(*new(interface{}) == nil)  // true
}
```
