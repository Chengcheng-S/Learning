# 边界检查

Go是一个内存安全的语言。在数组和切片的索引和子切片操作中，Go运行时将检查操作中使用的下标是否越界。 如果下标越界，一个恐慌将产生，以防止这样的操作破坏内存安全。这样的检查称为边界检查。  在保证程序安全运行的前提下，对运行效率有些许影响

```
go build -gcflags="-d=ssa/check_bce/debug=1"
```

运行以上的命令来检查那些程序需要边界检查

```go
package main

//var counter = func(n int ) chan<-chan <-int{
//	requests :=make(chan chan<-int)
//	go func() {
//		for request := range requests {
//			if request ==nil{
//				n++
//			}else {
//				request <-n  // 返回当前计数
//			}
//		}
//	}()
//	return requests
//}(0)

func main() {
	//cha := func(done chan<- struct{}) {
	//	for i := 0; i < 1000; i++ {
	//		counter <- nil
	//	}
	//	done <- struct{}{}
	//}
	//
	//done := make(chan struct{})
	//go cha(done)
	//go cha(done)
	//<-done;<-done
	//request:=make(chan int , 1)
	//counter<-request
	//fmt.Println(<-request)


}
func f1(s []int){
	_=s[0]  //边界检查
	_=s[1]  // 边界检查
	_=s[2]  //边界检查
}
func fa(s []int){
	_=s[3]  // 边界检查
	_=s[0]
	_=s[2]
}

func fb(s []int,index int){
	_=s[index]  // 边界检查
	_=s[index]  // 无需边界检查
	_=s[2]   // 边界检查
}

func fc(s [6]int){
	_ = s[4]    // 边界检查
}
```



```
F:\GO\bin\src\feature>go build -gcflags="-d=ssa/check_bce/debug=1" main.go
# command-line-arguments
.\main.go:36:5: Found IsInBounds
.\main.go:37:5: Found IsInBounds
.\main.go:38:5: Found IsInBounds
.\main.go:41:5: Found IsInBounds
.\main.go:47:5: Found IsInBounds
.\main.go:49:5: Found IsInBounds
```

由于41行确保了 42 43行不会越界，因此也不会进行边界检查

fb中 47行保证了边界没有越界，因此 48也就不需要边界检查了

至于fc  由于传入的数组元素为6 而获取的是第5个元素因此不会越界

