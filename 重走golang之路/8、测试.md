# 测试

## 总览

`go  test` 按照一定的约定和组织的测试代码的驱动程序。在包目录中，所有以`_test.go`为后缀的源文件并不是go build构建包的一部分，他们属于测试的一部分。

在`*_test.go`文件中，函数分为：测试函数、基准测试函数、示例函数

测试函数则是以`Test`为函数名前缀的函数，用于测试程序逻辑是否正确;go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。

基准测试函数则是以`Benchmark`为函数名前缀的函数，用于`衡量函数的性能`,go test命令会多次运行基准函数以计算一个平均的执行时间。

示例函数以`Example`为前缀的函数，提供一个由版一起保证正确性的示例文档

go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。

## 测试函数

每个测试函数必须导入`testing`包。测试函数的签名：

```go
func TestA(t *testing.T){
		// do somthing
}   
/*
注意测试函数的命名 必须以Test为前缀
参数t用于报告测试失败和附加的日志信息
*/
```

go test 命令如果没有参数指定包，默认为当前目录对应的包(和go build一样)

```go
package words

func  Print(a,b int) bool{
	c := a - b
	if c > 0 {

		return true
	}

	return false
}

func Add(a,b int)int{
	return a+b
}
```

测试函数

```go
package words

import "testing"

import "fmt"
func TestPrint(t *testing.T) {
	var a,b int
	//a,_=fmt.Scanln(&a)
	//b,_=fmt.Scanln(&b)
	a=2
	b=1
	if Print(a,b){
		fmt.Print("a b 都对")
	}
}

func TestAdd(t *testing.T) {
	a := 2
	b := 10
	c := a + b
	if Add(a, b) == c {
		fmt.Print("合格")
	} else {
		fmt.Printf("不合格\n")
	}
}
```

```go
F:\GO\bin\src\words>go test -v
=== RUN   TestPrint
a b 都对--- PASS: TestPrint (0.00s)
=== RUN   TestAdd
heg--- PASS: TestAdd (0.00s)
PASS
ok   /words  0.446s

```

go test 参数-v 返回每个测试函数的名字和运行时间

-run 对应一个正则表达式，只有测试函数名匹配时才会被测试

```go
F:\GO\bin\src\words>go test -v -run Print
=== RUN   TestPrint
--- PASS: TestPrint (0.00s)
PASS
ok      words  0.478s

```

## 测试覆盖率

```go
F:\GO\bin\src\words>go test -run =Print -coverprofile=a.out
testing: warning: no tests to run
PASS
coverage: 72.0% of statements
ok      words  0.608s

```

由测试驱动触发运行到的被测试函数的代码数目被称为测试的覆盖率

```go
$ go tool cover
Usage of 'go tool cover':
Given a coverage profile produced by 'go test':
    go test -coverprofile=c.out

Open a web browser displaying annotated source code:
    go tool cover -html=c.out
...
```

`go tool`命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT/pkg/tool/${GOOS}_${GOARCH}目录。

使用`-coverprofile`标志参数重新运行测试

```go
go test -run =Print -coverprofile=a.out
testing: warning: no tests to run
PASS
coverage: 0.0% of statements
ok      杂七杂八/words  0.608s

```

```go
命令解析
			运行的测试函数           
				|					
go test -run =Print -coverprofile=a.out
									|  
								覆盖率结果输出的文件
```

在网页中查看报告

```go
go tool cover -html=a.out
```

## 基准测试

不同于普通测试，默认情况下不运行基准测试，需要使用`-bench`来运行

```go
			  这个.表明匹配任何的基准测试函数
					 |  
words>go test -bench .

正确
goos: windows
goarch: amd64
pkg: words
BenchmarkAdd-4          正确
正确
正确
正确
正确
1000000000               0.00290 ns/op
PASS
ok      words  0.498s

```

报告显示每次调用Add函数花费0.00290微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。

## 性能剖析

Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的`go test`工具对几种分析方式都提供了支持。

CPU分析文件标识了函数执行时所需要的CPU时间。当前运行的系统线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个分析文件然后恢复正常的运行。

堆分析则记录了程序的内存使用情况。每个内存分配操作都会触发内部平均内存分配例程，每个512KB的内存申请都会触发一个事件。

阻塞分析则记录了goroutine最大的阻塞操作，例如系统调用、管道发送和接收，还有获取锁等。分析库会记录每个goroutine被阻塞时的相关操作。

在测试环境下只需要一个标志参数就可以生成各种分析文件。当一次使用多个标志参数时需要当心，因为分析操作本身也可能会影像程序的运行。

```go
$ go test -cpuprofile=cpu.out
$ go test -blockprofile=block.out
$ go test -memprofile=mem.out
```

`go tool pprof`命令。该命令有许多特性和选项，生成这个概要文件的可执行程序和对于的分析日志文件。

为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要和分析日志对于的可执行程序。虽然`go test`命令通常会丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对于测试包的名字。

```go
go test -run=NONE -bench=ClientServerParallelTLS64 \
    -cpuprofile=cpu.log net/http
```

```go
			指定输出的格式
				|	
go tool pprof -text -nodecount=10 ./http.test cpu.log
						|
					标志参数限制了指出书前10行的结果
```

参数`-text`用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中`-nodecount=10`标志参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。

## 示例函数

示例函数没有函数参数和返回值。

示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数直接的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是完整真实的Go代码，需要接受编译器的编译时检查，这样可以保证示例代码不会腐烂成不能使用的旧代码。

根据示例函数的后缀名部分，godoc的web文档会将一个示例函数关联到某个具体函数或包本身，因此ExamAdd示例函数将是Add函数文档的一部分，Example示例函数将是包文档的一部分。

示例文档的第二个用处是在`go test`执行测试的时候也运行示例函数测试。如果示例函数内含有类似上面例子中的`// Output:`格式的注释，那么测试工具会执行这个示例函数，然后检测这个示例函数的标准输出和注释是否匹配。

示例函数的第三个目的提供一个真实的演练场。由godoc提供的文档服务，它使用了Go Playground提高的技术让用户可以在浏览器中在线编辑和运行每个示例函数，









