# 接口

非侵入式，无需显式声明

接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。

Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。

这种设计创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。

1. 接口的命名習慣以`er`結尾，結構體
2. 接口只有方法簽名，沒有實現
3. 接口沒有數據字段
4. 可在接口中嵌入其他的接口
5. 類型可以實現多個接口

## 接口值

接口也是值。它们可以像其它值一样传递。

接口值可以用作函数的参数或返回值。

在内部，接口值可以看做包含值和具体类型的元组

```go
(value, type)
```

从源码看 iface包含两个字段:`tab`(接口表指针，只想类型信息)；`data`(数据指针，指向具体的数据)也就动态类型和动态值。

接口值包括`动态类型`和`动态值`

接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。

即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

注： 保存了nil具体值的接口其本身并不为nil

## 接口是合约

接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。（就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。）

接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。

一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判读接口值是否为空。调用一个空接口值上的任意方法都会产生panic

实现了接口中的所有方法，就实现了这个接口。接口就是一个需要实现的方法列表。go通过接口模拟多态

实现：

1. 实现本身的类型，能够访问实现类中的属性和方法	
2. 对应的接口的类型，只能够访问接口中的方法

接口的用法：

1. 一个函数如果接收接口类型为参数，实际上可以传入该接口的任意实现类型作为参数
2. 定义一个类型为接口类型，实际上可以赋值为任意实现的类的对象

## 类型断言

类型断言是一个使用在接口值上的操作，语法上`x.(T)`,此处x表示一个接口类型和T表示为一个类型。一个类型断言检查它的操作对象的动态类型是否和断言类型匹配。

第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。

第二种，如果相反断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。

方法1： 

1. instance:=接口对象.(实际类型) // 不安全会panic()
2. instance,ok :=接口对象(实际类型)// 安全

方法2：

switch语句

```go
switch instance :=接口对象.(type){
	case 实际类型1:
		....
	case 实际类型2：
	     ......

	default:
	.....

}
```

```go
package main

import (
	"fmt"
	"math"
)

func main() {

	var t1 Traingle=Traingle{a:3,b:4,c:5}
    var c1 Circle=Circle{radius:2}
    fmt.Printf("🔺的周长:%v,🔺的面积:%v\n",t1.peri(),t1.area())
    fmt.Printf("圆形的周长:%v,⚪的面积：%v\n",c1.peri(),c1.area())

	// 声明接口类型
	var s1 Shape
    s1=t1
    fmt.Println(s1.peri())
    fmt.Println(s1.area())


    var s2 Shape
    s2=c1
    fmt.Println(s2.area(),s2.peri())

    testshape(s1)
    gettype(t1)
    gettype(c1)
    var t2 *Traingle=&Traingle{a:4,b:5,c:2}
    gettype2(t2)
}

func gettype2(s Shape){
	switch ins:=s.(type) {
	case Traingle:
		fmt.Println("🔺",ins.a)
	case Circle:
		fmt.Println("⚪",ins.radius)
	case *Traingle:
		fmt.Printf("指针 地址为：%p",&ins.a)

	}
}

//定义一个函数
func testshape(s Shape){
	fmt.Printf("周长:%2f,面积：%2f",s.peri(),s.area())
}

// 判断数据类型
func gettype(s Shape){
	// 断言
	if ins,ok:=s.(Traingle);ok{
		fmt.Println("是▲，边长分别为：",ins.a,ins.b,ins.c)
	}else if  ins,ok:=s.(Circle);ok{
		fmt.Println("是⚪,半径为：",ins.radius)
	}else {
		fmt.Println("未能识别的参数类型‘-’")
	}
}


//定义一个接口
type Shape interface {
	peri() float64 // 周长
	area() float64 //面积

}

//定义实现类: 🔺
type Traingle struct {
	a,b,c float64
}
// 三角形的周长
func (t Traingle)peri() float64{
	return t.a+t.b+t.c
}
// ▲面积
func(t Traingle)area() float64{
	p:=t.peri()/2
	s:=math.Sqrt(p*(p-t.a)*(p-t.b)*(p-t.c))
	return s
}


//定义实现类⚪
type Circle struct {
	radius float64
}

// ⚪的周长
func (c Circle)peri() float64{
	return c.radius * 2*math.Pi
}
// ⚪的面积
func (c Circle)area()float64{
	return math.Pow(c.radius,2)*math.Pi
}

```



### 接口的技巧

```go
var _fmt.Stringer=(*data)(nil)
```

```go
type Tester interface {
 Do()
}
type FuncDo func()
func (self FuncDo) Do() { self() }
func main() {
 var t Tester = FuncDo(func() { println("Hello, World!") })
 t.D
```

### 值接收者和指针接收者

实现了接收者是**值类型**的方法，相当于**自动实现**了接收者是**指针**类型的方法；而实现了接收者是**指针类型**的方法，**不会自动**生成对应接收者是值类型的方法。

#### 区别：

方法的接收者是**值类型**，无论调用者是对象还是指针，修改的都是**对象的副本**。 如果方法的接收者是指针类型，则调用者修改的则是对象本身

指针作为接受作者的原因：

- 方法可以直接修改接收者指向的值
- 避免每次调用方法时复制该值，在值类型为大结构体时更实用。

#### 类型转换和断言的区别

`类型转换`和`类型断言`二者本质都是把一个类型转为另一个类型，不同之处，类型**断言**是对**接口变量**进行的操作。

##### 类型转换

对于类型转换而言，转换前后的两个**类型要相互兼容**即可。

语法：

```
<结构类型>:=<目标类型>(表达式)
```

```go
package main
import "fmt"
func main() {
    var i int = 9
    var f float64
    f = float64(i)
    fmt.Printf("%T, %v\n", f, f)
    f = 10.8
    a := int(f)
    fmt.Printf("%T, %v\n", a, a)
    // s := []int(i)
}
```

`int` 型和 `float64` 是相互兼容的。

##### 断言

Go中的所有类型都实现了空接口，当一个函数的形参是`interface{}`，在函数中，需要对形参进行断言，从而得到它的真是类型。

语法： 

```
<目标类型的值>，<布尔参数> := <表达式>.( 目标类型 ) // 安全类型断言
<目标类型的值> := <表达式>.( 目标类型 )　　//非安全类型断言
```

```go
func main() {
    var i interface{} = new(Student)
    s, ok := i.(Student)
    if ok {
        fmt.Println(s)
    }
}
```

另一种方式 switch

```go
func judge(v interface{}) {
    fmt.Printf("%p %v\n", &v, v)
    switch v := v.(type) {
    case nil:
        fmt.Printf("%p %v\n", &v, v)
        fmt.Printf("nil type[%T] %v\n", v, v)
    case Student:
        fmt.Printf("%p %v\n", &v, v)
        fmt.Printf("Student type[%T] %v\n", v, v)
    case *Student:
        fmt.Printf("%p %v\n", &v, v)
        fmt.Printf("*Student type[%T] %v\n", v, v)
    default:
        fmt.Printf("%p %v\n", &v, v)
        fmt.Printf("unknow\n")
    }
}

```





```go
var i interface{} = (*Student)(nil)
```

`i` 在这里动态类型是 `(*Student)`, 数据为 `nil`，它的类型并不是 `nil`，它与 `nil` 作比较的时候，得到的结果也是 `false`。



`fmt.Println`函数的参数是`interface`：

- 对于**内置类型**，函数内部就会使用**穷举法**，得出它的真实类型，然后抓内字符串打印。
- 对于自定义类型，首先确定该类型是否实现了`String`方法，如果实现了则直接打印输出`string`中的字符串，否则，会通过反射遍历对象的成员进行遍历。

```go
func (s *Student) String() string {
    return fmt.Sprintf("[Name: %s], [Age: %d]", s.Name, s.Age)
}
```

如果接收者类型变为指针类型

打印的结果则是

```go
{qcrao 18}
```

> 类型 `T` 只有接受者是 `T` 的方法；而类型 `*T` 拥有接受者是 `T` 和 `*T` 的方法。语法上 `T` 能直接调 `*T` 的方法仅仅是 `Go` 的语法糖。

调用则需要使用：

```go
fmt.Println(&s)
```

#### 编译器自动检测类型是否实现接口

对于某些语法

```go
var _ io.Writer = (*myWriter)(nil)
```

编译器由此会检查`myWrite`类型是否实现`io.Writer`接口。

在程序中添加

```go
type myWrite struct{}

var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter{}
```

用于检测是否实现了该接口。



















