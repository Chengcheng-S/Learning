# 方法

⽅法总是绑定对象实例，并隐式将实例作为第⼀实参 (receiver)

1.  只能为当前包内命名类型定义⽅法。
2. 参数 receiver 可任意命名。如⽅法中未曾使⽤，可省略参数名
3. 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接⼝或指针。
4. 不⽀持⽅法重载，receiver 只是参数签名的组成部分。
5. 可⽤实例 value 或 pointer 调⽤全部⽅法，编译器⾃动转换。

封装、组合

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

```go
type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

附加参数P称为方法接收器(Receiver),在golang中并不像其他语言一样，使用this，self作为接收器，可以选择任意得接收其名字由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。

方法调用,接收其参数会在方法之前，如同声明时一样。即

```go
p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call
```

上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数geometry.Distance，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的Point.Distance方法。

`p.Distance`称为选择器, 其会选择合适得对应P这个对象得Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义

## 方法集

每个类型都有与之关联的⽅法集，这会影响到接⼝实现规则。

1.  • 类型 T ⽅法集包含全部 receiver T ⽅法。 

2. • 类型 *T ⽅法集包含全部 receiver T + *T ⽅法。 

3. • 如类型 S 包含匿名字段 T，则 S ⽅法集包含 T ⽅法。 

4. • 如类型 S 包含匿名字段 *T，则 S ⽅法集包含 T + *T ⽅法。 

5. • 不管嵌⼊ T 或 *T，*S ⽅法集总是包含 T + *T ⽅法。

   

   ⽤实例 value 和 pointer 调⽤⽅法 (含匿名字段) 不受⽅法集约束，编译器总是查找全部 ⽅法，并⾃动转换 receiver 实参。

## 基于指针对象的方法

当调用一个函数时，会对其每一个参数进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法。

```go
func (p *Point)ScaleBy(factor float64){
	p.X*=factor
	p.Y*=factor
}
```

一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。

只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，

```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：

```go
p.ScaleBy(2)
```

编译器会隐式地帮我们用&p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到

```go
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

`*Point`这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号`*`来取到该变量即可。编译器在这里也会给我们隐式地插入`*`这个操作符，

```go
pptr.Distance(q)
(*pptr).Distance(q)   // 两种写法等价
```

在每一个合法的方法调用表达式中，以下三种情况是合理的：

1. 不论接收器的实际参数和其接收器的形参数相同，比如两个都是类型T或者类型*T

   ```go
   Point{1, 2}.Distance(q) //  Point
   pptr.ScaleBy(2)         // *Point
   ```

2. 接收器的形参是类型T，但是接收器的实参是类型*T，这种情况下，编译器会隐式取变量地址

   ```go
   p.ScaleBy(2) // implicit (&p)
   ```

3. 接收器形参是类型`*T`，实参是`T`，编译器会隐式的解引用,取指针指向的实际变量

   ```go
   pptr.Distance(q) // implicit (*pptr)
   ```

如果类型T的所有方法都是用T类型自己来做接收器(而不是`*T`)，那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。

不管method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会做类型转换。（带指针参数的函数必须接受一个指针，而以指针为接收者的方法被调用时，接收者既能为值又能为指针）

在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次`拷贝`；第二方面是如果你用`指针类型作为receiver`，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了`拷贝`。

## 扩展类型

通过嵌入结构体来扩展类型

```go
type Point struct{ X, Y float64 }

type Color struct {
    Point
    Color color.RGBA
}
```

将point内嵌到color，使得color包含point类型所具有的一切字段通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出Point

在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中(译注：访问需要通过该指针指向的对象去取)。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。

```go
type ColoredPoint struct {
    *Point
    Color color.RGBA
}

p := ColoredPoint{&Point{1, 1}, red}
q := ColoredPoint{&Point{5, 4}, blue}
fmt.Println(p.Distance(*q.Point)) // "5"
q.Point = p.Point                 // p and q now share the same Point
p.ScaleBy(2)
fmt.Println(*p.Point, *q.Point) // "{2 2} {2 2}"
```



```go
package main

import "fmt"

func main() {
	p:=Poepele{Name: "s"}
	
	s:=Student{Age: 13}
	s.p.Name="kk"
	p.Spaec()
	s.AAA()

}


type Poepele struct {
	Name string
}

type Student struct {
	p	Poepele
	Age  int
}

func (p Poepele)Spaec(){
	fmt.Println("people,say ",p.Name)
}

func (s Student) AAA() {
	fmt.Println("STUDENT ASY",s.Age,s.p.Name)
}


```

```go
F:\GO\bin\src\demo1>go run 嵌套.go
people,say  s
STUDENT ASY 13 kk

```

读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而ColoredPoint看作其子类或者继承类，或者将ColoredPoint看作"is a" Point类型。但这是错误的理解。请注意上面例子中对Distance方法的调用。Distance有一个参数是Point类型，但q并不是一个Point类，所以尽管q有着Point这个内嵌类型，我们也必须要显式地选择它。尝试直接传q的话你会看到下面这样的错误：

```go
p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point
```

一个ColoredPoint并不是一个Point，但他"has a"Point，并且它有从Point类里引入的Distance和ScaleBy方法。

内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：

```go
func (p ColoredPoint) Distance(q Point) float64 {
    return p.Point.Distance(q)
}

func (p *ColoredPoint) ScaleBy(factor float64) {
    p.Point.ScaleBy(factor)
}
```

当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。

在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下`字段和方法会被间接地引入到当前的类型中`(访问需要通过该指针指向的对象去取)添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。

## 方法值和方法表达式

选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法"值"->一个将方法(Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器(译注：因为已经在前文中指定过了)，只要传入函数的参数即可

```go
p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // "5"
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // "2.23606797749979", sqrt(5)

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           //      then (6, 12)
scaleP(10)          //      then (60, 120)
```

在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定对象的方法，方法值会非常实用

```go
type Rocket struct { /* ... */ }
func (r *Rocket) Launch() { /* ... */ }
r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })
```

直接用方法值传入更为简洁

```go
time.AfterFunc(10 * time.Second, r.Launch)
```

与方法值相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，需要使用选择器(p.Distance)语法来指定方法的接收器。

当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数"值"，这种函数会将其第一个参数用作接收器，所以可以用通常的方式来对其进行调用：

```go
p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // "5"
fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

scale := (*Point).ScaleBy
scale(&p, 2)
fmt.Println(p)            // "{2 4}"
fmt.Printf("%T\n", scale) // "func(*Point, float64)"

// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，
// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，
// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。
// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。
```



根据选择来调用接收器各不相同的方法

```go
type Point struct{ X, Y float64 }

func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
```

## 封装

一个对象的变量或者方法如果`对调用方是不可见`的话，一般就被定义为“封装”。封装有时候也被叫做`信息隐藏`，同时也是面向对象编程最关键的一个方面。

Golang通过首字母的格式来控制可见性(小写字母的标识符不会从定义的保重导出，大写的则会导出)，这种规则适用于struct或者一个类型的方法,所以封装对象之前，需要定义成结构体。

这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。

封装的优点：

1. 因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。
2. 隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。
3. 是阻止了外部调用方对对象内部的值任意地进行修改。对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性

Counter类型允许调用方来增加counter变量的值，并且允许将这个值reset为0，但是不允许随便设置这个值

```go
type Counter struct { n int }
func (c *Counter) N() int     { return c.n }
func (c *Counter) Increment() { c.n++ }
func (c *Counter) Reset()     { c.n = 0 }
```





