# Goroutine Scheduler

調度器是運行時最核心的部分，其基本理論建立在三種基本對象上

首先 `go`關鍵詞調用都會創建一個goroutine對象，代表`G`并發任務，其次所有的G任務都有系統綫程執行，這些綫程被稱爲`M `

每個G對象都有自己獨立棧内存，儅M執行任務時，從G用來保護執行現場的字段中恢復相關寄存器值即可。儅M執行任務時，將寄存器值保存會當前G對象，然後從另一個G對象中恢復，如此實現多綫程復用

G初始化棧内存只有几kb，按照需要擴張、收縮。這種輕量級設計開銷極小，可輕鬆創建成千上午的并發任務。除此之外還有個抽象處理器`p`，其數量決定了G并發任務的數量，每個運行M都必須獲取並綁定一個p對象，如同綫程必須被調度到某個CPU Core才能執行，P還爲M提供内存分配器緩存和G任務隊列執行資源

通常情況下，p數量在初始化時確定，運行時基本固定，但是M的數量和p未必對應。例 如，某 M 因系统调⽤⻓时间阻塞，其关联 P 就会被运⾏时收回。然后，调度器会唤醒或 新建 M 去执⾏其他排队任务。失去 P 的 M 被休眠，直到被重新唤醒。



每个M可以运行各个goroutine，在结构体M的定义中有一个相对特殊的goroutine叫g0

g0特殊之处在于其是有调度栈的goroutine，“m的g0栈”。Go在执行调度相关代码时，都是使用m的g0栈，**当一个g执行的是调度相关的代码时，它并不是直接在自己的栈中执行，而是先切换到m的g0栈然后再执行代码。**

> m的g0栈是一个特殊的栈，g0的分配和普通goroutine的分配过程不同，**g0是在m建立时就生成的，并且给它分配的栈空间比较大**，可以假定它的大小是足够大而不必使用分段栈。而**普通的goroutine是在runtime.newproc时建立，并且初始栈空间分配得很小(4K)，会在需要时增长**。不仅如此，m的g0栈同时也是这个m对应的物理线程的栈。



> Go使用的是分段栈，初始栈大小很小，当发现栈不够时会动态增长。动态增长是通过进入函数时插入检测指令实现的。然而C函数不使用分段栈技术，并且假设栈是足够大的。调用cgo代码时，使用的是m的g0栈，这是一个足够大的不会发生分段的栈。



当涉及到调用系统调用之前，先调用`runtime.entersyscall`,而在特推出系统调用时，调用`runtime.exitsyscall`, 因为调度器需要维持`GOMAXPROCS`的数量，当进入系统调用时，`runtime.entersyscall`将p的M玻璃并将它设置为`PSycall`状态，告知系统此时其他的p有机会运行，以保证始终是`GOMAXPROCS`个p在运行。

因此，**Go把cgo的C函数调用像系统调用一样独立出去了，不让它影响运行时库。**goroutine也就不必参与调度了。而其它部分的goroutine正常的运行不受影响。

在退出系统调用时(和进入系统调用相反)，`runtime.exitsyscall`函数仍然检查可用的p，否则这个goroutine将被挂起，对于cgo也同样起作用，出了cgo的c函数之后会调用`runtime.exitsyscall`。

