## 分号插入规则

一个显式代码块的起始左大括号`{`不放在下一行

正式的Go语法是使用（英文）分号`;`做为结尾标识符的。大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。

#### 规则

- 在Go代码中，注释除外，如果一个代码行的最后一个语法词段（token）为下列所示之一，则一个分号将自动插入在此字段后（即行尾）：
  - 标识符
  - 整数、浮点数、虚部、码点或字符串字面量
  - break,continue, fallthrough,return 
  - 自增运算符++，或自减运算符--
  - 一个右括号},],)
- 为了允许一条复杂语句完全显示在一个代码行中，分号可能被插入在一个右小括号`)`或者右大括号`}`之前。

分号自动插入规则导致的一个结果是：自增和自减运算必须呈现为单独的语句，它们不能被当作表达式使用。 比如，下面的代码是编译不通过的：

```go
func f() {
	a := 0
	println(a++)
	println(a--)
}
```

分号自动插入规则导致的另一个结果是：我们不能在选择器中的句点`.`之前断行。 在选择器中的句点之后断行是允许的，比如：

```
anObject       // 非法
  		.MethodA()
		.MethodB()
		.MethodC()
		
		
		anObject;
		.MethodA();
		.MethodB();
		.MethodC();     // 合法
```





```go
switch alwaysFalse()
{
	case true:
		println(true)
	case false:
		println(false)
	}
```

经过go fmt 之后变为

```go
switch alwaysFalse(); {
	case true:
		println(true)
	case false:
		println(false)
	}
```

等价于

```
switch alwaysFalse();true {
	case true:
		println(true)
	case false:
		println(false)
	}
```



```go
func f() {
	switch x {
	case 1:
	{
		goto A
		A: // 这里编译没问题
	}
	case 2:
		goto B
		B: // syntax error: 跳转标签后缺少语句
	case 0:
		goto C
		C: // 这里编译没问题
	}
}
```

上述程序编译失败

```go
func f(x int) {
	switch x {
	case 1:
	{
		goto A
		A:
	;} // 一个分号插入到了这里
	case 2:
		goto B
		B: // syntax error: 跳转标签后缺少语句
	case 0:
		goto C
		C:
	;} // 一个分号插入到了这里
}
```

**原因是，根据上述第二条分号自动插入规则，编译器将在`A:`和`C:`标签声明之后的右大括号`}`字符之前插入一个分号，**

一个单独的分号实际上表示一条空语句

`A:`和`C:`标签声明之后确实跟随了一条语句的原因，所以它们是合法的。 而`B:`标签声明跟随的`case 0:`不是一条语句，所以它是不合法的。

逗号不会被自动插入



> 在Go代码中，以下断行是没问题的（不影响程序行为的）：
>
> - 在除了`break`、`continue`和`return`这几个跳转关键字之外的任何关键字之后断行，或者在不跟随标签的`break`和`continue`关键字以及不跟随返回值的`return`关键字之后断行；
> - 在（显式输入的或者隐式被编译器插入的）分号`;`之后断行；
> - 在不会导致新的隐式分号被编译器插入的情况下断行。