# 函数

不支持重載，嵌套，和默認參數，無需聲明原型，支持不定長變參，支持多返回值，支持命名返回值，支持匿名函數和閉包

函数声明包括函数名，形参列表，返回值列表(可省略)，函数体

形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。

```go
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // "5"
```

返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。 如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。

声明拥有两个int型参数的和一个int型返回值的函数，blank identifier(即_)可以强调某个参数未被使用。

```go
func add(x int, y int) int   {return x + y}
func sub(x, y int) (z int)   { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int      { return 0 }

fmt.Printf("%T\n", add)   // "func(int, int) int"
fmt.Printf("%T\n", sub)   // "func(int, int) int"
fmt.Printf("%T\n", first) // "func(int, int) int"
fmt.Printf("%T\n", zero)  // "func(int, int) int"
```

函数的类型被称为函数的标识符，。如果两个函数的形式参数和返回值列表中的变量类型一一对应，那么这两个函数被认为拥有相同的标识符和类型，形参和返回值的变量名不影响函数标识符也不影响他们是否可以以省略参数类型的形式表示。

 每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的简介引用被修改。

没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。

```go
package math

func Sin(x float64) float //implemented in assembly language
```

函数值之间是不可比较的，也不能用函数值作为map的key。



## 匿名函数

智能在包级语法块中被声明函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。

```go
strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
```

## 可变参数

参数数量可变的函数称为为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个的必备参数，之后接收任意个数的后续参数。

在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号`...`，这表示该函数会接收任意数量的该类型参数。

```go
func sum(vals...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
```

如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。

```go
values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // "10"
```

虽然在可变参数函数内部，...int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。

```go
func f(...int) {}
func g([]int) {}
fmt.Printf("%T\n", f) // "func(...int)"
fmt.Printf("%T\n", g) // "func([]int)"
```

函数接收接口类型的形参，表示该函数可以接收任意类型的参数

## Deferred 函数

在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。

defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。

## panic异常

Go的类型系统会在编译时捕获很多错误，但是有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行错误会引起panic

一般而言，当程序panic时，会立即执行在该goroutine(之后会讲，暂且理解为线程)中的被延迟函数(defer机制)，随后程序奔溃并输入日志信息。(日志信息包括panic value和函数调用的堆栈跟踪信息。) 

panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。

不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：

```go
switch s := suit(drawCard()); s {
    case "Spades":                                // ...
    case "Hearts":                                // ...
    case "Diamonds":                              // ...
    case "Clubs":                                 // ...
    default:
        panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
}
```

## Recover捕获异常

在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。

```go
func Parse(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
}
```

deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。

为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理

```go
defer func() {
        switch p := recover(); p {
        case nil:       // no panic
        case bailout{}: // "expected" panic
            err = fmt.Errorf("multiple title elements")
        default:
            panic(p) // unexpected panic; carry on panicking
        }
```





```go
package main

func fa(a,b int)(int,int){
    return a+b,a-b
}
func main(){
    fa(1,2)
}
```





```
root@LAPTOP-DLMAJDK0:d/Alet_station# go tool compile -S alertstation.go
"".fa STEXT nosplit size=28 args=0x20 locals=0x0 funcid=0x0
        0x0000 00000 (alertstation.go:72)       TEXT    "".fa(SB), NOSPLIT|ABIInternal, $0-32
        0x0000 00000 (alertstation.go:72)       FUNCDATA        $0,   gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (alertstation.go:72)       FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (alertstation.go:72)       MOVQ    "".b+16(SP), AX  
        0x0005 00005 (alertstation.go:72)       MOVQ    "".a+8(SP), CX
        0x000a 00010 (alertstation.go:72)       LEAQ    (CX)(AX*1), DX
        0x000e 00014 (alertstation.go:72)       MOVQ    DX, "".~r2+24(SP)  // 初始化第一个返回值
        0x0013 00019 (alertstation.go:72)       SUBQ    AX, CX  
        0x0016 00022 (alertstation.go:72)       MOVQ    CX, "".~r3+32(SP)  //初始化第二个返回值
        0x001b 00027 (alertstation.go:72)       RET
        0x0000 48 8b 44 24 10 48 8b 4c 24 08 48 8d 14 01 48 89  H.D$.H.L$.H...H.
        0x0010 54 24 18 48 29 c1 48 89 4c 24 20 c3              T$.H).H.L$ .
"".main STEXT nosplit size=1 args=0x0 locals=0x0 funcid=0x0
        0x0000 00000 (alertstation.go:73)       TEXT    "".main(SB), NOSPLIT|ABIInternal, $0-0
        0x0000 00000 (alertstation.go:73)       FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (alertstation.go:73)       FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (alertstation.go:73)       RET
        0x0000 c3                                               .
go.cuinfo.packagename. SDWARFCUINFO dupok size=0
        0x0000 6d 61 69 6e                                      main
""..inittask SNOPTRDATA size=24
        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        0x0010 00 00 00 00 00 00 00 00                          ........
go.info."".fa$abstract SDWARFABSFCN dupok size=24
        0x0000 04 2e 66 61 00 01 01 11 61 00 00 00 00 00 00 11  ..fa....a.......
        0x0010 62 00 00 00 00 00 00 00                          b.......
        rel 0+0 t=24 type.int+0
        rel 11+4 t=31 go.info.int+0
        rel 19+4 t=31 go.info.int+0
gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size=8
        0x0000 01 00 00 00 00 00 00 00                          ........

```



function入参的压栈顺序和Clang一致，都是从右到左，即第一个参数再栈顶的SP~SP+8 ,第二个参数则是在 SP+8~SP+16之间

从汇编代码可以看出，当前函数在执行时，首先会`mian` 函数中预留的两个返回地址置成 int 类型默认值0 ，然后根据栈的相对位置获取参数并进行加减操作，并将值存储存在栈中。 在函数返回之后，main 函数会通过一下的指令来恢复栈基址指针并销毁已经失去作用的40字节的栈空间。

```
0x0000 00000 (alertstation.go:73)       RET
```



> 将指针作为参数传入某一个函数时，在函数内部会对指针进行复制，也就是会同时出现两个指针指向原有的内存 空间，所以 Go 语言中『传指针』也是传值。

#### 总结：

- 通过堆栈传递参数，入栈的顺序是从右到左
- 函数返回值通过堆栈传递并由调用者预先分配内存空间
- 调用函数时都是值传递，接受放只会对入参进行复制再计算
- 