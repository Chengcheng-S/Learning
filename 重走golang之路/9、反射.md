# 反射

<批注，对于reflect以及unsafe两个包的应用较少，了解即可>

Golang提供了一种机制在运行时更新遍历和检查他们的值、调用他们的方法和他们支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种类型称为反射。反射也可以让我们将类型本身作为第一类型处理

反射由`reflect`包所支持，	有两个重要类型 `Value`,`Type` 一个 Type 表示一个Go类型. 它是一个接口, 有许多方法来区分类型和检查它们的组件, 例如一个结构体的成员或一个函数的参数等. 唯一能反映 reflect.Type 实现的是接口的类型描述信息,同样的实体标识了动态类型的接口值.

函数` reflect.TypeOf`接收任意的类型，并返回对应的动态类型的`reflect.Type`

```go
t := reflect.TypeOf(3)  // a reflect.Type
fmt.Println(t.String()) // "int"
fmt.Println(t)          // "int"
```

一个 reflect.Value 可以持有一个任意类型的值. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value. 和 reflect.TypeOf 类似, reflect.ValueOf 返回的结果也是对于具体的类型, 但是 reflect.Value 也可以持有一个接口值.

```go
v := reflect.ValueOf(3) // a reflect.Value
fmt.Println(v)          // "3"
fmt.Printf("%v\n", v)   // "3"
fmt.Println(v.String()) // NOTE: "<int Value>"
```

```go
var x float64 =3.4
	fmt.Println("type",reflect.TypeOf(x))
	fmt.Println("value",reflect.ValueOf(x))

	// 根据反射的值，来获取对应的类型和数值
	fmt.Println("根据反射的值获取对应的类型和数值")
	v:=reflect.ValueOf(x)
    fmt.Println("v is float",v.Kind()==reflect.Float64)
	fmt.Println("type",v.Type())
	fmt.Println("value",v.Float())
	fmt.Println("string",v.String())
```

运行结果

```go
G:\goobject\反射>go run 反射.go
type float64
value 3.4
根据反射的值获取对应的类型和数值
v is float true
type float64
value 3.4
string <float64 Value>
```

> String作为字符串返回字符串v的基础值。 //由于Go的String方法约定，String是一种特殊情况。 //与其他获取方法不同的是，如果v的Kind不是String，它不会惊慌。 //而是返回形式为“ <T value>”的字符串，其中T是v的类型。 // fmt包特别对待Values。它不会隐式调用其String //方法，而是打印它们持有的具体值。  									----reflect包说明
>
> ```go
> y.Kind()    y的种类
> y.Name() y的类型
> 
> y.Type()  y的类型
> 
> ```

逆操作是调用 reflect.ValueOf 对应的 reflect.Value.Interface 方法. 它返回一个 interface{} 类型表示 reflect.Value 对应类型的具体值:

```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface()      // an interface{}
i := x.(int)            // an int
fmt.Printf("%d\n", i)   // "3"
```

使用 reflect.Value 的 Kind 方法来替代之前的类型 switch. 虽然还是有无穷多的类型, 但是它们的kinds类型却是有限的: Bool, String 和 所有数字类型的基础类型; Array 和 Struct 对应的聚合类型; Chan, Func, Ptr, Slice, 和 Map 对应的引用类似; 接口类型; 还有表示空值的无效类型. (空的 reflect.Value 对应 Invalid 无效类型.)

## 通过反射获取复合类型的值

```go
package main

import (
	"fmt"
	"reflect"
)

type Person struct {
	name ,sex string
	age int
}
func main() {
	/*
	接口类型反射 未知类型
	 */
     p:= Person{name:"老王",age:18,sex:" 男"}
     p.Say("啊哈")
     p.PrintInfo()
     GetMessage(p)

}
func (p Person)Say(msg string){
    fmt.Println("hello  reflect",msg)

}

func (p Person)PrintInfo(){
	fmt.Printf("姓名%s,性别%s,年龄%d\n",p.name,p.sex,p.age)
}

//  获取input的信息
func GetMessage (input interface{}){
     getTpye:=reflect.TypeOf(input) // 获取input的类型
     fmt.Println("input的类型为",getTpye.Name())
     fmt.Println("input的种类为",getTpye.Kind())
     getValue:=reflect.ValueOf(input) // 获取input的值
     fmt.Println("get all filed values:",getValue.Interface())
     /*
     获取字段
     step1：先获取reflect.Type  NumFiled() 当前类型有多少字段   Filed(index) 获取每一个字段
     step2： 通过Filed获取每一个字段
     step3： Interface() 获取对应的值
      */
     for i:=0; i<getTpye.NumField();i++{

     	//  获取每一个filed
     	filed:=getTpye.Field(i)
     	value:=getValue.Field(i)
     	fmt.Println("字段的名称",filed.Name,"字段类型",filed.Type,"对应的数值",value)


     // 获取方法
     for i:=0;i<getTpye.NumMethod();i++{
     	method:=getTpye.Method(i)
     	fmt.Println("方法名称",method.Name,"方法类型",method.Type)

	 }
     }
}
```

## 通过reflect.Value修改值

所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。可以通过`reflect.ValueOf(&x).Elem()`，对&x以解引用的方式生成，指向另一个变量，是可以进行取地址操作的。来获取任意变量x对应的可取地址的Value。

```go
x := 2                   // value   type    variable?
a := reflect.ValueOf(2)  // 2       int     no
b := reflect.ValueOf(x)  // 2       int     no
c := reflect.ValueOf(&x) // &x      *int    no
d := c.Elem()            // 2       int     yes (x)

fmt.Println(a.CanAddr()) // "false"
fmt.Println(b.CanAddr()) // "false"
fmt.Println(c.CanAddr()) // "false"
fmt.Println(d.CanAddr()) // "true"
```

经验证也只有d可以获取x的地址

## 对变量的值进行修改

```go
x := 2
d := reflect.ValueOf(&x).Elem()   // d refers to the variable x
px := d.Addr().Interface().(*int) // px := &x
*px = 3                           // x = 3
fmt.Println(x)                    // "3"
```

不通过指针，而是通过`reflect.Value.Set`的方法来更新值

```go
zz:=reflect.ValueOf(&x).Elem()
	zz.Set(reflect.ValueOf(8))
	fmt.Println(x)
```

Set方法将在运行时执行和编译时类似的可赋值性约束的检查。以上代码，变量和值都是int类型，但是如果变量是int64类型，那么程序将抛出一个panic异常，所以关键问题是要确保改类型的变量可以接受对应的值：

通用对一个不可取地址的reflect.Value调用Set方法也会导致panic异常：

```go
x := 2
b := reflect.ValueOf(x)
b.Set(reflect.ValueOf(3)) // panic: Set using unaddressable value
```

## 获取结构体字段标识

```go
// Print prints the method set of the value x.
func Print(x interface{}) {
    v := reflect.ValueOf(x)
    t := v.Type()
    fmt.Printf("type %s\n", t)

    for i := 0; i < v.NumMethod(); i++ {
        methType := v.Method(i).Type()
        fmt.Printf("func (%s) %s%s\n", t, t.Method(i).Name,
            strings.TrimPrefix(methType.String(), "func"))
    }
}
```

## 修改结构体的字段值

```go
 s1:=Student{Name:"次男",Age:13,School:"小浪底"}
    vs1:=reflect.ValueOf(&s1)


    if vs1.Kind()==reflect.Ptr{
    	newvalue:=vs1.Elem()
       fmt.Println(newvalue.CanSet())
    	f1:=newvalue.FieldByName("Name")
    	f1.SetString("首男")
    	f2:=newvalue.FieldByName("School")
    	f2.SetString("大山")
    	f3:=newvalue.FieldByName("Age")
    	f3.SetInt(15)

    	fmt.Println(s1)
	}
```

```GO
package main

import (
	"fmt"
	"reflect"
)

func main(){
	u:=&Admin{
		User{UserName: "jack",Age: 18},
		"NT",
	}

	v:=reflect.ValueOf(u).Elem()
	fmt.Println(v.FieldByName("Age").Int())
	if  v.CanSet(){
		v.FieldByName("Age").SetInt(32)
	}else {
		fmt.Println("the filed can not set")
	}
	fmt.Println(u.Age)



}

type User struct {
	UserName string
	Age int
}
type Admin struct {
	User
	title string
}
```



## 通过反射调用方法

```go
调用函数
函数也可以看作接口变量类型
1、 函数————> 反射对象 value
2、kind-——>func
3、 call 调用
```

```go
value:=reflect.ValueOf(f)
value1:=reflect.ValueOf(fun2)
value2:=reflect.ValueOf(fun3)

value.Call(nil)
	value1.Call([]reflect.Value{reflect.ValueOf(3),reflect.ValueOf("日记的")})
	value2.Call([]reflect.Value{reflect.ValueOf(5),reflect.ValueOf("日的")})

```

```

func  main(){
	u:=&Admin{
		User{UserName: "jack",Age: 18},
		"NT",
	}
	v2:=reflect.ValueOf(u)   // 此處不同于修改字段的值，無需調用elem 方法
	v2.MethodByName("Say").Call(nil)
}

type User struct {
	UserName string
	Age int
}
type Admin struct {
	User
	title string
}

func (u *Admin)Say(){
	fmt.Printf("%s say my age is %d, ",u.UserName,u.Age)
}
```



## 引用类型的比较

`reflect.DeepEqual`不足之处：它将一个nil值的map和非nil值但是空的map视作不相等，同样nil值的slice 和非nil但是空的slice也视作不相等。

























