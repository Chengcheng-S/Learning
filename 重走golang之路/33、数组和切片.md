# 数组和切片

## 切片作为函数参数

slice：len 长度 ，cap 容量，array 底层数据的地址

当slice作作为参数时，可以理解为一个结构体，若直接传递slice，实参slice并不会被更改，若传递的是slice的地址，则会更改原有的slice

注：

- 无论传递的是slice还是pointer 只要底层的数组的数据更改，相应的slice的数据也会更改   *底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。*
- Go的函数传递**只有值传递**，没有引用传递

通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 `s[i]=10` 这种操作改变 slice 底层数组元素值。



```go
package main
func main() {
    s := []int{1, 1, 1}
    f(s)
    fmt.Println(s)
}
func f(s []int) {
    // i只是一个副本，不能改变s中元素的值
    /*for _, i := range s {
        i++
    }
    */
    for i := range s {
        s[i] += 1
    }
}
```

。这里传递的是一个 slice 的副本，在 `f` 函数中，`s` 只是 `main` 函数中 `s` 的一个拷贝。在`f` 函数内部，对 `s` 的作用并不会改变外层 `main` 函数的 `s`

**要想真的改变外层 `slice`，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。**

```go
package main
import "fmt"
func myAppend(s []int) []int {
    // 这里 s 虽然改变了，但并不会影响外层函数的 s
    s = append(s, 100)
    return s
}
func myAppendPtr(s *[]int) {
    // 会改变外层 s 本身
    *s = append(*s, 100)
    return
}
func main() {
    s := []int{1, 1, 1}
    newS := myAppend(s)
    fmt.Println(s)
    fmt.Println(newS)
    s = newS
    myAppendPtr(&s)
    fmt.Println(s)
}
```

> `myAppend` 函数里，虽然改变了 `s`，但它只是一个值传递，并不会影响外层的 `s`，因此第一行打印出来的结果仍然是 `[1 1 1]`。
>
> 而 `newS` 是一个新的 `slice`，它是基于 `s` 得到的。因此它打印的是追加了一个 `100` 之后的结果： `[1 1 1 100]`。
>
> 最后，将 `newS` 赋值给了 `s`，`s` 这时才真正变成了一个新的slice。之后，再给 `myAppendPtr` 函数传入一个 `s 指针`，这回它真的被改变了：`[1 1 1 100 100]`。

## 切片容量增长

使用`append`给slice增加元素

签名：

```go
func append(slice []Type,elems ...Type)[]Type
```

append 传入的是可变参数，可以追加多个值到slice中，甚至可以使用`...`传入slice 直接追加一个切片

```go
slice=append(slice,elem,elem)
slice=append(slice,anotherSlice...)
```

经过签名可知 append函数返回一个新的slice，Go不允许调用append之后不使用返回值。

**append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。**

> 使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 `len-1` 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。
>
> 此时 slice会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 `slice` 的容量是留了一定的 `buffer` 的。否则，每次添加元素的时候，都会发生迁移，成本太高。
>
> 

向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。

最后，向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。



### 向nil的slice传入数据

`nil slice` 或者 `empty slice` 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 `mallocgc` 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的`nil slice` 或 `empty slice`，然后摇身一变，成为“真正”的 `slice` 了。

## 数组和切片的异同

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

切片灵活，可以动态扩容，切片的类型和长度无关。

数组则是一片连续的内存，slice实际上就一个结构体，包含 ：len  cap array





```go
package main
import "fmt"
func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s1 := slice[2:5]
    s2 := s1[2:6:7]
    s2 = append(s2, 100)
    s2 = append(s2, 200)
    s1[2] = 20
    fmt.Println(s1)
    fmt.Println(s2)
    fmt.Println(slice)
}
```

`s1` 从 `slice` 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。`s2` 从 `s1` 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。

```go
[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]
```



![img](https://static.bookstack.cn/projects/qcrao-Go-Questions/1fc17ab1c1155a4a23fa9318be3051c5.png)
