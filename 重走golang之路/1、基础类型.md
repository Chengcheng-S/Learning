# GOlang中的基础类型 

## 整型 

有符号`int8,int16,int32,int64`    无符号类型 `u8,u16,u32,u64`

Unicode字符`rune`类型等价于`int32` ，通常表示一个Unicode码点，数据名称可以互换使用。  `byte`=====`==>`uint8`, byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

无符号的整数类型`uintptr`,没有指定具体的bit大小但是足以容纳指针，`uintptr`类型应用于底层编程，尤其时CGO或者  操作系统接口交互的地方

> 其中有符号整数采用2的补码形式表示，也就是最高bit位用作表示符号位，一个n-bit的有符号数的值域是从−2n−1-2^{n-1}−2n−1到2n−1−12^{n-1}-12n−1−1。无符号整数的所有bit位都用于表示非负数，值域是0到2n−12^n-12n−1。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。

## 运算符

 算术运算符、逻辑运算符、比较运算符、二元运算符

按照优先级递减的顺序排序：
```go
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```


二元运算符有五种优先级。在同一优先级使用左优先结合的规则，使用括号可以明确优先规则，`mask&(1<<28)`

算术运算符+,-,*,/适用于整数、浮点数、复数， 但是取模运算符%仅用于整数间的运算，在go中%取模运算的符号和被取模数的符号总是一致，因此 `-5%3`等同于`-5%-3`。 至于除法运算则是依赖于操作数是否全为整数。如 `5.0/4.0`结果为浮点型，而`5/4`  结果则为整型。因为整数的除法会向着0方向阶段玉树

计算结果溢出：

> 如果一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的，

例如 int8的例子

```go
var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
```

两个相同的正整数类型可以使用二元运算符作比较，结果而是bool类型

```go
==    equal to
!=    not equal to
<     less than
<=    less than or equal to
>     greater than
>=    greater than or equal to
```

基本类型 (bool,int，float，string)都是可以比较的，两个相同类型的值可以用二元运算符比较，此外，整数、浮点数和字符串可以根据比较结果排序。许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。对于每种类型，需要保证规则的一致性。

一元运算符

```go
+  一元加法
-  负数
```

批注： 相对于整型而言  +x则是0+x   -x 则为0-x，对于浮点数和复数  +x则是x，-x则是-x

bit位操作运算符

```
&   位运算 and
|   位运算  or
^    位运算 Xor  按位异或
&^   位清空  AND NOT
<<   左移
>>   右移
```

前四个操作符不区分符号

位操作运算符`^`作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。

位操作运算符`&^` 用于按位置零(AND NOT) 

表达式`z = x &^ y`结果z的bit位为0，如果对应y中bit位为1的话，否则对应的bit位等于x相应的bit位的值。 `如果y非零，则z为0。如果y为零，则z为x`

在`x<<n`和`x>>n`移位运算中，决定了移位操作bit数部分必须是无符号数；被操作的x数可以是有符号或无符号数。算术上，一个`x<<n`左移运算等价于乘以2n2^n2n，一个`x>>n`右移运算等价于除以2n2^n2n。

左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。

## 强制类型转换

go中不支持隐式类型转换

T(v)  对于不同类型的数值之间的运算需要强制类型转换，转为相同类型的数值才可以进行运算。   

`fmt.Printf();` 格式化输出一个数值的时候，可以使用`%d`, ` %o`  ` %x` 参数控制输出的进制格式,`%c` 参数打印 ` %q `参数打印的单引号的字符，`%T`打印参数类型,`%v`打印参数的值。

>  注 ：  请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的`[1]`副词告诉Printf函数再次使用第一个操作数。第二，%后的`#`副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。

即 ： `x := int64(0xdeadbeef)`  `fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)`

![](C:\Users\师琤琤\Desktop\数据结构\批注新解print.png)

```go
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
```

## 浮点数

fmt.Printf("%g") 打印浮点数，或者%e   %f  

float32、 float64(一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度;)

批注： 因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差

小数点前面或后面的数字可能被省略，对于很小或者很大的数，用科学计数法通过E/e 来指定指数部分 的位置。

```go
for x := 0; x < 8; x++ {
    fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
}
```

math 除了提供大量的科学函数之外，还提供了浮点数标准中的定义的特殊值的创建和测试： +∞ 以及-∞分别用于表示太大溢出的数字和除零的结果，以及NaN 非数，一边拿用于表示无效的除法操作0/0 或Sqrt(-1)

```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

math.IsNaN 用于测试一个数是否非NaN,math.NaN则返回非数对应的值.虽然可以用math.NaN来表示一个非法的结果，但是测试一个是否为NaN容易panic

注： 在浮点数中 NaN ,∞ 都不是唯一的

## 复数

Go提供了两种精度的负数类型，complex64和complex128，分别对应float32和float64两种浮点数精度，内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部

```go
var x complex128=complex(1,2)   // i+2i
var y comples128=complex(3,4)   //3+4i  
fmt.Println(x*y)     //(-5*10i)
fmt.Println(real(x*y))    //-5
fmt.Println(imag(x*y))    //10
```

复数计算法则：

```go
(a+bi)(c+di)=(ac-bd)+(bc+ad)i
(a+bi)+(c+di)=(a+c)+(b+d)i
```

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（注：浮点数的相等比较繁琐，需要特别小心处理精度问题）。

math/cmplx包提供了复数处理的函数

```go
cmplx.Sqrt(-1) 
```

## 布尔型

true  fasle  可以用&&(AND) 和||(OR)操作符结合，并且可能会有短路行为:如果运算符左边值已经可以确定这个布尔表达式的值,那么运算符右边的值将不在被求值

```go
s!="" &&  s[0]=='x'
```

其中s[0]操作如果应用于空字符串将会导致panic， 因为&&优先级高于||

(`&&`对应逻辑乘法，`||`对应逻辑加法，乘法比加法优先级要高)

注： bool 并不会隐式转换为数字0/1

## 字符串

不可更改的字节序列，字符串可以包含任意的数据，包括byte和0，文本字符串通常采用utf-8编码的Unicode码点(rune)序列。

1. 默认值是空字符串 ""。
2. ⽤索引号访问某字节，如 s[i]。
3. 不能⽤序号获取字节元素指针，&s[i] ⾮法。
4. 不可变类型，⽆法修改字节数组。
5. 字节数组尾部不包含 NULL。

`len()` 可以返回字符串中的字节数目(非rune字符数目),索引操作s[i]返回第i个字节的字节值,i必须满足o<=i<len(s).第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。

```go
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
```

字符串拼接

+将两个字符串连接，构建一个新的字符串

```go
fmt.Println("goodbye" + s[5:]) // "goodbye, world"
```

字符串可以用==和<进行比较，通过逐个字节比较完成，比较的结果为字符串自然编码的顺序

注；： 字符串不可更改，禁止修改字符串内部的数据

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。

## 常量

常量表达式的值在编译器计算，而不是在运行器，每种常量的潜在类型都是`基础类型`： `bool`  、 `string` 、 `数字`、`byte`

一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改，常量的声明类似于变量，但是不能使用`:=`声明

```go
const pi=3.1415926	

const (
	e=123
    b="name"
)
```

常量间所有的算术运算、逻辑运算以及比较运算的结构也都是常量，对常量的类型转换操作或以下函数调用的返回值都为常量：`len\cap\real\imag\complex\unsafe.Sizeof`

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。

```go
const noDelay time.Duration = 0
const timeout = 5 * time.Minute
fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"
fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
```

time.Duration是一个命名类型，底层类型时int64，time.Minute是对应的常量

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。

```go
const (
    a = 1
    b
    c = 2
    d
)
​
fmt.Println(a, b, c, d) // "1 1 2 2"
```

iota 特殊的常量，可以认为是一个可以被编译器修改的常量。iota在const关键字出现时被重置为0(conts内部的第一行起，每增加一行iota计数一次)

```go
const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
```

首个iota等于0，每当iota在新的一行被使用时，它的值会自动+1

声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认`零值`。

各种类型对应的零值

```go
bool      -> false                              
numbers -> 0                                 
string    -> ""      

pointers -> nil
slices -> nil
maps -> nil
channels -> nil
functions -> nil
interfaces -> nil
```

关于`nil`必须了解的事情

Go的文档中说到，nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值，也就是预定义好的一个变量
