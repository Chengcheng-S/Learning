# GO  Carbage collecton

GC  Garbage Collection，即垃圾回收机制，是一种自动内存管理的机制。

通常垃圾回收器的执行过程被划为两个半独立的组件：

- 赋值器：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
- 回收器： 负责执行垃圾回收的代码。

### 根对象

根对象在垃圾回收的术语中又名根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

-  全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
- 执行栈： 每个goroutine都有自己的执行栈，这些执行栈上的变量及指向分配的堆内存区块的指针
- 寄存器：寄存器的值可能表示一个指针，参与计算得到额这些指针可能指向某些赋值器分配的堆内存区块。



GC : 垃圾回收管理内存的方式

RC: 引用計數管理内存的方式



## 常见的GC模式

> - 引用计数（reference counting）每个对象维护一个引用计数器，当引用该对象的对象被销毁或者更新的时候，被引用对象的引用计数器自动减 1，当被应用的对象被创建，或者赋值给其他对象时，引用 +1，引用为 0 的时候回收，思路简单，但是频繁更新引用计数器降低性能，存在循环以引用（php，Python所使用的）
> - 标记清除（mark and sweep）就是 golang 所使用的，从根变量来时遍历所有被引用对象，标记之后进行清除操作，对未标记对象进行回收，缺点：每次垃圾回收的时候都会暂停所有的正常运行的代码，系统的响应能力会大大降低，各种 mark&swamp 变种（三色标记法），缓解性能问题。
> - 分代搜集（generation）jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为**新生代（young generation）**中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。

- 追踪式GC 
  - 从跟对象出发，根对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。
- 引用计数GC 
  - 每个对象自身包含一个被引用的计数器，当计数器归零时自动回收，因为此方法缺陷较多，在追求高性能时通常不被应用，py Objective-C 等均为引用计数GC

目前比较常见的 GC 实现方式包括：

- 追踪式，分为多种不同类型，例如：
  - 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
  - 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
  - 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
  - 增量整理：在增量式的基础上，增加对对象的整理过程。
  - 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。
- 引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。

对于golang而言GC 目前使用的是无分代(对象没有代际之分)、不整理(回收过程不对对象进行移动和整理)、并发(与用户代码并发执行)的三色 标记清扫法。

## 三色标记法

GOlang的垃圾回收机制(GC),原则：三色算法

三色抽象规定了三种不同类型的对象，并以不同颜色相称：

- 白色对象(可能死亡)：未被回收器访问的对象，子啊回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达
- 灰色对象(波面)：已被回收期访问到的对象，但回收器需要对其中的一个或者多个指针进行扫描，因为其还有可能指向白色对象
- 黑色对象(确定存活)：已被回收器访问到的对象，其中所有的字段都已经被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

这三种不变性所定义的回收过程其实是一个波面不断前进的过程，这个波面同时也是黑色和白色对象的边界，灰色对象就是波面。

> 当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程



标记-清扫GC算法，首先从一个固定的root节点开始，对于go来说就是全局指针和goroutine栈上的指针，根据这些root结点进行递归标记，当标记完成后，所有被标记的对象就都是存活的，其余的对象即是可以清扫的。

> 1. 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
> 2. 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过**逃逸分析**将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。



## STW

STW 即：stop the world，or  strat the world 常用于指代从stop the world 这一动作发生时到strat the world 这一动作发生时的时间间隔。

在GC中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。

此过程中整个用户代码被停止或者放缓执行，STW越长，对用户代码造成的影响就越大，

## 观察GO中的GC

### 一、debug.ReadGCStats

```go
import (
	"fmt"
	"runtime/debug"
	"sync"
	"time"
)
func printGCStats() {
    t := time.NewTicker(time.Second)
    s := debug.GCStats{}
    for {
        select {
        case <-t.C:
            debug.ReadGCStats(&s)
            fmt.Printf("gc %d last@%v, PauseTotal %v\n", s.NumGC, s.LastGC, s.PauseTotal)
        }
    }
}
```

每秒监听一次GC

```
gc 0 last@1970-01-01 08:00:00 +0800 CST pauseTotal 0s
gc 0 last@1970-01-01 08:00:00 +0800 CST pauseTotal 0s
gc 0 last@1970-01-01 08:00:00 +0800 CST pauseTotal 0s
```



### 二、

运行时的内存相关的API监听GC

```go
func printMemStats() {
    t := time.NewTicker(time.Second)
    s := runtime.MemStats{}
    for {
        select {
        case <-t.C:
            runtime.ReadMemStats(&s)
            fmt.Printf("gc %d last@%v, next_heap_size@%vMB\n", s.NumGC, time.Unix(int64(time.Duration(s.LastGC).Seconds()), 0), s.NextGC/(1<<20))
        }
    }
}
func main() {
    go printMemStats()
    (...)
}
```

```
gc 0 last@1970-01-01 08:00:00 +0800 CST, next_heap_size@0MB
gc 0 last@1970-01-01 08:00:00 +0800 CST, next_heap_size@0MB
gc 0 last@1970-01-01 08:00:00 +0800 CST, next_heap_size@0MB
gc 0 last@1970-01-01 08:00:00 +0800 CST, next_heap_size@0MB
gc 0 last@1970-01-01 08:00:00 +0800 CST, next_heap_size@0MB
```

### 三、go tool trace

`go tool trace` 的主要功能是将统计而来的信息以一种可视化的方式展示给用户。要使用此工具，可以通过调用 trace API：

```go
import (
	"os"
	"runtime/trace"
)


func main() {
	f,_:=os.Create("trace.out")
	defer f.Close()
	trace.Start(f)
	defer trace.Stop()
}
```

```
F:\GO\bin\src\GOGC>go tool trace trace.out
2020/09/17 10:52:59 Parsing trace...
2020/09/17 10:52:59 Splitting trace...
2020/09/17 10:52:59 Opening browser. Trace viewer is listening on http://127.0.0.1:59376
```



![gotools](C:\Users\师琤琤\Desktop\gotools.png)

直观观察go程序的运行状态。

### 四、GODEBUG=gctrace=1

Windows：

```
set GOGCTRACE=1
set GODEBUG=gctrace=1
go build name.go
```

shell中使用

```
go build -o name
GODEBUG=gctrace=1
```

 查看GC的信息

```
package main

import (
	"sync"
)



func main() {
	wg:=sync.WaitGroup{}
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			var con int
			for i := 0; i <1e10 ; i++ {
				con++
			}
		}(&wg)
	}
	wg.Wait()
}
```



```
gc 1 @2.364s 0%: 0+0.21+0 ms clock, 0+0.21/0/0.21+0 ms cpu, 4->4->0 MB, 5 MB goal, 4 P

gc 2 @2.401s 0%: 0+1.0+0 ms clock, 0+1.0/0/0+0 ms cpu, 4->4->0 MB, 5 MB goal, 4 P
gc 3 @2.426s 0%: 0+0+0 ms clock, 0+0/0/0+0 ms cpu, 4->4->0 MB, 5 MB goal, 4 P
gc 4 @3.105s 0%: 0+0.96+0 ms clock, 0+0/0.96/1.9+0 ms cpu, 4->4->0 MB, 5 MB goal, 4 P
gc 5 @3.127s 0%: 0+0.98+0 ms clock, 0+0/0/2.9+0 ms cpu, 4->4->0 MB, 5 MB goal, 4 P
# command-line-arguments
gc 1 @0.014s 9%: 0+2.9+1.0 ms clock, 0+0/2.9/4.9+4.1 ms cpu, 4->5->3 MB, 5 MB goal, 4
P
# command-line-arguments
gc 1 @0.010s 6%: 0+1.9+0 ms clock, 0+1.9/1.0/3.9+0 ms cpu, 4->5->5 MB, 5 MB goal, 4 P
gc 2 @0.021s 5%: 0+3.9+0 ms clock, 0+0/2.9/0.96+0 ms cpu, 8->9->8 MB, 10 MB goal, 4 P
gc 3 @0.029s 6%: 0+8.0+0 ms clock, 0+0/4.0/5.0+0 ms cpu, 15->16->15 MB, 17 MB goal, 4
P
gc 4 @0.112s 3%: 0+6.0+0 ms clock, 0+0.99/4.0/8.0+0 ms cpu, 28->28->17 MB, 31 MB goal,
 4 P
gc 5 @0.179s 3%: 0+9.9+0 ms clock, 0+1.0/9.9/5.0+0 ms cpu, 33->34->19 MB, 35 MB goal,
4 P
```

- gc#  gc执行的编号
- @# s   自程序启动后当前程序的秒数
- #%   程序启动后gc花费的时间百分比
- #+..+# GC标记工作共使用的CPU时间占总CPU时间的百分比
- #->#->#MB    分别表示GC启动，结束，活动时的堆大小
- #MB goal 下一次触发GC的内存占用阈值
- #P   当前使用的处理器P的数量

Go中GC 的触发条件

> 1. gcTriggerAlways: 强制触发GC
> 2. gcTriggerHeap: 当前分配的内存达到一定阈值时触发，这个阈值在每次GC过后都会根据堆内存的增长情况和CPU占用率来调整
> 3. gcTriggerTime: 当一定时间没有执行过GC就触发GC（2分钟）
> 4. gcTriggerCycle: runtime.GC()调用
>    

從根(棧就是根，掃描的起點，一些全局變量也是根，是起點)掃描，掃描完所有的根，掃描完之後成爲黑色，正在掃描的是灰色，沒有掃描的白色(垃圾)。

**回收的内存**：垃圾之對於堆上的内存，棧上的内存是編譯器管理，堆上内存是業務分配，垃圾回收器所回收。

Go中的GC算法是基于标记-清除算法(mark and sweep)

1. 标记：从程序的根节点开始，递归遍历所有对象，将能遍历的对象打上标记
2. 清除： 回收所有未标记的对象

mark and sweep 在执行时，需要暂停程序（STOP THE WORLD  STW），其中存在的问题

1. STW 程序暂停，出现卡顿
2. 标记需要扫描整个heap
3. 清除数据会产生heap碎片

go采用三色并发标记法，在标记阶段和清楚阶段都可以和应用逻辑的goroutine并发执行

- 黑色：该对象已标记，且其后代已处理
- 灰色：该对象已标记，但其后代未处理
- 白色：未被标记

初始化阶段 所有对象都是白色，从根对象开始遍历，扫面可达到的对象标记为灰色，加入灰色集合，随后扫描灰色集合，将其转为黑色，其引用对象标记为灰色，直到灰色队列为空，回收白色对象

```makefile
请注意，任何对象都不能直接从"黑色集"转到"白色集"，
操作算法，并能够清除白集中的对象。
黑色集合可以直接指向白色集合的对象。
垃圾收集开始时，所有对象都是白色的，垃圾收集器将访问所有对象
根对象的颜色是灰色的。根是可以直接的对象。
由应用程序访问，其中包括全局变量和堆栈中的其他内容。
这些对象大多依赖于特定程序的go代码，之后就是垃圾了
将收集器选取一个灰色对象，使其变为黑色，然后开始搜索以确定该对象是否为
指向白色集合的其他对象。这意味着当一个灰色对象处于时。
扫描其他对象的指针，它是黑色的。如果扫描发现这一点。
特定对象具有指向白色对象的一个或多个指针，它将该白色对象放入
灰色集合。只要在灰色集合中存在对象，这个过程就会持续下去。
白集中的对象是不可访问的，它们的内存空间可以重复使用。
这一点上，白集的元素都说是垃圾化的。
如果灰色集合的对象在垃圾中的某个点变得无法访问
收集周期，它将不会被cllcted在垃圾cllrecycde中，但是
相反，在下一个情况下!虽然这不是一个最佳的情况，但它并不坏。

```

Go的GC是并行GC，大部分是可以和用户代码同时运行的

主要分为四个阶段：

1. Mark Setup：初始化GC任务，开启写屏障和辅助GC，这个过程需要STW
2. Mark：从根对象扫描，进行标记，直到灰色队列为空，这个过程可以并行执行
3. Mark Termination：完成标记，re-scan在检查一下，因为在Mark过程中，很有可能有新的对象分配或赋值，这些都会通过写屏障记录下来，这个过程也会STW。
4. Sweep：根据标记结果，回收所有的白色对象

```makefile
第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).

第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).
```

## 内存泄漏

预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。

在 Go 中，由于 goroutine 的存在，所谓的内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。

### one

预期能被快释放的内存因被根对象引用而没有得到快速释放。

当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。

```go
var cache=map[interface{}]interface{}{}
func keepalloc(){
    for i:=0;i<10000;i++{
        m:=make([]byte,1<10)
        cache[i]=m
    }
}
```

### two

goroutine 泄漏

GOroutine作为一种逻辑上的轻量级线程。需要维护执行**用户代码的上下文**信息。在运行过程中也**需要消耗一定的内存来保存这类信息**，而这些内存在目前版本的Go中不会被释放。因此如果一个程序持续不断的产生新的goroution，且不结束已经创建的goroutine并且复用这部分内存，就会造成内存泄漏现象。

```go
func f2(){
    for i:=0;i<1000;i++{
        go func(){
            select{}
        }()
    }
}
```

使用trace查看 Heap 在持续增长，没有内存被回收，产生了内存泄漏的现象。

这种形式的 goroutine 泄漏还可能由 channel 泄漏导致。而 channel 的泄漏本质上与 goroutine 泄漏存在直接联系。

Channel 作为一种同步原语，会连接两个不同的 goroutine，**如果一个 goroutine 尝试向一个没有接收方的无缓冲 channel 发送消息，则该 goroutine 会被永久的休眠，整个 goroutine 及其执行栈都得不到释放，**

```go
var ch = make(chan struct{})
func keepalloc3() {
    for i := 0; i < 100000; i++ {
        // 没有接收方，goroutine 会一直阻塞
        go func() { ch <- struct{}{} }()
    }
}
```



## 内存屏障

垃圾回收器的正确性体现在：**不应出现对象的丢失，也不应错误的回收还不需要回收的对象。**

当满足以下条件时会破坏垃圾回收器的正确性：

-  赋值器修改对象图，导致某一黑色对象引用白色对象
- 从灰色对象出发，到达白色对象的，未经访问过的路径被赋值器破坏。

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

- 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
- 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为**强三色不变性**

当赋值器令黑色不变性定义(或者满足条件1时)的情况称为弱三色不变性。

当赋值器进一步破坏灰色对象到达白色对象的路径时，即打破弱三色不变性， 也就破坏了回收器的正确性；在破坏强弱三色不变性时必须引入额外的辅助操作。 弱三色不变形的好处在于：**只要存在未访问的能够达到白色对象的路径，就可以将黑色对象指向白色对象。**

黑色赋值器：已由回收器扫描过，不会再对其进行扫描

灰色赋值器：尚未被回收器扫描过，或尽管已经扫描过但仍需要重新扫描

赋值器颜色对回收周期的影响：

- 如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描对象图。
- 如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能在其根中插入新的非黑色的引用，如此往复，直到重新扫描过程中没有发现新的白色或灰色对象。

为了确保强弱三色不变性的并发指针更新操作，需要通过赋值器屏障技术来保证指针的读写操作一致。Go 中的写屏障、混合写屏障，其实是指赋值器的写屏障，赋值器的写屏障作为一种同步机制，使赋值器在进行指针写操作时，能够“通知”回收器，进而不会破坏弱三色不变性。

golang内存屏障也是一個演進過程

- 插入寫屏障
- 混合寫屏障(插入+刪除寫屏障)

### 屏障的本質

1. 内存屏障只對應一段特殊的程序
2. 内存屏障在**編譯期閒**生成
3. 本質上在**運行期間攔截内存寫操作**，相當於一個hook調用

### 作用

通過hook内存的寫操作時機，組織一些事情發生，從而保證垃圾回收的正確性

### 逃逸分析

只有堆上的對象的寫才可能有寫屏障

在編譯是使用`-m` 參數支持把内存可視化

```go
go build -gcflags -m name.go
```

```
# command-line-arguments
.\ccc.go:12:6: can inline funcAlloc0
.\ccc.go:16:6: can inline funcAlloc
.\ccc.go:12:17: a does not escape
.\ccc.go:13:14: new(BaseStruct) escapes to heap
.\ccc.go:16:16: b does not escape
.\ccc.go:18:15: new(BaseStruct) does not escape
.\ccc.go:22:10: new(Tstruct) escapes to heap
.\ccc.go:23:10: new(Tstruct) escapes to heap
```

### 逃逸分析的原則：

1. 保證程序正確性的前提下，盡可能把對象分配到棧上， 棧上的對象生命周期就跟隨goroutine，協程結束，生命周期結束
2. 明確一定要分配到堆上的對象，或者不確定是否要分配到堆上的對象，這種對象的生命周期始于業務程序的創建，終於垃圾回收器的回收。

13行----觸發逃逸(分配到堆上)，這個必須分配到棧上，除了這個goroutine還要存活

18行----無(分配到棧上)，雖然是new，單就分配到棧上就行，因爲b0這個對象就是一個純粹的棧對象

22行-----觸發逃逸(分配到堆上)，這個需要分配到堆上，因爲分配出來的對象需要傳遞到其他協程使用。

24 行----觸發逃逸(分配到堆上)这次必须注意下，其实站在我们上帝视角，这次的分配其实也可以分配到栈上。这种情况编译器就简单处理了，直接给分配到堆上。这种就属于编译器它摸不准的，那么分配到堆上就对了，反正也就性能有点影响，功能不会有问题，不然的话你真分配到栈上了，一旦栈被回收就出问题了

注：

1. golang傳參和返回參數都是通過棧傳遞的(支持多返回值的实现，缺点是比寄存器的方式略慢，但是这种损耗在程序的运行下可以忽略)

2. 寫屏障是一段編譯器插入的特殊代碼，在編譯期間插入码函数名字叫做 `gcWriteBarrier` 

3. 屏障代碼并不是直接運行，也是要特殊判斷，并不是只要在堆上内存複製就會運行，`cWriteBarrier` 代码，而是要有一个条件判断。这个条件判断是垃圾回收器扫描开始前，stw 程序给设置上去的。所以平时对于堆上内存的赋值，多了一次写操作

   

   


golang ABI標準，傳參用棧，返回值也是棧，特例`runtime.gcWriteBarrier`

爲了減少GC導致性能的損耗，使用了rdi,rax兩個寄存器來傳參

1. rid  堆内存寫入的地址
2. rax 賦的值

### 寫屏障

1. hook寫操作
2. hook 住了写操作之后，把赋值语句的前后两个值都记录下来，投入 buffer 队列
3. buffer 攒满之后，批量刷到扫描队列（置灰）（这是 GO 1.10 左右引入的优化）



## Go中GC流程              

|       阶段       |                            说明                            | 赋值器状态 |
| :--------------: | :--------------------------------------------------------: | :--------: |
| SweepTermination | 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障 |    STW     |
|       Mark       |         扫描标记阶段，与赋值器并发执行，写屏障开启         |    并发    |
| MarkTermination  |    标记终止阶段，保证一个周期内标记任务完成，停止写屏障    |    STW     |
|      GCoff       |    内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭    |    并发    |
|      GCoff       |    内存归还阶段，将过多的内存归还给操作系统，写屏障关闭    |    并发    |

## 触发GC时机

GO中触发GC的情形：

- 主动触发： 调用runtime.GC来触发GC，此调用阻塞式地等待当前GC运行完毕
- 被动触发：
  - 使用系统监控，当前超过两分钟没有产生任何GC时，强制触发GC
  - 使用步调(pacing)算法，其核心思想是**控制内存增长地比例**。

通过 `GOGC` 或者 `debug.SetGCPercent` 进行控制(二者控制的是同一个变量，即堆的增长率$\rho$)

> 整个算法的设计考虑的是优化问题：如果设上一次 GC 完成时，内存的数量为 $H_m$（heap marked），估计需要触发 GC 时的堆大小 $H_T$（heap trigger），使得完成 GC 时候的目标堆大小 $H_g$（heap goal） 与实际完成时候的堆大小 $H_a$（heap actual）最为接近，即： $\min |H_g - H_a| = \min|(1+\rho)H_m - H_a|$。



当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用时进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。

编译器会分析用户代码，并在需要分配内存的位置，将申请内存的操作翻译为 `mallocgc` 调用，而 `mallocgc` 的实现决定了标记辅助的实现。



## GC 关注的指标

Go 的 GC 被设计为**成比例触发**、大部分工作**与赋值器并发**、**不分代**、**无内存移动**且会**主动向操作系统归还申请的内存**。

GC 关注的自然也是印象赋值器指标

- CPU利用率:通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述的。
- GC停顿时间:STW 和 Mark Assist 两个部分可能造成的停顿
- GC停顿频率: GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。
- GC可扩展性

## GC 调优

gc调优：减少用户代码对GC产生的压力(减少用户代码分配内存的数量；最小化Go的GC对CPU的利用率，即：跳转GOGC)

情形：

- 对停顿敏感：GC过程中产生的长时间停顿、或由于需要执行GC而没有执行用户代码，导致需要立即执行的用户代码滞后
- 对资源消耗不敏感：对于频繁分配内存的应用而言，频繁分配内存增加 GC 的工作量，原本可以充分利用 CPU 的应用不得不频繁地执行垃圾回收，影响用户代码对 CPU 的利用率，进而影响用户代码的执行效率。

优化内存的申请速度，尽可能地少申请内存，复用已经申请地内存呢

### 例：合理化内存分配速度，提高赋值器地CPU利用率

> 同时创建大量 goroutine 对调度器产生的压力确实不小，不妨将这一产生速率减慢，一批一批地创建 goroutine
>
> 可以当一个 goroutine 执行完毕时，直接启动一个新的 goroutine，也就是 goroutine 池的使用。

```go
func concat() {
    wg := sync.WaitGroup{}
    for n := 0; n < 100; n++ {
        wg.Add(8)
        for i := 0; i < 8; i++ {
            go func() {
                s := "Go GC"
                s += " " + "Hello"
                s += " " + "World"
                _ = s
                wg.Done()
            }()
        }
        wg.Wait()
    }
}
```

### 降低并复用已经申请的内存



### 调整GOGC

```
 GOGC=1000 ./main
```

GC 调优过程中 `go tool pprof` 和 `go tool trace` 的强大作用是快速定位 GC 导致瓶颈的具体位置，

1. 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
2. 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
3. 需要时，增大 GOGC 的值，降低 GC 的运行频率。

## GO垃圾回收器相关的API

- runtime.GC 手动触发GC
- runtime.ReadMemStas: 读取内存相关的统计信息，其中包含部分GC相关的统计信息
- debug.FreeOSMemory：手动将内存归还给操作系统
- debug.ReadGCStats：读取关于 GC 的相关统计信息
- debug.SetGCPercent：设置 GOGC 调步变量
- debug.SetMaxHeap（尚未发布[10]）：设置 Go 程序堆的上限值

## 各大语言的GC

从原理上而言，所有的语言都能够自行实现 GC。从语言诞生之初就提供 GC 的语言，例如：

- Python
- JavaScript
- Java
- Objective-C
- Swift

而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：

- C
- C++

也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：

- Rust

垃圾回收使程序员无需手动处理内存释放，从而能够消除一些需要手动管理内存才会出现的运行时错误：

1. 在仍然有指向内存区块的指针的情况下释放这块内存时，会产生悬垂指针，从而后续可能错误的访问已经用于他用的内存区域。
2. 多重释放同一块申请的内存区域可能导致不可知的内存损坏。

当然，垃圾回收也会伴随一些缺陷，这也就造就了没有 GC 的一些优势：

1. 没有额外的性能开销
2. 精准的手动内存管理，极致的利用机器的性能

