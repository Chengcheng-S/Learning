# 编译

golang程序启动过程

1. 检查运行平台的CPU，设置好程序运行需要的相关标记
2. TLS的初始化
3. runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。
4. runtime.newproc创建新的goroutine用于绑定用户写的main方法。
5. runtime.mstart开始goroutine的调度。

main 函数新建一个线程执行**sysmon函数**，定期垃圾回收和调度抢占，启动gc；执行所有的init函数。

当main函数执行结束之后，会执行**exit(0)**来**退出程序**，若执行exit(0)之后，**进程没有退出**，main函数最后的代码**会一直访问非法地址**。

## 编译链接过程

Go源码里的编译器源码位于`src/cmd/compile`

链接器源码位于`src/cmd/link`

### 词法分析

是计算机科学中将字符序列转换为标记（token）序列的过程。进行词法分析的程序或者函数叫作**词法分析器**（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。

`.go` 文件被输入到扫描器，它使用一种类似于`有限状态机`的算法，将源代码的字符系列分割成一系列的记号（Token）。

记号一般分为这几类：关键字、标识符、字面量（包含数字、字符串）、特殊符号（如加号、等号）。

### 语法分析

生成的 Token 序列，需要经过进一步处理，生成一棵以`表达式`为结点的`语法树`。

Go 语言编译器在这一阶段检查常量、类型、函数声明以及变量赋值语句的类型，然后检查哈希中键的类型。实现类型检查的函数通常都是几千行的巨型 switch/case 语句。

**类型检查**是 Go 语言编译的第**二个**阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误。

### 中间代码生成

编译过程一般可以分为前端和后端，前端生成和平台无关的中间代码，后端会针对不同的平台，生成不同的机器码。

词法分析，语法分析，语义分析都属于编译器前端，之后的阶段属于编译器后端。

将语法树转换成中间代码，它是语法树的顺序表示。

### 链接过程

编译过程是针对单个文件进行的，文件与文件之间不可避免地要引用定义在其他模块的全局变量或者函数，这些变量或函数的地址只有在此阶段才能确定。

链接过程就是要把**编译器**生成的一个个目标文件链接成可执行文件。最终得到的文件是分成各种段的，比如数据段、代码段、BSS段等等，运行时会被装载到内存中。各个段具有不同的读写、执行属性，保护了程序的安全运行。



GoRoot： Go的安装路径

GoPath： 提供一个可以寻找go源码的路径，是一个工作空间的概念，可以设置多个目录，包含三个文件 src,bin ,pkg

## 逃逸分析

编译原理中，分析**指针动态范围**的方法称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，称这个指针发生了**逃逸**。

> 逃逸分析：由编译器决定内存分配的位置，不需要程序员指定，函数中申请一个新的对象，
>
> - 若分配在栈中，则函数执行结束可以自动将内存回收
> - 若分配在堆上，则函数结束可交给gc处理

Go语言的逃逸分析是编译器**执行静态代码分析**后，对内存管理进行的优化和简化，它可以决定一个**变量是分配到堆还栈**上。

每当函数中申请新的对象，编译器会根据对象是否被函数外部引用来决定是否逃逸：

- 若函数外部没有引用，优先放到栈中
- 外部存在引用，必定放到栈中

注：对函数外部没有引用，有可能放到堆上，如内存过大超过栈的存储能力。

逃逸分析基本原则：

​        如果一个**函数**返回对一个**变量的引用**，那么他就会发生**逃逸**。

编译器会分析**代码的特征**和代码**生命周期**，Go中的变量只有在编译器可以证明在**函数返回后不会再被引用**的，才**分配到栈**上，其他情况下都是**分配到堆**上。

Go语言里**没有一个关键字**或者**函数可以直接让变量被编译器分配到堆上**，相反，编译器通过分析代码来决定将变量分配到何处。

对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。

编译器根据是否被外部引用来决定是否逃逸：

- 函数外部没有引用，优先放置于栈
- 外部存在引用，必须放置于堆

> 堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。

通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。

### 指针逃逸

```go
package main

type S struct {
	Name string
	Age int
}
func SR(name string,age int)*S{
	s:=new(S)
	s.Age=age
	s.Name=name
	return s
}

func main() {
	SR("jim",7)
}
```

使用编译参数，查看编译过程中的逃逸分析

```
go build -gcflags=-m 
```

```
F:\GO\bin\src\gc>go build -gcflags=-m
# \gc
.\main.go:7:6: can inline SR
.\main.go:14:6: can inline main
.\main.go:15:4: inlining call to SR
.\main.go:7:9: leaking param: name
.\main.go:8:8: new(S) escapes to heap
.\main.go:15:4: new(S) does not escape
```

第八行`new(S) escapes to heap` 代表改行内存分配发生了逃逸现象。

### 栈空间不足时发生逃逸

### 动态类型逃逸

很多函数参数为interface类型，编译器很难确定其参数的类型，也会产生逃逸

```go
package main

import "fmt"

func main() {
	fmt.Println("逃逸")
}
```

```
F:\GO\bin\src\gc>go build -gcflags=-m
#/gc
.\main.go:5:6: can inline main
.\main.go:6:13: inlining call to fmt.Println
.\main.go:6:14: "逃逸" escapes to heap
.\main.go:6:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

- 栈上分配内存比在堆上分配内存具有更高的效率
- 栈上分配内存的不需要gc处理
- 堆上分配的内存在使用完毕之后交给gc处理
- 逃逸分析的目的时决定分配地址是栈还是堆
- 逃逸分析在编译期完成



### 应用

如何查看某个变量发生了逃逸？  

1、使用go命令

2、 反汇编源码

```go
package main
import "fmt"
func foo() *int {
    t := 3
    return &t;
}
func main() {
    x := foo()
    fmt.Println(*x)
}
```

1、使用go命令：

```
go build -gcflags '-m -l' main.go
```

`-l` 不然函数内联

2、 反汇编源码：

```
go tool compile -S main.go
```


















