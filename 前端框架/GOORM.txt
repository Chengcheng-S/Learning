go get -u github.com/jinzhu/gorm


连接数据库
引入驱动程序
  import _"github.com/jinzhu/gorm/dialects/mysql"
**************************************************
```go
连接mysql
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/mysql"
)

func main() {
  db, err := gorm.Open("mysql", "user:password@(localhost)/dbname?charset=utf8mb4&parseTime=True&loc=Local")
  defer db.Close()
}
```


********************************************
连接PostgreSQL 
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/postgres"
)

func main() {
  db, err := gorm.Open("postgres", "host=myhost port=myport user=gorm dbname=gorm password=mypassword")
  defer db.Close()
}

*****************************************************
连接Sqlite3
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/sqlite"
)

func main() {
  db, err := gorm.Open("sqlite3", "/tmp/gorm.db")
  defer db.Close()
}

*************************************************************
连接SQLServer
mport (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/mssql"
)

func main() {
  db, err := gorm.Open("mssql", "sqlserver://username:password@localhost:1433?database=dbname")
  defer db.Close()
}


***********************************************************************基本使用：
func main() {
	/*
	GOORM
	 */

	db,err:=gorm.Open("mysql","root:1111@(localhost)/student?charset=utf8mb4&parseTime=True&loc=Local")
	defer db.Close()
	Handlerr(err,"Open sql is failed")
	
	// 自动迁移
	db.AutoMigrate(&STU{})


	// 创建记录
	db.Create(&STU{ID:3,Name:"小昭",Age:18})


	// 查询
	var s =new(STU)
	db.First(s)
	fmt.Println("检索的s",s)


	var s3 STU
	db.Find(&s3,"name=?","id=3")
	fmt.Println(s3)
	
	// 更新
	db.Model(&s).Update("name","老王吧")
	
	time.Sleep(3*time.Second)
	// 删除
	db.Delete(&s)
	
	fmt.Println("main over")

}

func Handlerr(err error,why string){
	if err!=nil{
		fmt.Println(err,why)
	}
}

type STU struct {
	ID int
	Name string
	Age int

}

*************************************************************
GORM Model
  GORM 内置一个gorm.Model结构体, gorm.Model是一个包含了ID  CreatedAt   UpdateAt  DeleteAt 四个字段的golang结构体
// gorm.Model 定义
type Model struct {
  ID        uint `gorm:"primary_key"`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt *time.Time
}

// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中
type User struct {
  gorm.Model
  Name string
}

定义模型实例：

type User struct {
  gorm.Model
  Name         string
  Age          sql.NullInt64
  Birthday     *time.Time
  Email        string  `gorm:"type:varchar(100);unique_index"`
  Role         string  `gorm:"size:255"` // 设置字段大小为255
  MemberNumber *string `gorm:"unique;not null"` // 设置会员号（member number）唯一并且不为空
  Num          int     `gorm:"AUTO_INCREMENT"` // 设置 num 为自增类型
  Address      string  `gorm:"index:addr"` // 给address字段创建名为addr的索引
  IgnoreMe     int     `gorm:"-"` // 忽略本字段
}


结构体标记 tags  使用结构体声明模型时,标记tags是可选项, gorm支持以下标记


Column  指定列名
Type    指定数据类型
Size    指定列的大小  默认为255
PRIMARY_KEY   主键
UNIQUE       将列指定为唯一
DEFAULT      指定默认值
PERCISION    指定精度
NOTUNLL      将列指定为非null
AUTO_INCREMENT   指定为 自增类型
INDEX        创建具有或不带名称的索引，如果多个索引同名则创建符合索引
UNIQUE_INDEX  创建唯一索引
EMBEDDED      将结构设置为嵌入
EMBEDDED_PREFIX    设置嵌入结构的前缀
_             忽略此字段


关联标记
MANY2MANY        指定连接表
FOREIGNKET       外键
ASSOCIATION_FOREIGNKEY   关联外键
POLYMORPHIC               指定多态类型
POLYMORPHIC_VALUE	指定多态值
JOINTABLE_FOREIGNKEY	指定连接表的外键
ASSOCIATION_JOINTABLE_FOREIGNKEY	指定连接表的关联外键
SAVE_ASSOCIATIONS	是否自动完成 save 的相关操作
ASSOCIATION_AUTOUPDATE	是否自动完成 update 的相关操作
ASSOCIATION_AUTOCREATE	是否自动完成 create 的相关操作
ASSOCIATION_SAVE_REFERENCE	是否自动完成引用的 save 的相关操作
PRELOAD	是否自动完成预加载的相关操作




GORM默认使用ID 为表的主键

// 使用`AnimalID`作为主键
type Animal struct {
  AnimalID int64 `gorm:"primary_key"`
  Name     string
  Age      int64
}



*********************************************************************
TABLE NAME
表明默认就是结构体名称的复数
type User struct {} // 默认表名是 `users`

// 将 User 的表名设置为 `profiles`
func (User) TableName() string {
  return "profiles"
}

func (u User) TableName() string {
  if u.Role == "admin" {
    return "admin_users"
  } else {
    return "users"
  }
}

// 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`
db.SingularTable(true) 

也可以通过Table() 指定表名
// 使用User结构体创建名为`deleted_users`的表
db.Table("deleted_users").CreateTable(&User{})

var deleted_users []User
db.Table("deleted_users").Find(&deleted_users)
//// SELECT * FROM deleted_users;

db.Table("deleted_users").Where("name = ?", "jinzhu").Delete()
//// DELETE FROM deleted_users WHERE name = 'jinzhu';

GORM还支持更改默认表名称规则：
gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string  {
  return "prefix_" + defaultTableName;
}



**************************************************************
列名
COLUMN NAME
 列名由字段名称进行下划线分割来生成
type User struct {
  ID        uint      // column name is `id`
  Name      string    // column name is `name`
  Birthday  time.Time // column name is `birthday`
  CreatedAt time.Time // column name is `created_at`
}


使用结构体tag 指定列名

type Animal struct {
  AnimalId    int64     `gorm:"column:beast_id"`         // set column name to `beast_id`
  Birthday    time.Time `gorm:"column:day_of_the_beast"` // set column name to `day_of_the_beast`
  Age         int64     `gorm:"column:age_of_the_beast"` // set column name to `age_of_the_beast`
}

***************************************************************
时间戳跟踪
CreatedAt  
如果模型由CreatedAt字段,该字段的值将会是初次创建记录的时间
db.Create(&user) // `CreatedAt`将会是当前时间

// 可以使用`Update`方法来改变`CreateAt`的值
db.Model(&user).Update("CreatedAt", time.Now())


UpdateAt
该字段的值将会是每次更新记录的时间
db.Save(&user) // `UpdatedAt`将会是当前时间

db.Model(&user).Update("name", "jinzhu") // `UpdatedAt`将会是当前时间


DeleteAt 
调用delete删除该记录时,将会设置deleteat 字段为当前时间,而不是直接将记录从数据库中删除

*****************************************************
默认值 
通过tag定义字段的默认值
type User struct{
   ID int  
   Name  string `gorm:"default:`xxx`"`
   Age    int  	`gorm:"default:18"`
    
}
注： 通过tag定义字段的默认值,在创建记录时生成的sql语句会排除没有值或者值为零值的字段,在将记录插入到数据库后 Gorm会从数据库加载字段的默认值


GORM  CRUD 


db.NEWRecord(&user)// 判断主键是否为空

1、创建模型  type User struct{  ...}
2、模型与数据库中的表的对应
   db.AutoMigrate(&User)
//3，创建模型对应的数据
u:=User{....}
db.Create(&u)

***************************************************
将零值存入到数据库中
如 0、"",false
1、使用指针的方式将零值存入数据库
// 使用指针
type User struct {
  ID   int64
  Name *string `gorm:"default:'小王子'"`
  Age  int64
}
db.AutoMigrate(&User{})
user := User{Name: new(string), Age: 18))}
db.Create(&user)  // 此时数据库中该条记录name字段的值就是''


2、 使用Scanner/Valuer
// 使用 Scanner/Valuer
type User struct {
	ID int64
	Name sql.NullString `gorm:"default:'小王子'"` // sql.NullString 实现了Scanner/Valuer接口
	Age  sql.NullInt32 `gorm:"default:13"`
}
user := User{Name: sql.NullString{"", true}, Age:18}
db.Create(&user)  // 此时数据库中该条记录name字段的值就是''

*******************************************************
查询

db.Debug() 查询sql语句

var user  User
根据主键查询第一条记录
db.First(&user) // select *from user order by id limit 1
fmt.Println(stu)

随机获取一条记录
db.Take(&user)// select * from user limit 1;

根据主键查询最后一条记录
db.Last(&user) // select * from user order by id desc limit 1

查询所有的记录
db.Find(&user)// select * from user

查询指定的某条记录(仅当主键为整型是可用)
db.First(&user,10) // select * from user where id=10;

**********************************************************
where 查询
// Get first matched record
db.Where("name = ?", "jinzhu").First(&user)
//// SELECT * FROM users WHERE name = 'jinzhu' limit 1;

// Get all matched records
db.Where("name = ?", "jinzhu").Find(&users)
//// SELECT * FROM users WHERE name = 'jinzhu';

// <>
db.Where("name <> ?", "jinzhu").Find(&users)
//// SELECT * FROM users WHERE name <> 'jinzhu';

// IN
db.Where("name IN (?)", []string{"jinzhu", "jinzhu 2"}).Find(&users)
//// SELECT * FROM users WHERE name in ('jinzhu','jinzhu 2');

// LIKE
db.Where("name LIKE ?", "%jin%").Find(&users)
//// SELECT * FROM users WHERE name LIKE '%jin%';

// AND
db.Where("name = ? AND age >= ?", "jinzhu", "22").Find(&users)
//// SELECT * FROM users WHERE name = 'jinzhu' AND age >= 22;

// Time
db.Where("updated_at > ?", lastWeek).Find(&users)
//// SELECT * FROM users WHERE updated_at > '2000-01-01 00:00:00';

// BETWEEN
db.Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&users)
//// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00';

************************************************
structuct  map 查询
// Struct
db.Where(&User{Name: "jinzhu", Age: 20}).First(&user)
//// SELECT * FROM users WHERE name = "jinzhu" AND age = 20 LIMIT 1;

// Map
db.Where(map[string]interface{}{"name": "jinzhu", "age": 20}).Find(&users)
//// SELECT * FROM users WHERE name = "jinzhu" AND age = 20;

// 主键的切片
db.Where([]int64{20, 21, 22}).Find(&users)
//// SELECT * FROM users WHERE id IN (20, 21, 22);


当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为0，''，false或者其他零值时，将不会被用于构建查询条件，例如：

db.Where(&User{Name: "jinzhu", Age: 0}).Find(&users)
//// SELECT * FROM users WHERE name = "jinzhu";


可以使用指针或实现 Scanner/Valuer 接口来避免这个问题.

********************************************************
not 查询
db.Not("name", "jinzhu").First(&user)
//// SELECT * FROM users WHERE name <> "jinzhu" LIMIT 1;

// Not In
db.Not("name", []string{"jinzhu", "jinzhu 2"}).Find(&users)
//// SELECT * FROM users WHERE name NOT IN ("jinzhu", "jinzhu 2");

// Not In slice of primary keys
db.Not([]int64{1,2,3}).First(&user)
//// SELECT * FROM users WHERE id NOT IN (1,2,3);

db.Not([]int64{}).First(&user)
//// SELECT * FROM users;

// Plain SQL
db.Not("name = ?", "jinzhu").First(&user)
//// SELECT * FROM users WHERE NOT(name = "jinzhu");

// Struct
db.Not(User{Name: "jinzhu"}).First(&user)
//// SELECT * FROM users WHERE name <> "jinzhu";

****************************************************************
or条件
db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&users)
//// SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin';

// Struct
db.Where("name = 'jinzhu'").Or(User{Name: "jinzhu 2"}).Find(&users)
//// SELECT * FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2';

// Map
db.Where("name = 'jinzhu'").Or(map[string]interface{}{"name": "jinzhu 2"}).Find(&users)
//// SELECT * FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2';

*****************************************************************
内敛条件
作用与where查询类似,当内联条件与多个立即执行方法一起  内联条件不会传递给后面的立即执行方法
// 根据主键获取记录 (只适用于整形主键)
db.First(&user, 23)
//// SELECT * FROM users WHERE id = 23 LIMIT 1;
// 根据主键获取记录, 如果它是一个非整形主键
db.First(&user, "id = ?", "string_primary_key")
//// SELECT * FROM users WHERE id = 'string_primary_key' LIMIT 1;

// Plain SQL
db.Find(&user, "name = ?", "jinzhu")
//// SELECT * FROM users WHERE name = "jinzhu";

db.Find(&users, "name <> ? AND age > ?", "jinzhu", 20)
//// SELECT * FROM users WHERE name <> "jinzhu" AND age > 20;

// Struct
db.Find(&users, User{Age: 20})
//// SELECT * FROM users WHERE age = 20;

// Map
db.Find(&users, map[string]interface{}{"age": 20})
//// SELECT * FROM users WHERE age = 20;

************************************************************
额外查询选项
为查询sql添加额外的sql操作
db.Set("gorm:query_option", "FOR UPDATE").First(&user, 10)
// SELECT * FROM users WHERE id = 10 FOR UPDATE;

*********************************************************
FirstOrInit
获取匹配的第一条记录,否则根据给定的条件初始化一个新的对象，仅支持struct和map


// 未找到
db.FirstOrInit(&user, User{Name: "non_existing"})
//// user -> User{Name: "non_existing"}

// 找到
db.Where(User{Name: "Jinzhu"}).FirstOrInit(&user)
//// user -> User{Id: 111, Name: "Jinzhu", Age: 20}

db.FirstOrInit(&user, map[string]interface{}{"name": "jinzhu"})
//// user -> User{Id: 111, Name: "Jinzhu", Age: 20}

**************************************************************
Attrs 
如果未找到记录,将使用参数初始化struct
// 未找到
db.Where(User{Name: "non_existing"}).Attrs(User{Age: 20}).FirstOrInit(&user)
//// SELECT * FROM USERS WHERE name = 'non_existing';
//// user -> User{Name: "non_existing", Age: 20}

db.Where(User{Name: "non_existing"}).Attrs("age", 20).FirstOrInit(&user)
//// SELECT * FROM USERS WHERE name = 'non_existing';
//// user -> User{Name: "non_existing", Age: 20}

// 找到
db.Where(User{Name: "Jinzhu"}).Attrs(User{Age: 30}).FirstOrInit(&user)
//// SELECT * FROM USERS WHERE name = jinzhu';
//// user -> User{Id: 111, Name: "Jinzhu", Age: 20}


db.Attrs(Stu{Age:18}).FirstOrInit(&stu,Stu{Name:"换行"})
   fmt.Println(stu)

*************************************************************
Assign 
不管是否找到记录，都将参数赋值给struct
db.Assign(Stu{Age:70}).FirstOrInit(&stu,Stu{Name:"kk"})
	fmt.Println(stu)


// 未找到
db.Where(User{Name: "non_existing"}).Assign(User{Age: 20}).FirstOrInit(&user)
//// user -> User{Name: "non_existing", Age: 20}


// 找到
db.Where(User{Name: "Jinzhu"}).Assign(User{Age: 30}).FirstOrInit(&user)
//// SELECT * FROM USERS WHERE name = jinzhu';
//// user -> User{Id: 111, Name: "Jinzhu", Age: 30}



****************************************************************
FirstOrCreate
获取匹配的第一条记录，否则根据给定的条件创建一个新的记录，仅支持struct和map
db.FirstOrCreate(&stu,Stu{Name:"闭包"})

Attrs  如果未找到参数，将使用参数创建struct和记录
db.FirstOrCreate(&stu,Stu{Name:"闭包"}).Attrs(Stu{Age:20})


Assign  不管是否找到记录 均会保存到数据库
db.FirstOrCreate(&stu,Stu{Name:"闭包"}).Assign(Stu{Age:20})

*****************************************************************
select
选取部分字段
db.Select(query).Find(&user)// select query from user

db.Select([]string{"name", "age"}).Find(&users)


db.Table("users").Select("COALESCE(age,?)", 42).Rows()
//// SELECT COALESCE(age,'42') FROM users;

**********************************************************
排序
Order 指定从数据库中检索出记录的顺序，设置第二个参数reorder为true
可以覆盖前面定义的排序条件

db.Order("age desc, name").Find(&users)
//// SELECT * FROM users ORDER BY age desc, name;

// 多字段排序
db.Order("age desc").Order("name").Find(&users)
//// SELECT * FROM users ORDER BY age desc, name;

// 覆盖排序
db.Order("age desc").Find(&users1).Order("age", true).Find(&users2)
//// SELECT * FROM users ORDER BY age desc; (users1)
//// SELECT * FROM users ORDER BY age; (users2)

***********************************************************
数量 
Limit 指定从数据库检索出最大记录数

db.Limit(3).Find(&users)
//// SELECT * FROM users LIMIT 3;


// -1 取消 Limit 条件
db.Limit(10).Find(&users1).Limit(-1).Find(&users2)
//// SELECT * FROM users LIMIT 10; (users1)
//// SELECT * FROM users; (users2)

**********************************************************
偏移
Offset 指定开始返回记录前要跳过的记录数
db.Offset(3).Find(&users)
//// SELECT * FROM users OFFSET 3;


-1 取消 Offset 条件
db.Offset(10).Find(&users1).Offset(-1).Find(&users2)
//// SELECT * FROM users OFFSET 10; (users1)
//// SELECT * FROM users; (users2)



****************************************************
Count 总数 
该model能获取的记录总数
db.Where("name = ?", "jinzhu").Or("name = ?", "jinzhu 2").Find(&users).Count(&count)
//// SELECT * from USERS WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (users)
//// SELECT count(*) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (count)

db.Model(&User{}).Where("name = ?", "jinzhu").Count(&count)
//// SELECT count(*) FROM users WHERE name = 'jinzhu'; (count)

db.Table("deleted_users").Count(&count)
//// SELECT count(*) FROM deleted_users;

db.Table("deleted_users").Select("count(distinct(name))").Count(&count)
//// SELECT count( distinct(name) ) FROM deleted_users; (count)

注：
 Count 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 SELECT，但如果里面使用了 count 时不会覆盖



***************************************************************************
删除记录
db.Delete(&stu)  删除现有记录  DELETE FROM STU WHERE ID=;

为删除sql添加额外的sql操作
DB.Set("gorm:delete_option","OPTION(OPTIMIZE FOR UNKNOW)").Delete(&stu)
delete from stu where id=10 OPTION(OPTIMIZE FOR UNKNOWN)

批量处理
DB.Where("email LIke=?","%jin%").Delete(Stu{})  DELETE from emails where email LIKE "%jinzhu%";


db.Delete(Stu{},"name like ?","%jinzhu%")
DELETE from emails where email LIKE "%jinzhu%";


软删除
如果一个 model 有 DeletedAt 字段，他将自动获得软删除的功能！ 当调用 Delete 方法时， 记录不会真正的从数据库中被删除， 只会将DeletedAt 字段的值会被设置为当前时间
db.Delete(&stu)
UPDATE users SET deleted_at="2013-10-29 10:23" WHERE id = 111;

// 批量删除
db.Where("age = ?", 20).Delete(&User{})
//// UPDATE users SET deleted_at="2013-10-29 10:23" WHERE age = 20;

// 查询记录时会忽略被软删除的记录
db.Where("age = 20").Find(&user)
//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;

// Unscoped 方法可以查询被软删除的记录
db.Unscoped().Where("age = 20").Find(&users)
//// SELECT * FROM users WHERE age = 20;


物理删除
db.Unscoped().Delete(&order)
dleete from order where id=10;