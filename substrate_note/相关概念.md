## Account

Substrate 使用多组pubkey/privatekey 代表网络中的参与者，包括验证者、提名者、普通用户。

如：Substrate 节点使用NPOS算法来选择验证者。验证者和提名者可能持有大量的资金，因此Substrate Staking pallet 引入了`Account abstractions`，以此来确保资金安全。

- `Stash Key`  `Stash` 账户存入大量资金，其私钥在冷钱包
- `Controller key` `controller`代表Stash 账户发出选择信号，如支付偏好， 但应该只持有最少量的资金来支付交易费用。它的私钥应该是安全的，因为它会影响验证器设置，但会定期用于验证器维护。
- `Session Key`  保存在验证器客户端中的密钥，用于签名某些验证器的操作，此类账户不会持有代币。

### Account Keys

在 Substrate 的 Balances pallet的上下文中，这些帐户必须有一个最低金额（`existential deposit`）才能存在于存储中。

`acoount key`是通用定义的，并在runtime 具体化。

#### Stash Keys

Stash 密钥是定义 Stash 帐户的公钥/私钥对。这个账户就像一个“储蓄账户”.

由于 Stash 密钥保持离线状态，因此它指定一个 Controller 帐户以根据 Stash 帐户资金的权重做出非支出决策。它还可以指定一个代理帐户代表它在治理中投票。

#### Controller keys

在 Substrate 的 NPoS 模型的上下文中，Controller 密钥将表明一个人验证或提名的意图。

`controller keys`用于设置奖励目的地等偏好，对于验证者，用于设置其`session keys`。 Controller账户只需要支付交易费用，因此只需要最少的资金。

Controller 密钥永远不能用于从其 Stash 帐户中花费资金。但是，Controller 采取的行动可能会导致 惩罚，因此它仍然应该得到很好的保护。

## tx pool

包含广播到网络的所有已被本地节点接收和验证的交易（签名和未签名）。

检查交易有效性。事务的有效性不是硬连接到txpool的，而是由runtime定义的。

- 检查tx 的nonce
- 检查tx的费用是否足够
- 检查签名是否有效



从runtime中调用`validate_transaction` 检查有效的签名和nonce(或 UTXO链的输出)，并返回结果，是单独执行此检查的，因此它不会捕获错误，该方法不会检查`pallet`的调用是否会成功。 

validate_transaction 为txpool提供必要的信息来对交易进行排序和优先级排序，并快速拒绝所有无效或过时的交易。该函数将被频繁调用，可能会为同一事务多次调用。 validate_transaction 也有可能使依赖事务失败，如果它以正确的顺序执行，它将通过 `execute_block`。

### sort

若TX有效，txqueue将tx分为两组：

- `Ready Queue` 包含可以包含在待处理block中的tx，对于使用FRAME构建的runtime，tx必须遵循`ready queue`中的顺序。
- `Future Queue` 包含将来可能生效的tx



### tx depend

`ValidTransaction` 结构定义了需求并提供了参数来构建交易的依赖关系图,这个依赖图允许txpool产生有效的交易线性排序。

> 对于使用 FRAME 构建的运行时，节点使用基于帐户的系统对交易进行排序。每个签名的交易都需要包含一个nonce，每次进行新交易时都会增加 1。
>
> 如果 nonce > 0，FRAME 交易至少有一个提供标签编码（发送者 ++ 随机数）和一个需要编码（发送者 ++（随机数 -1））标签。如果随机数 = 0，则交易不需要任何东西。因此，来自单个发送者的所有交易将形成一个序列，它们应该被包含在其中。

### tx priority

ValidTransaction 结构中的事务优先级决定了就绪队列中事务的顺序。如果一个节点是下一个区块的作者，它将在下一个区块中从高到低的优先级对交易进行排序，直到达到该区块的权重或长度限制。

在一个事务解锁多个相关事务的情况下，优先级定义了图的线性顺序。例如，如果我们有两个（或更多）事务的依赖关系得到满足，那么我们使用优先级来为它们选择顺序。

对于使用`FRAME`构建的runtime，优先级定义为tx支付的费用：

1. 如果我们收到来自不同发送者的 2 笔交易（nonce=0），我们使用优先级来确定哪个交易更重要并首先包含在块中。
2. 如果我们从同一个节点发起 2 笔具有相同随机数的交易，则只能将一笔交易包含在链上。我们使用优先级选择费用较高的交易存储在交易池中。

> txpool不知道费用、账户或签名——它只处理交易的有效性和优先级的抽象概念，要求并提供参数。所有其他细节由运行时通过 validate_transaction 函数定义。



### tx lifecycle

tx遵循两条路径

本地产生块

- 节点监听网络上的交易
- 经过验证的tx放入到txpool
- txpool 负责对交易进行排序并返回准备好包含在块中的交易。就绪队列中的事务用于构造块。
- 执行事务并将状态更改存储在本地内存中。来自就绪队列的事务也通过网络传播到peer。
- 构建的块发布到网络。网络上的所有其他节点接收并执行该块

> 在创建块时，事务不会从就ready queue中删除，而是仅在块导入时删除。这是因为最近创作的区块可能无法进入规范链。

网络中同步到的块

验证接收到的区块

### Signed extensions

SignedExtension 是一种trait，通过它可以使用附加数据或逻辑扩展事务。签名扩展用于在执行之前需要有关交易的一些信息的任何地方。这在交易池中被大量使用。

ignedExtension 也可以用来验证未签名的交易。可以实现 *_unsigned 方法集来封装交易池所需的验证、垃圾tx和重放保护逻辑。



## Session Keys

Substrate 提供了`session pallet`，它允许验证者管理他们的`session key`

`session key` 是验证者用来签名共识相关消息的密钥。它们可以定期更换；controller只需要通过签署会话的公钥并通过外部广播此证书来创建新的session key。session key也被通用定义并在runtime具体化。

> 要创建session key，验证者必须证明密钥代表他们的 Stash 帐户（权益）和提名人行事。为此，他们通过使用controller key 对密钥进行签名来创建新的session keys。然后，他们通过在链上的交易中发布 Session certificate来通知链该密钥代表他们的控controller key。

### implementation

验证者使用会话密钥来签署与共识相关的消息。 SessionKeys 是一种通用的、可索引的类型，在运行时具体化。

> 可以声明任意数量的session key。例如，默认的 Substrate 节点使用四个。其他链可能有更多或更少，具体取决于链期望其验证者执行的操作



验证者将所有会话公钥合并到一个对象中，使用`controller`帐户签署公钥集，并提交交易以在链上注册密钥。这种链上注册将验证节点与持有资金的账户联系起来。因此，该帐户可以根据节点的行为获得奖励或惩罚。

```rust
impl_opaque_keys!{
    pub struct pub grandpa: Grandpa,
        pub babe: Babe,
        pub im_online: ImOnline,
        pub authority_discovery: AuthorityDiscovery, SessionKeys{
        
    }
}
```



```rust
mod app {
      use sp_application_crypto::{app_crypto, key_types::BABE, sr25519};
      app_crypto!(sr25519, BABE);
}
```

这些密钥也最初在创世状态中配置，以使用预先建立的验证器启动区块链。



作为节点操作员，可以使用 RPC 调用 `author_rotateKeys` 生成密钥。然后，需要使用 session.setKeys 事务在链上注册新密钥。

## TX weight

块可能包含的权重数量是有限的，可选的权重消耗（即不需要作为块的初始化或最终确定阶段的一部分部署，也不需要用于强制性固有外部的权重）通常会通过经济措施来限制 - 或简单来说，通过交易费用。权重系统的费用影响包含在交易费用文件中。

Substrate 将一个重量单位定义为 1 picosecond的执行时间，即 1012 weight = 1 秒，或 1000 weight = 1 纳秒，在固定参考硬件（Intel Core i7-7700K CPU，64GB RAM 和 NVMe SSD）上。

最大区块权重应该相当于目标区块时间的三分之一，分配三分之一用于区块构建，三分之一用于网络传播，三分之一用于导入和验证。将块时间加倍将允许最大块权重加倍。

### weight fundamentals

weight 代表你的区块链必须验证一个块的有限时间。这包括计算周期和存储 I/O。自定义实现可以使用复杂的结构来表达这一点。在substrate中 weight只是一个数值。

weight 计算方式：

- 在调度之前可计算，区块生产者应该能够在实际决定接受与否之前检查可调度的weight
- 本身消耗很少的资源，消耗计算tx weight的类似资源与执行它所花费的类似资源，权重计算应该比调度轻得多
- 无需咨询链上状态即可确定使用的资源。权重擅长表示固定测量值或仅基于可调度函数的参数的测量值，其中不需要昂贵的 I/O。当成本取决于链状态时，权重就不那么有用了。

在可调度的权重严重依赖于链状态的情况下，有两种选择：

- 确定或引入一个可调度的weight可能承受的强制上限。如果强制的上限与可调度的最小可能重量之间的差异很小，那么可以假设它始终处于重量的上限而无需咨询状态。然而，如果差异太大，那么进行较少交易的经济成本可能会太大，这将扭曲激励并导致吞吐量效率低下。
- 要求将有效权重（或可用于有效计算它的前体）作为参数传递给调度。收取的重量应基于这些参数，但也包括在发货期间验证它们所需的时间。必须进行验证以确保称重参数与链上状态准确对应，如果不正确，则操作应正常出错。

### factors

有几个因素会影响执行时间，从而影响权重计算。一个重要的因素是由可分派执行的数据库访问次数。因为数据库访问的成本在很大程度上取决于数据库后端和存储硬件，所以权重计算是参数化的，而不是数据库读取和写入的权重成本。

systme pallet 负责在执行时累计每个块的weight，确保它不超过限制，transaction payment pallet 负责解释这些weight并据此扣除费用，weight func 是runtime的一部分，因此根据需要进行升级。

### Block weight and length limit

权重系统的主要目的是防止一个块被需要太长时间才能执行的交易填充。在处理块内的事务时，`system pallet` 会累积块的总长度（以字节为单位的编码事务的总和）和块的总权重。如果这些数字中的任何一个超过限制，则该块中不接受进一步的交易。这些限制在`MaximumBlockLength`和`MaximumBlockWeight` 中定义。

## Execution

Substrate runtime 的执行由Executive模块负责（不是runtime模块，而是一个普通的rust模块，调用区块链中包含的各种runtime模块）

该模块公开了`Execute_block` 方法:

- 

- initializes 
- Executes 
- Finalizes 

### validate tx

在区块执行之前，检查签名tx的有效性

### exec block

一旦有一个有效交易的队列，executive模块开始执行该块

### Initializing a block

为初始化一个块，system 模块和所有其他包含的runtime都调用`on_initialize`方法，该方法执行由这些模块定义的任何业务逻辑，以在tx执行之前发生，模块按照它们在`construct_runtime`宏中定义的顺序执行（system 首先执行）

在区块头中的父哈希被验证为正确且外部树根实际上代表外部的地方进行初始检查。

### Executing extrinsics

在块被初始化后，每个有效的外部函数都会按照事务优先级的顺序执行。外部因素不得在运行时逻辑中引起panic，否则系统将容易受到攻击，用户可以触发计算执行而不受任何惩罚。

外部执行时，状态在执行之前不会被缓存，并且存储突变直接在存储上操作。因此，runtime开发人员应该在改变存储之前执行所有必要的检查以确保外部存储成功。如果外部在执行过程中失败，则不会恢复以前的存储突变。

从外部发出的事件也被写入存储，如果在发出event后失败，则该事件不会被还原。

### Finalize a block

在执行完所有排队的外部函数之后，Executive 模块调用每个模块的 `on_idle `和 `on_finalize` 函数来执行应该在块末尾发生的任何最终业务逻辑。模块再次按照它们在`construct_runtime!`中定义的顺序执行,system 则是最后执行

在块头中的摘要和存储根与计算的内容匹配的地方进行最终检查。

`on_idle` 会通过区块剩余的weight允许更急区块链的使用情况执行

## off-Chain

通常需要在查询/处理链下数据，然后才能将其包含在链上状态中，执行此操作的传统方法则是通过预言机，主要的缺陷则是在安全性、可扩展性和基础架构效率方面仍然存在一些缺陷。

substrate提供链下功能：

- off-chain worker (ocw) 子系统允许执行长时间运行且可能不确定的任务（如web请求、数据加密/解密和签名、随机数生成、CPU密集型计算etc）需要比块执行时间更长的时间。
- off-chain storage 节点的本地存储，可以由ocw（读取和写入访问）和链上逻辑（通过链下索引进行写入访问，但不能读取访问）访问。允许不同的线程间相互同行并不需要在整个网络上达成共识的用户和节点的特定数据。
- off-chain-index 允许runtime，独立于ocw直接写入链下存储。这用于链上逻辑的本地/临时存储，并补充其链上状态。

链下功能在 Substrate runtime之外的自己的 Wasm 执行环境中运行。这种关注点分离确保了区块生产不受长期运行的链下任务的影响。然而，由于链下特性在与运行时相同的代码中声明，它们可以轻松访问链上状态以进行计算。

### off chain workers

ocw 可以访问扩展 API 以与外部世界进行通信：

- 能够向链提交tx，发布计算的结果
- 一个功能齐全的 HTTP 客户端，允许工作人员从外部服务访问和获取数据。
- 访问本地密钥库以签署和验证语句或交易。
- 在所有ocw之间共享的附加本地kvdb
- 用于随机数生成的安全本地源
- 访问节点的精确本地时间
- 休眠和恢复工作的能力

来自ocw的结果不受常规交易验证的约束。应实施验证机制

### off chain storage

存储不存储在链上。它可以被链下工作线程（读写访问）和链上逻辑（只写，参考下面的链下索引）访问。此存储不填充在区块链网络中，也不需要对其进行共识计算。

由于在每个块导入期间都会产生一个脱链工作线程，因此在任何给定时间可能有多个脱链工作线程在运行。因此，与任何多线程编程环境类似，还有一些实用程序可以在访问存储时对存储进行互斥锁以实现数据一致性。

链下存储充当各种链下工作线程相互通信以及在链下和链上逻辑之间进行通信的桥梁。它也可以使用RPC读取，因此它适合存储无限增长数据的用例，而不会过度消耗链上存储

### off chain index

Substrate 还包括一个称为“链下索引”的功能，允许运行时独立于 OCW 直接写入链下存储。启动 Substrate 节点时，节点必须通过 --enable-offchain-indexing 标志选择加入此数据的持久性。

与在初始区块链同步期间不执行的 OCW 不同，链下索引会在每次处理块时填充存储，因此数据始终是一致的，并且对于启用索引的每个节点来说都是完全相同的。



## Account info

substrate中账户信息定义在 `frame/system/lib.rs`

```rust
#[pallet::storage]
#[pallet::getter(fn account)]
pub type Account<T: Config> = StorageMap<
	_,
	Blake2_128Concat,
	T::AccountId,
	AccountInfo<T::Index, T::AccountData>,
	ValueQuery,
>;
```



```rust
#[derive(Clone, Eq, PartialEq, Default, RuntimeDebug, Encode, Decode, TypeInfo)]
pub struct AccountInfo<Index,AccountData>{
    //账户已经发送tx的数量
    
    pub nonce :Index,
    
    //当前依赖此账户存在的其他模块的数量，在此值为零之前，该账户无法清除
    pub consumers : RefCount,
    
    //允许此彰化存在的其他模块的数量，在此之前，该账户不会被删除，并且`sufficients` 为零
    pub providers : RefCount,
    
    //允许此账户仅用于自身的模块数量，在此之前，该账户不会被删除，且`provider==0` 
    pub sufficients :RefCount,
    
    //属于此账户的附加数据，用于将余额存储在多个区块链中。
    pub data: AccountData, 
}
```



- `consumers`指模块依赖此账户的次数
- `providers` 账户是否处于active/ready 如：当创建的新账户超过现有的余额时，计数器会增加。
- `sufficients` 账户是否有任何原因可以独立存在，当账户有足够数量的某些资产，但不拥有任何本地账户余额。

> `consumer`和`provider`被设计为一起使用,`provider`告诉 Substrate pallet在该帐户处于`active`之前不要存储有关该帐户的数据（即`providers`> 0），`consumers`告诉 Substrate 在所有`pallet`中删除有关该帐户的数据之前不要删除该帐户（即`consumers` == 0）。这是为了让用户对他们存储在链上的数据负责。如果用户想要移除他们的账户并取回存在的存款，他们需要从那些链上pallet中移除依赖关系，例如为这些pallet清除存储在链上的数据，这会减少消费者的反击。 Pallets 还具有清理功能，以减少提供程序以将帐户标记为在托盘管理范围内停用。当帐户`providers`达到 0 时，前提是`consumers`此时已达到 0，该帐户被所有链上`pallet`视为停用。



runtime 可以根据frame提供的`inc_consumers()` `dec_consumers()`、`inc_providers()`、`dec_providers()`、`inc_sufficients()` 和 `dec_sufficients()`更新这些计数器。在账户的生命周期中，某个计数器的递增都应随着计数器的相应递减。

 查询功能：

- `can_inc_consumer()` 检查账户是否可用`providers >0`
- `can_dec_provider()` 在providers为0之前，检查是否在runtime不再引用账户(`consumer ==0`)
- `is_provider__required()` 检查账户是否有未完成的consumer ref(consumer >0)



### AccountData

```rust
#[derive(Encode, Decode, Clone, PartialEq, Eq, Default, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub struct AccountData<Balance> {
	
    //余额的非保留部分，对此可以有限制，原则上可以转移、保留和用于小费
    //它单独用于在合约执行环境中确定余额。
    pub free :Balance ,
    
    
    /*
    被保留的余额，这部分可以被用作偿还罚金，但是这部分资金确实最后被用于偿还的。
    
    该余额是其他子系统使用的“储备”余额，用于留出仍由帐户持有人“拥有”但可暂停的代币。这包括命名reserve和未命名reserve
    
    */
    pub reserved:Balance,
    
    
    // 取款时，free的额度不得低于tx fee以外的任何金额
    pub misc_forzen:Balnace,
    
    //转为支付tx fee，free的额度不得低于此额度
    pub fee_forzen:Balnace,
    
}
```

- `free` 未保留的余额部分，这对于大多数操作来说很重要
- `reserved` 该额度仍属于账户持有人，保留余额可以被削减，但只有在所有免费余额都被削减之后。账户的总余额是其自由余额和保留余额之和
- `misc_forzen` `fee_forzen` 表示free余额不能低于的余额。 fee_frozen 专门用于支付交易费用，而 misc_frozen 用于其他一切。实际冻结余额是这两者中的最大值，它们是在账户被锁定交易时设置的。



## Executor

executor 负责调度和执行对substrate runtime的调用。

### runtime exec

substrate runtime被编译成为本机可执行文件和wasm文件。

本机runtime作为节点可执行文件的一部分包含在内，而wasm文件存储在区块链上一个storage key下。

### Executor stragey

在runtime执行之前，Substrate客户端建议应该使用哪个运行时执行环境。这是由执行策略控制的，可以针对区块链执行过程的不同部分进行配置。这些策略在 `ExecutionStrategy `枚举中列出：

- `NativeWhenPossible`: 使用native build 否则使用wasm
- `AlwaysWasm`:仅使用wasm
- `Both`: native wasm 
- `NativeElseWasm`: 如果可能，使用native build 执行；如果失败，则使用 WebAssembly 执行。

如果native和wasm runtime不同是，则会选择wasm runtime

区块链执行过程中不同部分默认执行的策略：

- 同步：`NativeElseWasm`
- block import( non-vaild) : `nativeElseWasm`
- block import (vaildator) :`AlwaysWasm`
- block construction: `AlwaysWasm`
- off-chain worker :`NativeWhenPossible`
- other: `NativeWhenPossible`

### wasm execution

Substrate 运行时的 Wasm 表示被认为是规范运行时。因为这个 Wasm 运行时被放置在区块链存储中，所以网络必须就这个二进制文件达成共识。因此，可以验证它在所有同步节点之间是一致的。

Wasm 执行环境可能比本机执行环境更具限制性。例如，Wasm 运行时始终在具有可配置内存限制（最高 4 GB）的 32 位环境中执行

### Native execution

native 运行时只有在被选为执行策略并且与请求的运行时版本兼容时才会被执行程序使用。对于除块构造之外的所有其他执行过程，本机运行时是首选，因为它具有更高的性能。在不应运行本机可执行文件的任何情况下，都会改为执行规范的 Wasm 运行时。



## Cryptography

Substrate 中使用哈希函数将任意大小的数据映射到固定大小的值

Substrate 提供了两种开箱即用的hash算法，可以支持任何实现Hasher trait的hash算法。

#### xxHash

xxHash 是一种快速的非加密哈希函数，工作速度接近 RAM 限制。因为 xxHash 在密码学上不是安全的，所以有可能通过修改输入来合理控制散列算法的输出。这可以允许用户通过创建密钥冲突、哈希冲突和不平衡的存储尝试来攻击该算法

xxHash 用于外部各方无法操纵散列函数输入的地方。例如，它用于生成运行时存储值的密钥，其输入由运行时开发人员控制

Substrate 使用 Rust 中的 twox-hash 实现。

### Blake2

Blake2 是一个加密哈希函数。它被认为非常快，也用于 Zcash。 Substrate 使用 Rust 中的 blake2 实现。

Substrate 中使用secp256k1 曲线提供ECDSA签名，与btc、eth的加密算法相同。

Ed25519 使用Curve25519 的EdDSA签名方案。可以在不影响安全性的情况下实现非常高的速度。

SR25519 基于Ed25519相同的基础曲线，但是，其使用Schonrr 签名而不是EdDSA方案

Schnoor 签名为ECDAS/EdDSA 的特性：

- 对于分层确定性密钥派生更好
- 允许通过签名算法聚合进行本地多重签名
- 通常更耐误用

在 ECDSA 上使用 Schnorr 签名时做出的一项牺牲是两者都需要 64 个字节，但只有 ECDSA 签名才能传达其公钥。

## storge

substrate 使用kv进行数据存储，实现为数据库支持的修改后的 Merkle 树。 Substrate 的所有高级存储抽象都建立在这个简单的键值存储之上

使用`RocksBD`快速存储的数据库，用于所有需要持久化的Substrate的组件：

- 

- Substrate client
- substrate light
- off-chain workers

Substrate 使用来自 paritytech/trie 的 Base-16 Modified Merkle Patricia 树（“trie”）来提供一个 trie 结构，其内容可以修改，并且其根哈希可以有效地重新计算。

所有的 trie 节点都存储在数据库中，并且可以修剪部分 trie 状态，即当键值对超出非归档节点的修剪范围时，可以从存储中删除它

### state trie

基于 Substrate 的链有一个主树，称为状态树，其根哈希放置在每个块头中。这用于轻松验证区块链的状态，并为轻客户端验证证明提供依据。

这个 trie 只存储规范链的内容，而不是分叉。有一个单独的 state_db 层维护 trie 状态，所有非规范的引用都计入内存。

### Child trie

Substrate 还提供了一个 API 来生成具有自己的根哈希的新子尝试，这些根哈希可以在运行时使用。

子 trie 与主状态 trie 相同，只是子 trie 的根被存储和更新为主 trie 中的节点而不是块头。由于它们的标头是主状态树的一部分，因此当它包含子尝试时，仍然很容易验证完整的节点状态。





























