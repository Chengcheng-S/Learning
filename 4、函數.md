# 過程

Nim中的類似於其他語言中的函數 被命名為過程，使用關鍵字`proc`

并且要求注释它们的参数和返回类型。在类型和参数之后，一个=用来表明函数体的开始。另一点需要注意的是:过程有统一函数调用语法，这意味着可以使用foo(a, b)和a.foo(b)调用它.

### 導出符號

过程也支持封装，但是不是约定的那样如名字使用下划线而是使用*注释过程，*`*`意味着导出过程，并使它能被使用者通过模块得到.

```
proc fo*():int=3
```

### side effect 分析

Nim支持函數式編程，所以包含`{.noSideEffect}`編譯指示,它靜態確保沒有副作用

```
proc sum(x,y:int):int{.nosideEffect.}=
	x+y
	echo hello  // error proc can have sode effects
```

過程躰不能有輸出語句

### 操作符

創建一個操作符必須使用``包裹起自定義的符號，來表示他們是操作符

```
proc `^&*^@%`(a, b: string): string =
  ## A confusingly named useless operator
  result = a[0] & b[high(b)]
```

### 汎型函數

允許同模板的靜態類型檢查duck-typing語義

```
# Not really good idea for obvious reasons
let zero = ""
proc `+`(a, b: string): string =
  a & b

proc `*`[T](a: T, b: int): T =
  result = zero
  for i in 0..b:
    result = result + a

assert("a" * 10 == "aaaaaaaaaaa")
```

```
proc `?`[T](a:T,b:T):T =
    if a>b:
        a
    else:
        b 

echo 1?2
```



## result

result變量在Nim中，每一個定義的返回值的函數中都有一個**隱式**的reslut變量，reslut代表的就是返回值，一個沒有表達式的return語句表示的就是return **reslut。****如果在过程中没有return语句，那么在过程的结尾会自动返回result值。**

```python
proc sunTill(x:varargs[int]):int =
    for i in x:
       if i<0:
            return
       result=result+i

echo sunTill()
echo sunTill(1,2,3)
echo sunTill(7,5,3) 
```

该程序中形参的类型是不定参数

result变量在有返回值的过程中是默认被声明的，在没有返回值的过程中没有默认声明result。Result变量的类型与返回值的类型相同，因为它就代表返回值。Result的初始值是所属类型的初始值，像整型的话，result的初始值为0。需要注意的是，对于引用数据类型，**result的初始值将会是nil，因此在使用result时可能需要手动初始化，例如string类型**。

```
proc linkStr(x: varargs[string]): string = 
  echo result   #输出为 nil
  result = ""  #注意要初始化result，不然会出现编译错误
  for sub in x:
    result = result & sub #运算符& 链接两个字符串

echo linkStr("abc","def","ghi")
```

`&`可以連接兩個字符串類型的數據

```
proc sum(a, b: int): int =
  var result: int
  result = a + b

echo sum(1,2)   #echo  0
```

該程序輸出為0，返回的result不是后定義的，而是默認的result，**如果在函數中重新生命了變量result，他將與默認的result存在，若沒有顯式聲明`return result`則會返回默認的result而不是后定義的那個。**



如果函數中最後一句是一個沒有接受返回值的表達式，那麽程序默認返回這個值。

```
proc myproc(): int =
  var result = 10
  result + 3      #下面不能有语句了，不然会编译错误，  注意这条语句是没有接收返回值的表达式。
  
proc myproc2(): int = 
  var x = 10
  x + 3
echo myproc()  //12
echo myproc2()  //12
```



Nim提供了非常自由的調用函數的方式，對一個函數f1(a,b),調用方式有：a.f1(b)   \ f1(a,b)\a.f1  b

```
proc f1(x: int): int =
    x+1

proc f2(x: float): float =

    x-1

var z :int=1
echo f1 1 
echo z.f1
```



甚至可以定義一些運算符

```
proc `^^`(a, b: int): int = 
  #这个运算符`^^`表示a 的 b 次方,要求b为非负数 
  var n = b
  if b < 0:
    return
  elif b == 0:
    result = 1
  else:
    result = a
  while n>1:
    result = result * a
    dec(n)

echo 3 ^^ 3
echo `^^`(2,4)
```

**運算符需要“``”使用反引號包裹起來，**

使用运算符时可以像使用内置的运算符一样，也可以像使用过程的方式

## 參數

在Nim中參數有兩種類型，一種是**在函數體内不允許改變其值**的參數，另一種則是**允許改變的參數，**

不能更改值得參數是爲了讓編譯器能以最高效的方式傳參

```
prco sum(x:int):int=
	result=a+1
echo sum(1)	
```

若要嘗試修改 `x=x+1` 則會報錯

```
Error: 'x' cannot be assigned to
```

### 可變值參數

在函數中修改參數的值，在函數定義的時候，簽名部分加上`var`關鍵字

```
prco sum(x,b: var int):int=
	a=a+1
	b=b+3
	a+b
echo 1.f2 3	
```

这样就可以改变参数a和b的值了，并且这样改变了a的真实值，在sum外，a的值也随之而变。

```
proc f3(a,b:int; res,remainder:var int) =
  res=a div b 
  remainder=a mod b
var x ,y:int
f3(8,5,x,y)
assert x==1
assert y==3
```

f3中a,b是不可更改的參數，而res，remainder可以更改

注意： 傳遞給var參數的必須是一個`l-value`

l-value: 一個表達式能指定一個產生一個值或者位置的計算，產生位置的表達式就是`l-values`（var x=5, x就是一個l-value，5就不是）一个 l-value 能够表示一个位置或者这个位置包含的值，这取决于语境。**表达式的值能够被静态确定的被称为常量表达式。它们不是 l-values。let 声明的变量不是 l-values。**

var參數作爲隱式的指針實現

```
proc f3(a,b:int; res,remainder:ptr int) =
  res[]=a div b 
  remainder[]=a mod b
var x ,y:int
f3(8,5,addr(x),addr(y))
assert x==1
assert y==3
```

`ptr` 表示指針類型，調用過程中`addr()` 表示地址，var類型傳遞地址，通過指針直接修改值

### 多參數：

使用逗號分割

```
proc strAdd(str1: var string, str2: string, n: bool) = 
  if n:
    str1 = str1 & str2
var 
  str1 = "yr"
strAdd(str1,"ss",true)
echo str1
```

使用分號分割

```
proc strAdd(str1: var string; str2: string; n: bool) = 
  if n:
    str1 = str1 & str2

var 
  str1 = "yr"
strAdd(str1,"ss",true)
echo str1
```

### var return type

函數、轉換器、迭代器可能返回一個var類型，返回值是一個l-value并可以被調用者所修改

```
var g = 0

proc WriteAccessToG(): var int =
  result = g
WriteAccessToG() = 6
assert g == 6 
```



这是一个编译时错误如果隐式引入的指针可以访问一个超出它生命周期的位置:

```
proc f3():var int=
	var g=0
	result=g
Error: address of 'g' may not escape its stack frame

```

標準庫中的返回值var類型的程序名都是以`m`前綴開始的

## discard語句

可以用作多行注释，還可以用於丟棄函數的返回值(Nim中是不允許丟棄的，除非遇到discard語句)

返回值会隐式的忽略如果调用的过程或者迭代器已经使用discardable编译指示声明

```
proc f1(x,y:int):int{.discardable.}=
	return x+y
f1(3,4)  #no value	
```

也可以用於if else語句，不做任何的事情

```
var i = 2
if i == 1:
  echo i
else:
  discard
```

discard语句也可以用来创建块注释，注释部分作为描述

```
discard """

proc p(x, y: int): int {.discardable.} =
  return x + y

p(3, 4) # now valid

"""
```

### discard mannal

```
proc f1(j,l:int):int=
  j+l
discard f1(3,4)
```

discard语句评估它的表达式的其他作用，然后抛弃表达式的结果值. 不使用dicard语句而忽略过程的返回值是一个静态错误. 一个空的discard语句经常作为一个空的语句使用

## 默認值

声明过程时可以为参数设置默认值，如果调用时没有提供实参时，就会使用该参数的默认值

```
proc strAdd(str1: var string, str2: string; n: bool = true) = 
  if n:
    str1 = str1 & str2

var 
  str1 = "yr"
strAdd(str1,"ss",false)
echo str1           #echo  yr
strAdd(str1,"ss")
echo str1           #echo yrss
```

声明过程是要使用默认参数，只需在参数类型后面添加 **= 和默认值**，默认值为true。在调用过程时如果传入实参，那么形参的值就变为传入的值，如果没有提供实参，则使用参数默认值。

注：類型推斷作用于有默認值的參數

## 重載

```
proc toString(x: int): string = 
  if x != 0:
    result = $x 
  else:
    result = "zero"
proc toString(x: bool): string =
  if x: result = "true"
  else: result = "false"

echo(toString(13))   # calls the toString(x: int) proc
echo(toString(true)) # calls the toString(x: bool) proc
```

聲明了兩個相同的函數，但是參數的類型不同，從而實現了重載，編譯器會根據實參類型去選擇對應的函數

### 重載決議

在一个p(args)调用中，将选择匹配最好的p程序.如果有多个程序都能很好的匹配，则在编译时会报告歧义. 参数中的每一个参数都需要匹配。一个参数如何匹配有多种不同的匹配策略.假设f为形式参数的类型，a为实参类型.

- 精確匹配：a 和f是相同的類型
- 字面量匹配：a是一個整形字面量v，f是一個有符號或者無符號整形,并且v在f的范围中.或者:a是一个浮点字面量值v，f是一个浮点类型，并且v在f的范围内.
- 汎型匹配：f是一个泛型类型然后a匹配，(a是int,f是泛型参数类型(就如[T]或者[T:int|char]))
- 字界或子類型匹配:a是一個range[T],T正好匹配f，或者a是f的一個子類
- 整體轉換匹配：a轉到f，f和a是整型或者浮點型指針類型
- 轉換匹配：a轉到f，可以通過自定義的轉換器

優先級：确匹配高于字面量匹配，字面量匹配高于泛型匹配等.

```
proc gen[T](x: ref ref T) = echo "ref ref T"
proc gen[T](x: ref T) = echo "ref T"
proc gen[T](x: T) = echo "T"

var ri: ref int
gen(ri) # "ref T"

var rri:ref ref int
gen(rri)

var r:int
gen(r)
```



## 前置聲明

每一个变量、函數等在使用之前都需要声明。对于没有函數体的过程称为前置声明，仅仅省略=和过程体。

```
proc even(n: int): bool
```

## 匿名函數

函數可以作爲表達式，在這種情況下允許省略其名字

```nim
var myadd=proc (a,b:var int ):int =
             a=a+1
             b=b+1
             a+b
var a:int=1
var b:int=2
echo a.myadd b  		
```

```
import algorithm

var cities = @["Frankfurt", "Tokyo", "New York"]

cities.sort(proc (x,y: string): int =          
    cmp(x.len, y.len))                         #sort是一个排序过程，它的排序条件是一个参数过程。   该过程是根据字符串长度排序
echo cities

cities.sort(proc (x,y: string): int =
    cmp(x, y))                                  #该过程是根据字符串字典序排序
echo cities
```

函數作爲表達是可以出現在嵌套過程中，也可以在頂層執行

```
proc dosomething(v:int,x:proc(v:int):int):int=return x(v)
proc doSomething(v: int, x: proc(v:int)) = x(v)

echo doSomething(10, proc(v: int): int = return v div 2)
doSomething(8, proc(v: int) = (echo v))
```

### 嵌套函數

```
proc add(x: var int): int =
    x=x+1
    proc add2(x:int,y:int): int =
        result=x+y
    result= add2(x,3)

var s :int=3
echo s.add 
```
