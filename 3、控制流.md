# 控制流

## if语句

```
if expression:
	do something
```

关键词`if`后边的条件是布尔类型(**nim中的0和false以及非0和true并不等价**)

```
if x<0:
	echo $x
elif x==0:
	echo x
eise:
	echo x
```

其中elif可以有0个或多个，else部分也是可选的，如果没有else部分，当所有表达式的值为false时，结束当前if-elif-else语句的执行，执行下面的语句。If-elif-else 结构的执行顺序是先判断if条件，如果为true,则执行改作用域内的语句，否则判断elif的条件，如条件为true，则执行相应的作用域的语句，否则继续判断下一个条件。以此类推，最后如果条件都不满足，则执行else作用域内的语句。

## `case`

case语句类似于if语句，提供多分支选择结构， 关键字case后的表达式被评估，如果它的值是在关键字`of`后面的表达式里，那么就执行这个`of`分支对应的代码。如果这个值不属于任何一个给定的of列表分支，那么`else`语句部分将被执行。

如果没有else部分，并且expr可能出现的所有值并不都在一个of分支列表中，将会发生一个静态错误。这个只适用于序数类型的表达式。expr所有可能的值通过expr的类型来判定。为了解决该静态类型错误，可以使用一个带有空discard语句的else部分。

```
let name = readLine(stdin)
case name
of "":
  echo("Poor soul, you lost your name?")
of "name":
  echo("Very funny, your name is name.")
of "Dave", "Frank":
  echo("Cool name!")
else:
  echo("Hi, ", name, "!")
```

```
case n
of 0..2, 4..7: echo("The number is in the set: {0, 1, 2, 4, 5, 6, 7}")
of 3, 8: echo("The number is 3 or 8")
else: discard
```

`discard`是nim中的关键字，意味着编译器不需要做任何的动作，空的`discard`是什么也不做的声明

### case语句用于子界类型

```
type a=range[0..7]

var x :a
x=3
case x :
of 0..3:
	echo "x in 0..3"
of 4..7:
	echo "x in 4..7"
```

上述程序定义的a就是子界类型，取值范围为“0..7”

### 用于枚举类型

```
type b=enum
    c,d,e
var j:b
j=d
case j:
of c:
    echo "j is c"
of d:
    echo "j is d"
else:
    echo "j is e"   

```

使用type定义了一个b的枚举类型，有三个变体(c,d,e)

**case语句的of分支可以对一个集合或数组构造器进行评估，这个集合或数组的元素会在一个列表中展开**。

```
const
  SymChars: set[char] = {'a'..'z', 'A'..'Z', '\x80'..'\xFF'}

proc classify(s: string) =
  case s[0]
  of SymChars, '_': echo "an identifier"
  of '0'..'9': echo "a number"
  else: echo "other"

# is equivalent to:
proc classify2(s: string) =
  case s[0]
  of 'a'..'z', 'A'..'Z', '\x80'..'\xFF', '_': echo "an identifier"
  of '0'..'9': echo "a number"
  else: echo "other"
```



## while

```
while Boolean_expression:
  while_suite
```

while语句是由关键字`while`、布尔表达式和一个复合语句组成，其中复合语句称为循环体，布尔表达式为循环条件。While语句的执行规则是：

1. 计算表达式的值，如果为true时，进行2，否则进行3
2. 执行循环体，在进行
3. 结束while语句的执行

```
echo("What's your name? ")
var name = readLine(stdin)
while name == "":
  echo("Please tell me your name: ")
  name = readLine(stdin)
# no ``var``, because we do not declare a new variable here

echo("hi, ", name)
```



## `for`语句

for语句是为了遍历一个迭代器提供的所有元素的结构。for 循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环. 它的语法如下:

```
for iter_var in iterable:
    suite_to_repeat
```

每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.

for语句是一个构造去循环遍历迭代器提供的任何元素。

```
echo("Counting to ten: ")
for i in countup(1, 10):
  echo($i)
# --> Outputs 1 2 3 4 5 6 7 8 9 10 on different lines
```

使用内置的迭代器`countup`,迭代元素，然后echo，至于**`$`可以把一个整型和很多类型转为一个字符串**



```
echo("Counting down from 10 to 1: ")
for i in countup(1, 10, 2):
  echo($i)
# --> Outputs 1 3 5 7 9 on different lines
```

第三个参数则是控制迭代的步长

Nim中的for结构接受可迭代对象(str，set，array，iteor)，每次迭代其中一个元素

### 另一种便捷的形式

```
for i ,value in @[1,2,36,7]:
    echo "index ",i,"value"，vlaue
```

for语句可以使用一个或两个变量当用于一个序列的时候。当你使用一个变量的形式，这个变量将会持有序列提供的值。但是如果你使用两个变量的形式，**第一个变量将保存索引位置，第二个变量将保存值。**

## 作用域和`block`

控制流打开一个新的作用域。因此对于下面的例子中变量x在循环外是不能被访问的

```
while fasle:
	var x="jkl"
echo x	
```

一个while或for移进一个隐式的块，标识符只能在它声明的块中可见，block语句能够被用于明确的声明一个新的块

```
block myblock:
	var x="h"
echo x	 // doesn't work either
```

**作用域规则**：标识符的有效范围是从它的定义开始，一直到它的定义所在的块结束为止。标识符可知的范围就是标识符的作用域。标识符确切的作用域依赖于它声明的方式。

**block作用域**:在一个块中声明一个变量，它的有效作用域是：从变量声明开始，到这个块结束为止。如果一个块中包含另一个块，第二个块中重新声明了第一个块中的标识符，那么在这个第二个块中，第二次声明是有效的。离开内层块之后，第一个块中的声明再次有效。在相同的块中，一个标识符不能被重复声明，除非是为了过程或迭代器重载的目的才有效。

**元组对象作用域**：

- 元组或队形定义的块内
- 元组或对象类型所给的一个变量的字段标志符
- 该对象类型的所有子类型

**模块作用域**： 一个模块的所有标识符从它定义开始到这个模块结束都是有效的。来自间接依赖模块的标识符是无效的。在每一个模块中都自动导入system模块.

如果一个模块通过两个不同的模块导入一个标识符，则出现的每一个标识符都将被限制，除非它是一个重载的过程或者迭代器，在这种情况下，将会发生重载协议

```
# Module A
var x*: string
```

​         

```
# Module B
var x*: int
```

```
# Module C
import A, B
write(stdout, x) # error: x is ambiguous
write(stdout, A.x) # no error: qualifier used

var x = 4
write(stdout, x) # not ambiguous: uses the module C's x
```

上面三个模块对应于三个Nim文件，分别命名为A.nim，B.nim，C.nim。其中在A和B模块中声明的变量x后面的*，表示该模块导出该符号，则其他模块可以通过import语句导入模块使用模块中导出的符号。这里需要注意的是，如果在Windows下运行C.nim程序，C模块中的A.x 表达式要改为a.x，因为在Windows下，字母都被认为是小写。

## break

break语句能提前离开一个block，break能够用于while，for或这一个block。 使用break能离开最内层的作用域，如果break后跟着一个块名，那么将离开指定的块范围

```
block myblock:
  echo("entering block")
  while true:
    echo("looping")
    break # leaves the loop, but not the block
  echo("still in block")
  
  
  
 block myblock2:
  echo("entering block")
  while true:
    echo("looping")
    break myblock2 # leaves the block (and the loop)
  echo("still in block")
  
```

第一个break跳出了while，第二个break跳出了 block。因此运行该程序时，最后一句echo语句将不会输出。

## coutiune

一个continue语句意味着立即开始下一次迭代，它仅仅允许使用在一个循环内。

```
while true:
  let x = readLine(stdin)
  if x == "": continue
  else: echo(x)
  if x == "end": break
```



## when

**与if语句的差距**

1. when的每个条件必须是常量表达式，因为他需要经过编译器的评估
2. 在一个分支内的语句不会开启一个新的作用域
3. 编译器仅仅检查第一个被评估为true的条件语句的语义和生成代码

注：对于要注释掉一大块代码，经常使用的是when false：语句，而不是使用真正的注释，这种方式嵌套是有可能的。

```
when sizeof(int) == 2:
  echo("running on a 16 bit system!")
elif sizeof(int) == 4:
  echo("running on a 32 bit system!")
elif sizeof(int) == 8:
  echo("running on a 64 bit system!")
else:
  echo("cannot happen!")

when false:
  This is a test
  int类型在不同位数的操作系统中占有不同的字节数
```

When语句使用的是条件编译技术，作为一种特殊的语法扩展，when构造能够用于object定义中

## 迭代器

1. 只能用于for循环，
2. 不能包含return语句
3. 没有隐藏的result变量
4. 不支持递归
5. 不能被前置声明，因为编译器必须能够内联一个迭代器。

一个迭代器与一个过程类似，除了它可以在一个for循环的上下文中调用。迭代器提供一种方法来指定迭代一个抽象类型。在一个for循环执行中一个关键角色承担被调用迭代器中的yield语句。无论何时一个yield语句达到for循环变量的绑定值然后控制在for循环体中继续。在调用中自动保存迭代器的本地变量和执行状态。

```
// define exists in the system module
iterator items*(a: string): char {.inline.} =
  var i = 0
  while i < len(a):
    yield a[i]
    inc(i)
    
for ch in item("hello"):
	echo ch
```

迭代器中使用`yield`而不是return 是因为：yield仅在迭代器中有效.执行返回到for循环体叫做迭代器。**yield不是结束迭代过程，而是如果下一次迭代开始，执行将传递回迭代器。**

### 隐式的items/pairs调用

for循环表达式e并不代表一个迭代器，并且for循环正好仅有１个变量，则for循环表达式被重写为items(e);隐式的调用items迭代器:

```
for i in [1,2,3]: echo x
```

如果for循环有两个变量，隐式的调用`pairs`迭代器

### 高级迭代器

Nim中有两类迭代器：`inline`和`closure`迭代器

一个内联迭代器是一个由编译器内联的迭代器将会导致零开销的抽象，但是可能导致在代码大小上一个巨大的增加。内联迭代器是第二等公民;它们仅可以作为参数传递给其他内联工具，如模块，宏和其他内联迭代器.

与内联迭代器相反的是，可以更自由的传递闭包迭代器:

```
iterator count0(): int {.closure.} =
  yield 0

iterator count2(): int {.closure.} =
  var x = 1
  yield x
  inc x
  yield x

proc invoke(iter: iterator(): int {.closure.}) =
  for x in iter(): echo x

invoke(count0)
invoke(count2)
```

相比内联迭代器，闭包迭代器的限制：

1. 闭包迭代器中的`yield`不能出现在一个try语句中
2. 一个闭包迭代器无法再编译时估计
3. 在一个闭包迭代器中允许return语句，然后结束迭代
4. 无论是内联迭代器还是闭包迭代器都可以循环. 没有显式的标记{.closure.}或者{.inline.}的迭代器默认为内联迭代器，

迭代器类型总是隐式的调用closure约定

```
type 
	Task=iterator(ticker:int)

iterator a1(ticker: int) {.closure.} =
  echo "a1: A"
  yield
  echo "a1: B"
  yield
  echo "a1: C"
  yield
  echo "a1: D"

iterator a2(ticker: int) {.closure.} =
  echo "a2: A"
  yield
  echo "a2: B"
  yield
  echo "a2: C"

proc runTasks(t: varargs[Task]) =
  var ticker = 0
  while true:
    let x = t[ticker mod t.len]
    if finished(x): break
    x(ticker)
    inc ticker

runTasks(a1, a2)
```

内置的system.finished可以用于判断是否一个迭代器已经完成了它的操作，在试图调用一个已经完成它的工作的迭代器时不会引发异常

注：system.finished容易错误使用，因为在迭代器完成一次迭代后仅返回true

```
iterator mycount(a, b: int): int {.closure.} =
  var x = a
  while x <= b:
    yield x
    inc x

var c = mycount # instantiate the iterator
while not finished(c):
  echo c(1, 3)
```

闭包迭代器时可恢复的功能，所以必须给每一次调用都提供参数，为了解决这个限制一个外部过程可以捕获参数

```
proc mycount(a, b: int): iterator (): int =
  result = iterator (): int =
    var x = a
    while x <= b:
      yield x
      inc x

let foo = mycount(1, 4)

for f in foo():
  echo f
  
```

Nim有高级迭代器并且语法去使用它们,for循环.continue和break关键字也作用在for循环内部.这有两种类型的迭代器，和两个特殊的for循环使用方法.

### itemand pair

```
type
  TRange = object
    low: int
    high: int

iterator items(range: TRange): int =
  var i = range.low
  while i <= range.high:
    yield i
    inc i
iterator pairs(range: TRange): tuple[a: int, b: char] =
  for i in range:  # uses Range.items
    yield (i, char(i + ord('a')))

for i, c in TRange(low: 1, high: 3):
  echo c   
```

当迭代有一项的对象时，Nim调用items迭代器，它的第一个参数是你想迭代的元素类型。当调用有两项的对象时，同理，但是在这种情况下，将调用pairs迭代器。

### Operators

迭代器也可以成为标准方式的操作符，使用单反号(``)将名字扩起来。

标准库定义的silce迭代器

```
iterator `...`*[T](a: T, b: T): T =
  var res: T = T(a)
  while res <= b:
    yield res
    inc res

for i in 0...5:
  echo i
```

### Inline Iterators

内联迭代器。基本在for循环主体中然后，将它内联到迭代器中。这意味着它们没有任何函数调用开销，但是如果不小心创建可能会大幅度增加代码大小.

```
iterator countTo(n: int): int =
  var i = 0
  while i <= n:
    yield i
    inc i

for i in countTo(5):
  echo i
```

### Closure iterators

闭包迭代器保持他们的状态，可以在任何时候继续，finished() 函数可用来检查在迭代器中是否还有可用的元素，然而原生迭代器的用法是不直观的并且很容易出错。

```
proc countTo(n: int): iterator(): int =
  return iterator(): int =
    var i = 0
    while i <= n:
      yield i
      inc i
let countTo20 = countTo(20)

echo countTo20()


var output = ""
# Raw iterator usage:
while true:
  # 1. grab an element
  let next = countTo20()
  # 2. Is the element bogus? Its the end of the loop, discard it
  if finished(countTo20):
    break
  # 3. Loop body goes here:
  output.add($next & " ")

echo output

output = ""
let countTo9 = countTo(9)
for i in countTo9():
  output.add($i)
echo output
```

## 语句缩进

Nim中的简单语句和复杂语句的区别：简单语句不能包含其他语句：赋值，过程调用或return都属于简单语句。

复杂语句：if，when，for，while能包含其他的语句，为了避免歧义，符合语句总是要被缩进的，但是简单语句可以不用缩进

表达式时一个语句的一部分，这个语句通常产生一个值，if语句的条件是一个表达式的例子，在某些地方为了更好的可读性表达式能够被缩进

一般来说，在运算符、圆括号和逗号后面进行表达式缩进是被允许的

圆括号和分号可以用在只有一个表达式的语句中

```
const fac4 = (var x = 1; for i in 1..4: x *= i; x)
echo fac4

```















































