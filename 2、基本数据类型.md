# 基本数据类型

## 布爾類型

Nim中的bool被命名為bool，由預定義的true和false組成，在when，if，whie中的條件類型就是bool

运算符not、and、or、xor、<、<=、>、>=、!=、== 是为bool类型定义的。and和or运算符执行短路评估。

```
var n=0
proc Tand(): bool =
  inc(n)
  return true

if false and Tand() :
  discard
echo n           
```

if语句部分用到了逻辑运算符and，如果and的左边的第一个条件为false，那么and后面的条件将不会在去执行评估，因为不管后面的条件是true还是false，if语句的条件最终还是false。该程序将会输出0，如果把false改为true，那么将会执行Tand()部分，n的值会增加变为1。

bool類型占據1bit，是一個内置的枚舉類型，其在system中的定義為

```
type
	bool*{.magic:Bool.}=enum 
	    false=0, true=1
	    	    
```

Nim中的bool類型只有兩個值：false，true 

```
const
	on*=true
	off*=false
```

on和off也可以作为if,elif,while,when条件语句

邏輯運算符not、not、or、xor分別是非、與、或抑或

```
echo(not false)
echo(true and false)
echo(false or true)
echo(true xor false)
echo(true xor true)
```

```
ord(false) == 0 and ord(true) == 1
```

`ord()`過程返回序數類型的下表值，即爲索引值

## 字符類型

在Nim中的字符類型用關鍵字`char`聲明，大小為1bit，在nim中能夠使用`==,>=,<,<=`運算符比較，運算符`$`能夠轉換一個字符為字符串，字符不能混整形，可以使用`ord`函數來得到一個字符的序列值，使用`chr`過程轉換一個整數為一個字符

```
var 
    a:char='a'
    s:char='b'
    c:int=120
echo a.ord ,"\n",c.char 
echo a>s
```

Nim可以有效支持array[char,int]或者set[cahr]

```
var aValue:array['a'..'z',int]

for i in 'a'..'z':
   aValue[i]=int(i)


for i in 'a'..'z':
   echo aValue[i]
```

## 字符串類型

所有字符串字面值都是string，Nim中的字符串和一個字符序列十分相似，在Nim中字符**是可變的**，

字符串都是以\0结束的，也有一个长度字段。可以通过内置的`len`过程来检索字符串的长度，这个长度是字符串所占的字节数。字符串长度不包括末尾的\0。是可以访问末尾的\0的，并且经常会使代码更简单

```
var str:string="yrs"
str[2]='k'
echo str   // yrk
```

字符串可以通过**赋值运算符=来复制一个字符串** **使用&連接字符串**，或者使用`add`拼接字符串

```
var
  str1 = "yrs"
  str2 = "abc"
  str3: string

str3 = str1         #通过赋值运算复制一个字符串，深拷贝
echo "str3 = ", str3
```

字符串可以通過字典序列來比較，所有的比较运算符都是可以使用的

字符串变量被初始化为一个特殊的值：nil。然而，大部分字符串运算符不能处理nil，如果处理nil将会引发一个异常。空值字符串应该用""表示，而不是nil。但是""经常在堆上创建一个字符串，因此这里就需要权衡了。

大多数Nim本地类型都支持通过$过程转化成字符串

ceho $3



## 数值类型

### 整型

```
内置整型：
int, int8,int16, int32,int64, uint  uint8  uint16  uint32  uint64
```

默认的整型是int，int所占字节的大小依赖于平台，**操作系统是64位的占8个字节，32位的操作系统占4个字节。**

int后面带数字的类型是其他的整型，后面数字表示它们有多少位，**int8、int16、int32、int64数据类型分别有8、16、32、64位，所占字节数也就分别是1、2、4、8个字节。**

無符號整型，不會產生上溢或下溢的錯誤

整型常量可以有有一個類型後綴來標記他們的其他的整型類型，有符號數用後綴`iXX`,無符號則是`uXX`,  使用整型計算内存中的對象, **int和一個指針大小相同**

```
let
  x = 0           # x is of type ``int``
  y = 0'i8        # y is of type ``int8``
  z = 0'i64       # z is of type ``int64``
  u = 0'u         # u is of type ``uint``
  v = 0'u8        # v is of type ``uint8`` 
```

一般的运算符 +、- 、*、div、mod、<、<=、==、!=、>、>= 都能用于整型，逻辑运算符 and、or、xor、not 也可以用于整型，提供按位运算。按位左移使用shl，按位右移使用shr运算符。位移运算符认为它们是无符号数。对于算术位移（有符号数的位移）通常使用乘法或者除法。

```python
let
  a = 11
  b = 4

echo "a + b = ", a + b 
echo "a - b = ", a - b
echo "a * b = ", a * b
echo "a / b = ", a / b
echo "a div b = ", a div b
echo "a mod b = ", a mod b
```

在Nim中只有擴大的類型轉換是隱式，縮小類型轉換壓迫進行强制類型轉換

```
var 
  x = 3'i8
  y = 4'i16

y = x
echo y
x = int8(y)         #强制类型转换
echo x
```

`sizeof()`返回參數所占據字節的大小

### 浮点数

Nim中的内置浮點數： float float32 float64(8bit) 

默認是float，Float后面带有数字的类型，数字表示对应的位宽。float字面量能够使用后缀来标记以区别不同类型

```
var
   x=0.0
   y=0.1'float64
   z=0.0'float32
```

浮点型也会自动类型转换，同样是较小的转向较大类型,整型不会自动转换为浮点型，反之亦然。可以使用toInt和toFloat过程来整型和浮点型

```
var
  x:int = 1
  y:float = 2.2

x = toInt(y)
echo x

y = toFloat(1)
echo y
```

#### IEEE標準的五種浮點數據類型異常：

1. 無效的：數學上的無效的操作，例如`0.0/0.0`  sqrt(-1.0) ,log(-37.8)
2. 除以0： 除數是0并且被除數是非零的有限數。eg：1.0/0.0
3. 上溢出： 操作產生的結果超出指數範圍
4. 下溢出： 操作產生的結果太小以至於不能用一個正常的表達式`MINDOUBLE*`
5. 不精確：操作產生的結果不能用無限精度表示    

## 類型轉換

在Nim中通過使用類型作爲一個函數來轉換不同的基本數據類型

```
var x:folat=3.0
y:int=int(x)


var
  a,b:int=5
  c,d:float=5.0
  e,f:int32=5

#使用类型名进行类型转换
assert(a==(int)e)
assert(a==(int)c)
assert(d==(float)b)
assert(f==(int32)d)

#使用过程进行类型转换
assert(a==toInt(c))
assert(d==toFloat(e))


#使用cast进行类型转换
#assert(a==cast[int](c))
echo cast[int](c)
echo cast[float](a)
```

### type casts

```
case[int](x)
```

case是關鍵字，[int]則是要轉換的類型，x則是轉換后的類型

### 類型轉換和推斷

Nim是一种静态类型语言。因此,每一个变量都有一个与它关联的类型.如前面的例子中这些类型通过编译器使用const,let,var声明推断.

```
var x=5
var y="foo"

x=y  // 給一個變量複製一個不同的類型值將會導致編譯時錯誤
```

一个冒号后面指定类型。在某些情况下编译器期望你显式的类型转换，对于这种情况两种方法可以使用:

1. 類型轉換：將被編譯器安全檢查
2. cast關鍵字，非安全

```
var x = int(1.0 / 3)   # 类型转换

var y = "Foobar"
proc ffi(foo: ptr array[6, char]) = 
  echo repr(foo)
ffi(cast[ptr array[6, char]](addr y[0]))
```

## 内部類型表達式

調試複雜類型 `repr`(作用與任何類型甚至是帶有周期的複雜數據圖)

```
type 
    person =object
      x:int 
      y:string

var p:person
p.x=32
p.y="jinh"
echo p.repr
```

```
[x = 32,
y = 000000000016F0F8"jinh"]
```

## 運算符

Nim中的語法分析器可以通過中綴表示法(a+b)或者前綴表示法(+a)使用運算符

一个中缀运算符总是接收两个参数，一个前缀运算符总是接收一个参数。沒有後綴運算符

### 優先級

nim允许用户自定义操作符。二元操作符有11个不同层次的优先级。

- 第一個字符是**`^`的二元操作符是右結合性**，其他的所有二元操作符都是**左結合性**

- 一元運算符的結合性强於任何二元運算符。($a+b 是($a)+b)

- 如果一個一元運算符的第一個字符是`@`，它是一個sigil-like 操作符，他的結合性强於一個primarySuffix(首要後綴)[@x.abc被解析为(@x).abc，反之，$x.abc被解析为$(x.abc)]

  ```
  @簽名
  proc `@` * [IDX, T](a: array[IDX, T]): seq[T] {.
    magic: "ArrToSeq", nosideeffect.}
  ```

  **@操作符用於將一個數組轉爲一個序列**

  ```
  type
     intArray=array[0..2,int]
  
  var arr:intArray=[1,2,3]
  echo `@`(arr)     #以过程方式调用
  echo (@arr)       # 操作符调用方式
  
  ```

### 對於不關鍵的二元運算符，優先級

- 以任何一个类似箭头状的符号结束的操作符,如:->,~>，=>，它在所有的操作符中有最低的优先级。
- 如果操作符以=结束并且它的第一个字符不是<, >, !, =, ~, ?中的任何一个，它是一个具有二次最低优先级的赋值运算符。
- 否则，优先级通过第一个字符决定。 如果2个或更多的操作符有相同数量的前置空格，优先表适用，所以1 + 3 * 4仍然被解析为1 + (3 * 4)，但是1+3 * 4被解析为(1+3) * 4







