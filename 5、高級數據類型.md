# 高級數據類型

在Nim中使用`type`語句來定義一個新的類型

一個type部分以關鍵字type開始，可以包含多個類型定義，綁定一個名字給類型，类型定义可以是递归定义，甚至是相互递归。相互递归类型定义只能在一个单一的type部分，普通类型像枚举和对象的定义只能在type语句内，不能在其外部定义。

```
type
	myIntger=int   // 類型別名，本質是int類型
let a:int=2
discard a+myIntger(4)
```

## 枚举类型

Nim中的枚举类似于c中的枚举，但由类型检查，Nim中没有匿名枚举

枚举类型的变量只能被分配一个有限集合中的值，这个集合是由有序的符号组成，每个符号被映射到内部的一个整数值，第一个符号由`0`表示，以此类推

```
type 
    a=enum
     north,east,west,south

var x=south
echo $x,"\n",ord(x)
echo ord(east)   //  
```

结果为：

```
south 
3
1
```

**$操作符可以将任何枚举类型的值转化为它的名字，ord过程得到它的下标整型值**。 

所有的比较运算符能用于枚举类型

```
type
  TE1 = enum eA, eB
  TE2 = enum eC, eD

echo eA < eB
echo eC > eD
#echo eA < eD   #errormsg: "type mismatch"
```

枚举类型的符号可以被指定一个显示的序数值，然而，这些**序数值必须是升序排列**。一个符号的序数值**没有明确的分配**，那么它的**值是前面符号的值加1**。

过程inc、dec、succ和pred。

序数类型操作

| Operation |    Comment    |
| :-------: | :-----------: |
|  ord(x)   | 返回x的整数值 |
|  inc(x)   |    x递增1     |
| inc(x,n)  |    x递增N     |
|  dec(x)   |      x-1      |
| dec(x,n)  |      x-n      |
| succ(x,n) | x后的第n个值  |
|  pred(x)  |  x的前一个值  |
| pred(x,n) |  x前第n个值   |
|  succ(x)  |  x的下一个值  |

### 支持内置的运算符$操作枚举类型

对于枚举编译器支持内置的字符串解析操作符$（注：stringify()用于从一个对象解析出字符串）。stringify()解析的结果可以通过显示的给出字符串值使用控制：

```
type
  MyEnum = enum
    valueA = (0, "my value A"),
    valueB = "value B",
    valueC = 2,
    valueD = (3, "abc")

echo MyEnum.valueA," is same as: ",valueA," ordinal value: ",ord(valueA)
echo ($valueD)
echo ($valueD)," ordinal value: ",ord(valueD)   #这样是错误的 Error: invalid indentation
```

一个枚举类型的符号可以以严格的方式去表示：MyEnum.value，这样可以避免歧义。如果要强制通过MyEnum.value方式来调用，可以**使用pure编译指示标记，以至于使它的字段不被添加到当前的作用域，**

```
type
	myenum{.pure.}=enum
	 valueA,valueB,valueC,valueD
echo valueA    //error unkown identifier
echo myenum.valueA   //works
```

### 枚举名和类型相同：

1. 在同一个模块中，不能出现相同的枚举类型和枚举项，相同的枚举项不可以出现在多个枚举类型中，即使定义在多个type中也不允许出现相同的枚举项
2. 从其他模块导入,外模块中可以出现与当前模块相同的枚举类型以及枚举项
3. 当使用当前模块以及导入模块中相同的枚举类型时,直接屏蔽外模块中的此种枚举类型,使用当前模块中的枚举类型。

### 指定枚举大小

```
type
  TEnumHole {.size: sizeof(int8).} = enum
  	#明确指定枚举类型大小，这个是枚举项的数量，比如该枚举项有256个，2的8次方
  	 eA = 0
     eB = 255,
     eC = 256
    
var
  x: TEnumHole = eB
  y: TEnumHole = eC

echo sizeof(TEnumHole)

echo ord(x)      #echo 255
echo x           #echo eB

echo ord(y)      #echo  0
echo y  #echo eA       #循环到索引 0 了  
```

## 元组

元组变量或对象变量是一个异构的存储器，可以存储不同类型的数据，一个元组或对象定义了各种命名字段的类型，元组作为异构存储类型意味着没有开销和很少可能抽象。

通过构造器 () 来构造元组。在构造器中字段的顺序应该与元组定义时的顺序相同。如果不同的元组类型它们的字段是相同的名称和类型，并且有相同的命名顺序，那么可以认为它们是相同的。

```
type 
 student =tuple[name:string,age:int]
var 
	x:student
x=(name:"sad",age:30)
echo x
```

赋值运算符对于元组将会复制每一个部分，符号t.field是用于访问一个元组的字段。其他的方式是 t[i] 是访问第i个字段。这里的i需要是一个整型常量。

以不同的字段命名创建的元组会被认为是不同的对象，即便二者有相同的字段类型

```nim
var
	x:tuple[name:string,age:int]
	y:tuple[naem:string,age:int]
x=(name:"dfg",age:13)
y=(name:"knm",age:15)
e=y   // error type mismathc
echo x
```

在变量赋值时元组可以被打开（也只有这时），这个可以方便的直接赋给元组单独命名的字段变量，

```
import os

let
  path = "usr/local/nimc.html"
  (dir, name, ext) = splitFile(path)
  baddir, badname, badext = splitFile(path)
echo dir            # outputs `usr/local`
echo name           # outputs `nimc`
echo ext            # outputs `.html`
# All the following output the same line:
# `(dir: usr/local, name: nimc, ext: .html)`
echo baddir
echo badname
echo badext
```

元组结构也可以在var或者let之外

```python
import os
var 
	path = "usr/local/nimc.html"
  	dir, name, ext = ""
(dir, name, ext) = splitFile(path)
echo dir   
echo name
echo ext
```

元组可以像声明一个对象一样定义，在type中通过缩进代替`[]`

```
type 
	person=tuple 
	  name:string
	  age:int
var student:perosn
stduent=(name:"xiaoh",age:32)
echo student
```

```rust
proc test(): int64 =
  return 0xdeadbeef.int64

const items = [
  (var1: test(), var2: 100'u32),
  (var1: test(), var2: 192'u32)
]

echo items[0]
echo items[1]
```

元组或者对象类型的变量是一个异构的存储容器。一个元组或者对象定义了一个类型的各种命名域。一个元组也定义了域的顺序。元组意味着没有开销的异构存储类型以及一些抽象的可能性。构造器()可用于构造元组。构造器中的域的顺序必须匹配元组定义的域的顺序。不同的元组类型如果它们指定的相同类型的相同域有相同的顺序则它们是等价的。域的名字也必须相同。

## 对象

**对于元组的赋值操作复制每一个元素。对于对象的默认赋值操作复制每一个元素。为对象重载赋值运算符是不可能的，**

```
type
  Person = tuple[name: string, age: int] #  类型代表一个人，包含name域和age域
                                         
                                   
var
  person: Person

person = (name: "Peter", age: 30)
#下面这样也是等价的，但是缺少可读性
person = ("Peter", 30)
```

对象提供了很多元组没有的特性，对象提供了继承和信息隐藏，可以子啊运行时访问他们的类型，以便`of`操作可用于确定对象的类型

```
type
  Person {.inheritable.} = object
    name*: string      #   *意味着从其他模块可以访问到`name`
    age: int           #   没有*意味着该域是隐藏的
  
  Student = ref object of Person # a student is a person
    id: int                  # with an id field

var
  student: Student
  person: Person
assert(student of Student)       # is true
assert(student of Person)        # also true
```

与元组不同的是，**不同的对象类型是绝不等价的。没有祖先的对象是隐式的终点**，所以没有隐藏的类型域。可以使用inheritable编译指示引入除了system.RootObj之外的新对象

对象定义了一组域，默认被垃圾收集器跟踪，当分配对象之后，没有必要显示的(free)释放他们。

```
type
  Animal* = object
    name*, species*: string
    age: int

proc sleep*(a: var Animal) =
  a.age += 1

proc dead*(a: Animal): bool =
  result = a.age > 20

var carl: Animal

carl = Animal(name : "Carl",
              species : "L. glama",
              age : 12)

let joe = Animal(name : "Joe",
                 species : "H. sapiens",
                 age : 23)

assert(not carl.dead)

for i in 0..10:
  carl.sleep()

assert carl.dead
```

通常,对象类型在type部分定义. 它们可以被导出，单个字段也可以被导出.字段可以不违反封装的安全导出，因为在它们之间的调用语法是等价的。

> carl在栈上创建并初始化为0,所以它的值是[name = nil, species = nil, age = 0]。它是可变的，所以意味着carl的内容可以改变.这也意味着carl可以传递给一个要求可变参数的过程，如sleep(),它可以修改它的值。
>
> joe也在栈上创建，但是它的内容是不可变的，不能被改变



```nim
type
  Animal* = object
    name*, species*: string
    age: int

proc sleep*(a: var Animal) =
  a.age += 1

proc dead*(a: Animal): bool =
  result = a.age > 20


let mittens: ref Animal = new(Animal)

mittens.name = "Mittens"
mittens.species = "P. leo"
mittens.age = 6

mittens.sleep()    #Error
```



mittens是一个对象的引用在堆上分配。mittens的值不能改变，所以mittens不可能指向其他的任何东西，但是mittens指向的值可以和从默认的初始化值0改变。它的易变性也意味着mittens可以传递给一个要求可变参数的函数。

**在多数情况下，仅想要一个引用类型的对象，通过声明它为ref object为一个引用类型的对象。**

```
type
  Thing* = ref object
    positionX*, positionY*: int


var tValue=Thing(positionX:3,positionY:4)
```

### 对象构造

对象也可以使用一个对象构造表达式来创建，语法如下

```
T(fieldA: valueA, fieldB: valueB, ...)
```

**T** 是一个**obje**类或者时一个**ref obje**

```
var student = Student(name: "Anton", age: 5, id: 3)
```

对于一个ref object类型隐式的调用system.new。

## 序数类型

整型、布尔类型、字符型和连续的枚举型（和这些类型的子类型）都属于序数类型。

| Operation |       Comment       |
| :-------: | :-----------------: |
|  ord(x)   |    返回x的整数值    |
|  inc(x)   |   增加x一个单位值   |
| inc(x,n)  |   增加x n个单位值   |
|  dec(x)   |   减少一个单位值    |
| dec(x,n)  |   减少x n个单位值   |
|  succ(x)  | 返回x的后续第一个值 |
| succ(x,n) |  返回x的后续n个值   |
|  pred(x)  | 返回x前序的第一个值 |
| pred(x,n) | 返回x前序的第n个值  |

inc,  dec,succ, pred 可能会一起EOutOfRange 或 EOverflow异常

```
{.overflowChecks:off}
type
  Direction = enum
    north, east, south, west

var x:Direction = north

echo sizeof(x)       #枚举类型所占字节数
inc(x,256)
echo x               #echo north
```

**程序中添加overflowChecks编译指示，当为off也就是关闭时，程序运行时不会检查是否越界，**由上面这个程序可知，该枚举类型大小为1个字节，x的值增加256个单位时，又循环到了north。如果编译指示为on也就是打开时，该程序运行时会出现错误： **over- or underflow [OverflowError]。**

### 序数类型的特点：

- 序数类型是可计算的和有序的，这个特性允许inc、ord、dec这些操作用于序数类型
- 序数值有一个最小的可能值，如果尝试着计算比最小值还小的值，那么需要给一个运行时检查或者会产生一个静态错误。
- 序数值有一个最大的可能值，如果尝试着计算比最大值还大的值，那么需要给一个运行时检查或者会产生一个静态错误。

## 字界类型(区间类型)

 一个子界类型是一个序数类型（基类型）值的范围，定义一个子界类型，必须要指定它的限定值(最大值和最小值)

```
type
	s=range[0..10]
var x:s
x=3
echo x
```

s是int的一个子界类型，取值范围是0到10，分配任何其他的值给**S**类型的变量都会产生编译错误或运行时错误，从基类型到一个它的子类型作为值分配给变量是允许的。一个子界类型与它的基类型同样的大小。

```
type s=range[0..9]

var x:s=8
case x
of 0..3:echo 2
of 4..6:echo 5
of 7..9: echo 10 
```

nim要求子界类型的区间算法涵盖一组涉及常数的内置操作符:

x%%3是range[0..2]

对于整型数的内置操作符都受这种规则的影响:-,+,*,min,max, succ,pred, mod,div,%%,and (bitwise and按位与)按位与只产生一个range如果它的一个操作数是一个常数x所以（x+1）是两个数。(按位与则是%%操作.)



```
var x:int

case (x and 3) + 7   #(x and 3) + 7是range[7..10]
of 7: echo "A"
of 8: echo "B"
of 9: echo "C"
of 10: echo "D"
# note: no ``else`` required as (x and 3) + 7 has the type: range[7..10]
#注意:没有"else"要求(x and 3)+7有range[7..10]类型

case (x and 3)*2+7:    #(x and 3)*2+7是range[7..13]
of 7:echo "0"
of 9:echo "9"
of 11:echo "11"
of 13:echo "13"
#以上并没有覆盖所有的可能值
of 8,10,12:echo "other value"


type
  Subrange = range[1..2]

var 
  sValue:Subrange
  iValue:int

sValue=1

case (sValue*2):   #(sValue*2)是range[2..4]
of 4:echo "4"
of 2:echo "2"
of 3:echo "3"

case ((iValue mod 2)*2): #((iValue mod 2)*2)是range[-2..2]
of 0:echo "0"
of -2:echo "-2"
of 2:echo "2"
of -1:echo "-1"
of 1:echo "1"
```



## 集合

集合的基类型只能是一种具有一定规模的序数类型，也就是：

- int8-int16
- uint8/byte-uint16
- char
- enum

**集合是以高性能位向量来实现的，试图用一个大类型来声明一个集合将会导致一个错误**

```
var s:set[int64]
// error :set is too large
```

通过集合构造器来构造一个集合：{}是一个空集合，空集合是兼容任何的集合类型，构造器也可以带有元素（和元素的范围）

```
type 
	inset=set[int8]
var x:inset
x={1'i8,2'i8}
echo x
```



```
type
  color = enum
    red, yellow, blue, green, white

  enumSet = set[color]
var
  x: enumSet
x = {yellow..green}
echo x

type
  CharSet = set[char]
var
  x: CharSet
x = {'a'..'z', '0'..'9'} # This constructs a set that contains the
                         # letters from 'a' to 'z' and the digits
                         # from '0' to '9'
echo x
```

| operation      | meaning                          |
| -------------- | -------------------------------- |
| A + B          | 两个集合的并集                   |
| A * B          | 两集合的交集                     |
| A - B          | 两个集合的差集(A中没有B中的元素) |
| A == B         | 集合相等                         |
| A <= B         | 子集关系 (A是B的子集或者与B相等) |
| A < B          | 强子集关系 (A是 B的真正子集)     |
| e in A         | 集员关系 (A 包含元素 e)          |
| e notin A      | A 不包含元素 e                   |
| contains(A, e) | A 包含元素 e                     |
| card(A)        | 集合A的基数(A中元素数量)         |
| incl(A, elem)  | same as A = A + {elem}           |
| excl(A, elem)  | same as A = A - {elem}           |

集合中的每一个可能的元素消耗一bit位，因此一个«2^{16}»元素的位集合将消耗64KiB. 位集合有数学集合所有有用的操作

| operation | meaning                       | Example Code                               |
| --------- | ----------------------------- | ------------------------------------------ |
| a in B    | is a an element of B?         | 'd' in {'a'..'z'}                          |
| a notin B | is a not an element of B?     | 40 notin {2..20}                           |
| A + B     | union of A with B             | {'a'..'m'} + {'n'..'z'} == {'a'..'z'}      |
| A - B     | relative complement of A in B | {'a'..'z'} - {'b'..'d'} == {'a', 'e'..'z'} |
| A + b     | add element b to set A        | {'b'..'z'} + 'a' == {'a'..'z'}             |
| A - b     | remove element b from set A   | {'a'..'z'} - 'a' == {'b'..'z'}             |
| A * B     | intersection of A with B      | {'a'..'m'} * {'c'..'z} == {'c'..'m'}       |
| A <= B    | is A a subset of B?           | {'a'..'c'} <= {'a'..'z'}                   |
| A < B)    | is A a strict subset of B?    | {'b'..'c'} < {'a'..'z'}                    |

## 数组

固定长度的容器，数组的每一个元素有相同的类型，数组的索引可以是任何的序数类型，通过`[]`构造数组

```
type
  IntArray = array[0..5, int]     # an array that is indexed with 0..5
var
  x: IntArray
x = [1, 2, 3, 4, 5, 6]
for i in low(x)..high(x):     #low(x),high(x)返回数组的最下索引和最大索引
  echo(x[i])
```



x[i]是用来访问数组x的第i个元素，数组访问总是有边界检查的（在编译时或运行时）。这些检查能够通过编译指示来关闭掉或者通过编译命令 **--bound_checks:off**来关闭边界检查。

```
{.boundChecks:off.}
//  或者使用命令行参数 nim c --bound_checks:off -r name

var x=[1,2,3]
echo rper(x)
echo x[9]
```

**数组是一个值类型，赋值运算符复制数组的整个内容。**

len 数组的长度，low(a) 最小索引， high(b) 最大索引

Nim中多维数组中在不用的维度可以使用不同类型的索引（序数类型：整型、字符型、布尔类型、连续的枚举型等）

多维数组的定义：

```
type
  Direction = enum
    north, east, south, west
  BlinkLights = enum
    off, on, slowBlink, mediumBlink, fastBlink
  LevelSetting = array[north..west, BlinkLights]
  LightTower = array[1..10, LevelSetting]
var
  tower: LightTower
tower[1][north] = slowBlink
tower[1][east] = mediumBlink
echo len(tower) # --> 10
echo len(tower[1])  # --> 4
```

注：内建的过程len仅仅返回数组的一个维度的长度，在这个例子中定义了一个二维数组类型LightTower，它的一个维度的索引是枚举类型，另一个维度的索引是整型。也有其他的定义类型LightTower的方式，并且更能展示它的嵌套性质的放式是省略前面定义的LevelSetting类型，直接在里面嵌套写出这个类型。

二维数组

```
type
	a=array[3,int]
	b=array[3,a]
var c:b=[[1,2,3],[4,5,6],[7,8,9]]
echo c

```

三维数组：

```
type
  ODArray = array[2,int]
  TDArray = array[2,ODArray]
  ThDArray = array[2,TDArray]

var myarray2:ThDArray = [[[1,2],[3,4]],[[5,6],[7,8]]]
echo myarray2[0][0][0]
```

数组从索引0开始，因此这里有一个快捷的语法去指定从0到指定的索引减1的范围

```
type
  IntArray = array[0..5, int] # an array that is indexed with 0..5
  QuickArray = array[6, int]  # an array that is indexed with 0..5
var
  x: IntArray
  y: QuickArray
x = [1, 2, 3, 4, 5, 6]
y = x
for i in low(x)..high(x):
  echo(x[i], y[i])
```

```
type
  IntArray = array[0..5, int] # 索引值为0..5的数组
  QuickArray = array[6, int]  # 索引值为0..5的数组

var
  x: IntArray
  y: QuickArray
x = [1, 2, 3, 4, 5, 6]
y = x
for i in low(x)..high(x):
  echo x[i]," ",y[i]
```

Nim中的数组类似于Clang中的数组，在编译时确定大小，并不能在运行时修改

可选择的索引数组的方法也是允许的，第一个类型参数实际上是一个范围(仅一个值，如上，对于0..N-1是语法糖)。使用序数类型去索引一个数组也是可能的，有效地创建一个查找表:

```
type
  Matrix[W, H: static[int]] =
    array[1..W, array[1..H, int]]

let mat1: Matrix[2, 2] = [[1, 0],
                          [0, 1]]
let mat2: Matrix[2, 2] = [[0, 1],
                          [1, 0]]

proc `+`[W, H](a, b: Matrix[W, H]):
               Matrix[W, H] =
  for i in 1..high(a):
    for j in 1..high(a[0]):
      result[i][j] = a[i][j] + b[i][j]

# See `$` from the procs section

echo repr(mat1+mat2)    
```

## 序列

类似于数组，但是长度可以在运行时更改，序列是作为可变长度数组来实现的，随着元素被添加分配新的内存。**一个序列S总是通过整数索引，其范围是0到len(S)-1，并且是有边界检查的。由于序列是可调整大小的，所以他们总是被分配在堆上，并且可以垃圾回收**。

使用`[]`来构造序列,`@` 把数组转为序列，其他的方式是通过**内置的newSeq来分配空间给一个序列**

```
var 
	x:seq[int] 
x=@[1,2,34]
echo x
```

```
var inputStrings : seq[string]
newSeq(inputStrings, 3)
inputStrings[0] = "The fourth"       #创建一个序列后，要用赋值语句，而不是add
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"    #error
echo inputStrings
```

一个序列可能被传递给openarray参数,openarray 只能作为参数使用

```
proc seqAdd(x:openArray[int]):int=
  for i in x:
     reslut=result+i
var x:seq[int]= @[1,2,3,4]
echo seqa=Add(x)
```

注：  注意**@**和**等号之间要有空格**

序列变量默认的初始化为nil，然而大多数的序列操作考虑到性能原因不能处理nil，因此应该使用一个空序列`@[]`而不是nil作为空值。但是`@[]`会在堆上创建一个序列对象

> 对于for语句在使用一个序列时可以用一个变量或是两个变量，当你使用一个变量时，这个变量将会是序列提供的元素，For语句会使用system模块中的items()迭代器去迭代序列。但是如果你使用两个变量，那么第一个变量将会是位置的索引，第二个变量会是序列的值，这个时候for语句将会使用pairs()迭代器。

```
for i in @[3,4,5]:
  echo $i
# --> 3
# --> 4
# --> 5

for i, value in @[3, 4, 5]:
  echo("index: ", $i, ", value:", $value)
  # --> index: 0, value:3
# --> index: 1, value:4
# --> index: 2, value:5
```

序列索引总是以一个int型0位置开始，len、low和high操作能够用于序列类型，符号x[i] 是访问序列x的第i个元素。序列的边界可以通过内建的过程low()和high()得到，它们分别返回最小索引和最大索引。

通过**add()**或 **&**来向一个序列添加元素，  通过**pop()**删除/得到最后一个元素

```
var 
  x: seq[int]
x = @[1,2,3,4,5]
echo x

x.add(6)  
echo x          #add过程添加元素到序列x

echo x & 7      # &只是返回一个连接后的序列，而x并没有改变
echo x
```

**delete()**删除第几个元素

```
var
  a = @[1, 2, 3]
  b = newSeq[int](3)

for i, v in a:
  b[i] = v*v

for i in 4..100:
  b.add(i * i)

b.delete(0)  # takes O(n) time      #删除第0个元素
b = a[0] & b  # Same as original b
```

**不变性**： 虽然序列是动态分配的，但是他们依然是不可变的

```
let a= @[1,2,3]
a.add(4)   // 编译失败    let 运行时不可变
```

```
var b= @[1,2,3,4]
b.pop()
```

一个序列可以传递给一个方法使用var或者ref标记使它更改,所以:

```
proc foo(mySeq: var seq[int]) =
  mySeq[9] = 999

var thisSeq = newSeq[int](10)
foo(thisSeq)

assert thisSeq[9] == 999
```

### varargs

一个varargs参数是一个openarrar参数，它允许像过程传递一个可变数量的参数，编译器会自动地转换这个列表参数为一个数组

**如果变参数在程序头中是最后一个参数这个转变才会发生**

```
proc p1(f:File,a:varargs[string])=
	for s in item(a):
	   write(f,s)
	write(f,"\n")
p1(stdout,"adbv","asdw")

myWriteln(stdout, ["abc", "def", "xyz"])
```

#### 俩例子

```
proc myWriteln(f: File, a: varargs[string, `$`]) =
  for s in items(a):
    write(f, s)
  write(f, "\n")

myWriteln(stdout, 123, "abc", 4.0)
# is transformed by the compiler to:
myWriteln(stdout, [$123, $"abc", $4.0])
```



```
proc myWriteln2(f: File, a: varargs[int, `-`]) =
  for s in items(a):
    writeln(f, s)

myWriteln2(stdout,-1,-2,-3)
#is the same as:
myWriteln2(stdout,[-1,-2,-3])
```

以上的程序中运算符`$`和`-`用于传递参数给a的任何实参，

**运算符`$`用于字符串是一个空操作。将一个显示的数组构造器传递给一个可变参数是不包含在另一个隐式的数组结构中的**

## 切片

切片在语法上看起来与子界类型相似，但是它用于不同的语境中。一个切片仅仅是Slice类型的一个对象，它包含两个边界

定义为：

```
type
  Slice*[T]=object
    a*,b*:T    //the bounds
```

由定义可以看出切片是一个泛型的对象，它有两个边界：a和b。

#### 字符串切片

```
var 
  x: Slice[int]
  str = "012345"
x.a = 0
x.b = 2
echo str[x]
echo(x is Slice)   // 判断x是否为切片
```

字符串的切片操作，切片类型只能为整型

```
var
  a = "Nim is a progamming language"
  b = "Slices are useless." 
  siValue:Slice[int]


siValue= 1..3

echo a[1..3]            #`[]`过程的调用方式是单一的  string[Slice[int]]
echo a[siValue]
#echo ([].(a,siValue))  #error
#echo 1..3.[a]          #error
```

切片为字符串赋值。如果b.len不恰好是x引用的元素的数量，将执行拼接:即将x替换为b

```
var s = "abcdef"
s[1 .. ^2] = "xyz"
assert s == "axyzf"
```

切片类型在字符串中的作用：

- 索引值从左往右0..string.len-1;索引值从右往左:-(string.len)..-1
- 界限值a,b都不能越界,否则出现越界错误
- 从索引上界处开始依次替换字符串;若索引位置a在b的左侧,则替换索引a到b之间的字符串;若索引位置a在b的右侧,则替换从索引位置a开始,替换将要替换字符串长度的字符,替换向后进行

#### 数组切片

对数组的切片操作，且**切片的类型只能为整型，返回序列类型**

**切片为数组赋值。且要替换的长度必须等于x的长度。**

```
var 
  x: Slice[int]
  arr = [1,2,3,45,6]
x.a = 1
x.b = 2
echo arr[x][0..1]
```

```
var x = "012345"
echo x[0..2]
echo x[^2..^1]     #^表示负号
echo x[0..^1]
echo x[..2]
#echo x[0..]      #error

x[1..3] = "abc"       # 赋值长度相同
echo x           #echo  0abc45

x[1..3] = "abcdef"    #大于切片长度    原来的abc替换成了abcdef
echo x        #echo  0abcdef45

x[1..3] = "12"       #小于切片长度     原来的abc替换成了12
echo x        #echo  012def45
```



```
var
  a = "Nim is a progamming language"
  b = "Slices are useless."

echo a[7..12] # --> 'a prog'
b[11..^2] = "useful"
echo b # --> 'Slices are useful.'
```



```
var x = (1..3)   #切片
echo x 
echo(x is Slice)

var y = {1..3}    #集合     y = {x}  #error
echo y
echo(y is set)

echo((1..3) is set)
```

**..过程是切片的构造器**. **直接使用..过程构造，也可以先声明，再用..进行初始化**

```
proc `..`*[T](a, b: T): Slice[T]
```



#### 其他操作

**contains检查value是否在slice中**

```
assert((1..3).contains(1) == true)
```

```
type
  PureColor=enum
    pcRed,pcOrange,pcYellow,pcGreen,pcBlue,pcPurple

var seValue:Slice[PureColor]

seValue= ..pcBlue

assert(seValue.contains(pcYellow)==true)
```

#### 序列切片

对序列的切片操作，切片类型为整型，返回序列，切片为序列赋值。如果b.len不恰好是x引用的元素的数量，将执行拼接:即将x替换为b

```
type
  PureColor=enum
    pcRed,pcOrange,pcYellow,pcGreen,pcBlue,pcPurple

var
  siValue:Slice[int]
  iSeq:seq[int]
  cSeq:seq[char]
  fSeq:seq[float]
  sSeq:seq[string]
  eSeq:seq[PureColor]

siValue= 1..3

iSeq= @[1,2,3,4,5,6]
cSeq= @['a','b','c','d','e']
fSeq= @[1.1,2.2,3.3,4.4,5.5,6.6]
sSeq= @["a1","b2","c3","d4","e5","f6"]
eSeq= @[pcRed,pcOrange,pcYellow,pcGreen]

echo iSeq[siValue]
echo cSeq[siValue]
echo fSeq[siValue]
echo sSeq[siValue]
echo eSeq[siValue]

iSeq[siValue]= @[11,22,33,44,55]
echo iSeq

cSeq[siValue]= @['w']
echo cSeq
```

















