# 對象

在Nim中，對象和元組類似，對象也是把一些列不同的東西放到一起的一種方式，對象提供了繼承和信息隱藏，由於對象的特性所以對象的封裝性，所以對象的构造方法只能用於對象的内部(初始化對象===》構造器)

在運行期間訪問一個對象的實例使用關鍵字`of`

```c++
type
	Person =ref object of RootObj
	   name* :string
	   age:int
	   
	Student =ref objcet of Person
    id :int

var
	student:Student
	person:Person
assert(stduent of Student)

student=Student(name:"..",age:13,id:7)
echo stduent[]
```

**對象類型只能通過`type`定義，**nim中的對象支持繼承，如果一個對象沒有合適的父類，可以使**用RootObject作爲父類**，使用`ref`明確繼承關係，在設計上組合優於繼承

### 自引用對象類型

```python
type
  Node = ref NodeObj # a traced reference to a NodeObj
  NodeObj = object
    le, ri: Node     # left and right subtrees
    sym: ref Sym     # leaves contain a reference to a Sym
   
  Sym = object       # a symbol
    name: string     # the symbol's name
    line: int        # the line the symbol was declared in
    code: PNode      # the symbol's abstract syntax tree

```

### 類型轉換

Nim支持顯示和隱式類型轉換，使用`casts`完成顯示類型轉換，顯示類型轉換工作是編譯期完成的，是位模式， 隱式轉換在編譯器完成，不是位模式

### 對象變型

```python
type
  NodeKind = enum  # the different node types
    nkInt,          # a leaf with an integer value
    nkFloat,        # a leaf with a float value
    nkString,       # a leaf with a string value
    nkAdd,          # an addition
    nkSub,          # a subtraction
    nkIf            # an if statement
  Node = ref NodeObj
  NodeObj = object
    case kind: NodeKind  # the ``kind`` field is the discriminator
    of nkInt: intVal: int
    of nkFloat: floatVal: float
    of nkString: strVal: string
    of nkAdd, nkSub:
      leftOp, rightOp: PNode
    of nkIf:
      condition, thenPart, elsePart: PNode
 
var n = PNode(kind: nkFloat, floatVal: 1.0)
# the following statement raises an `FieldError` exception, because
# n.kind's value does not fit:
n.strVal = ""
```



## 方法調用

`obj.method(args)`

```python
echo "abc".len
echo "abc".toUpper()

import strutils
 
stdout.writeln("Give a list of numbers (separated by spaces): ")
stdout.write(stdin.readLine.split.map(parseInt).max.`$`)
stdout.writeln(" is the maximum!")
```

## 屬性

```python
type 
	Socket*=object of RootObj
	Fhost:int
	
	
proc `host=`*(s:var Socket,value:int){.inline.}=
	s.Fhost=value

proc host*(s:Socket):int{.inline.}=
    s.Fhost
    
var s:Socket    
new s
s.host=32
```

``Socket`類有兩個方法，`host`方法用來獲取其屬性值，另一個則是設置值。

### 重載運算符

```python
type
  Vector* = object
    x, y, z: float
 
proc `[]=`* (v: var Vector, i: int, value: float) =
  # setter
  case i
  of 0: v.x = value
  of 1: v.y = value
  of 2: v.z = value
  else: assert(false)
 
proc `[]`* (v: Vector, i: int): float =
  # getter
  case i
  of 0: result = v.x
  of 1: result = v.y
  of 2: result = v.z
  else: assert(false)
```

## 動態指派方法

需要使用``method`來代替proc，就可以動態指派特性

```python
type
    Thing = ref object of RootObj
    Uint = ref object of Thing
        x: int

method collide(a, b: Thing){.inline.} =
    quit "to override!"

method collide(a: Thing, b: Uint){.inline.} =
    echo "1"

method collide(a: Uint, b: Thing){.inline.} =
    echo "2"

var a:Thing 
var b: Uint
new a
new b
collide(a,b)

```

Nim 不产生虚方法表





















