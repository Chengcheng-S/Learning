# 语句和表达式

Nim使用通用得语句/表达式返利：与表达式相比，**语句不会产生值**，但是，有的表达式是语句。

语句分为**简单语句**和**复杂语句**

简单语句是不能包含**调用、赋值、return**的语句 ； 

复杂语句可以包含其他语句，为了避免dangling else的问题，复**杂语句必须缩进**

## 语句列表表达式

语句也可以出现在类似于(stmt1; stmt2; …; ex)的表达式上下文中。语句也可以出现在表达式上下文中，这叫做语句列表表达式

### Discard表达式

```
proc p(x,y:int):int=
  result =x+y
discard p(3,4)  // 丢弃p的返回值 
```

discard 语句评估其副作用的表达式，并丢弃表达式的结果。在**不**使用discard语句的情况下**忽略**过程的返回值是一个**静态错误**

如果使用**discardable** 编译指示声明了被调用的**proc** 或**iterator**，则可以**隐式忽略返回值** 

```python
proc p(x, y: int): int {.discardable.} =
  result = x + y
 
p(3, 4) # now valid
```

**空的discard语句通常作为null语句**

```
proc classify(s: string) =
  case s[0]
  of SymChars, '_': echo "an identifier"
  of '0'..'9': echo "a number"
  else: discard
```

### Void 上下文

在语句列表中，除最后一个表达式之外的每个表达式都需要**具体类型void**

此外，对于内置的**result**符号的赋值也会**触发后续表达式的强制void上下文**

```
proc invalid*():string=
  result ="foo"
  "invalid"  //  错误 string类型值必须丢弃
```

```
proc valid*():string=
  let x = 222
  "valid"
```

### var语句

var语句声明新的局部变量和全局变量并初始化它们。逗号分隔符的变量列表可用于指定相同类型的变量。

```
var 
  a:int=0
  x,y,z:int
```

给出**初始值设定项，则可以省略该类型**：该变量的类型与初始化表达式的类型相同。 如果**没有初始化表达式，变量总是使用默认值初始化**。 默认值取决于类型，并且在二进制中始终为零。

| 类型                 | 默认值                                                       |
| :------------------- | :----------------------------------------------------------- |
| any integer type     | 0                                                            |
| any float            | 0.0                                                          |
| char                 | '\0'                                                         |
| bool                 | false                                                        |
| ref or pointer type  | nil                                                          |
| procedural type      | nil                                                          |
| sequence             | @[]                                                          |
| string               | ""                                                           |
| tuple[x: A, y: B, …] | (default(A), default(B), …) (analogous for objects)          |
| array[0…, T]         | [default(T), …]                                              |
| range[T]             | default(T); this may be out of the valid range               |
| T = enum             | cast[T](https://www.bookstack.cn/read/nim-1.0.2-zh/0); this may be an invalid value |

处于优化的原因，可以使用**noinit** 编译指示来**避免隐式初始化**

```
var a{.noinit.}:array[0..1023,char]
```

对于一个**过程**使用**noinit**指示，则指的是**它隐含的result变量**。

```
proc returnUndefinedValue: int {.noinit.} = discard
```

**隐式初始化**可以用 **requiresInit**类型编译指示**阻止**，编译器需要对**对象以及所有字段**进行**显式初始化**，然而它执行**控制流分析证明变量已经初始化并且不依赖于语法属性**

```
type
  mYobject=object{.requiresInit.}
proc p()=
  //  此间内容有效
  var x:mYobject
  if someCondition():
      x=a()
  else:
      x=a()
  //  use  x    
```

### Let  语句

let语句声明了**新的本地和全局单次赋值变量并绑定值**

语法上类似于var语句，

 **Let变量不是左值因此不能传递给 var 参数，也不能采用它们的地址。他们无法分配新值。**

对于let变量，可以**使用与普通变量相同的编译指示。**











