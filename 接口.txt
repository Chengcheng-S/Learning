接口定义： 一组方法签名，当某个类型为这个接口中的所有方法提供了方法的实现，称为实现接口
type name  interface{

  filed
  ......
  filed
}

GO语言中接口和类型的实现关系为非侵入式
接口对象不能访问实现类当中的属性


定义接口：
type Sayer interface{
	say()
}

定义两个结构体
func dog struct{

}

func cat struct{

}

接口调用
func (d dog)say(){
	fmt.Println("......")
}

func(c cat)say(){
	fmt.Println("......")
}

接口实现：
    实现了接口中的所有方法,就实现了这个接口。一个对象只要全部实现了接口中的方法，那么就实现了这个接口，接口就是一个需要实现的方法列表

多态： 一个事务的多种形态
     go语言通过接口模拟多态
接口实现： 
	1、实现本身的类型，能够访问实现类中的属性和方法
	2、对应的接口的类型，只能够访问接口中的方法

接口的用法：
	1）一个函数如果接受接口类型作为参数，那么实际上可以传入该接口的任意实现类型对象作为参数
	2）定义一个类型为接口类型，实际上可以赋值为任意实现类的对象
		

空接口：
     不包含任何的方法，所有类型都实现了空接口，空接口可以存储任意类型的数据

     fmt 包下的print系列函数，都是空接口 


接口嵌套：
    type A interface{
     test1()
}

    type  B interface{
     test2()
    }


type c interface{
    A
    B
}

type cat struct{
    
}


func (c cat)test3(){
    fmt.Println("......")
}





接口值： 由一个具体类型和具体类型的值两部分组成，分别称为动态类型和动态值

判断接口中的值可以使用类型断言
格式： x.(T) x：表示类型为接口的变量
	T：表示断言x可能的类型
	返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个bool，若为true' 表示断言成功，为false 表示断言失败

方法1： 1)instance:=接口对象.(实际类型) // 不安全会panic()
	2)instance,ok :=接口对象(实际类型)// 安全

方法二： switch
switch instance :=接口对象.(type){
	case 实际类型1:
		....
	case 实际类型2：
	     ......

	default:
	.....

}
断言.go


